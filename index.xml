<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://gaohongy.github.io/blog/</link><description/><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Fri, 02 Aug 2024 10:58:33 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Debugging With GDB</title><link>https://gaohongy.github.io/blog/posts/project-experience/debugging-with-gdb/</link><pubDate>Fri, 02 Aug 2024 10:58:33 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/project-experience/debugging-with-gdb/</guid><description>How to launch a program There are three ways to launch a program:
run: Start debugged program. If we don&amp;rsquo;t set any breakpoints, it will run directly until get to the end of execution. start: Start the debugged program stopping at the beginning of the main procedure. starti: Start the debugged program stopping at the first instruction. </description></item><item><title>Program Loading</title><link>https://gaohongy.github.io/blog/posts/compile-link/program-loading/</link><pubDate>Fri, 02 Aug 2024 09:54:09 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/compile-link/program-loading/</guid><description>Before the program running, static loader or dynamic loader need to initialize the content of the progress stack which is stipulated by System V Application Binary Interface.</description></item><item><title>ELF File Format Analysis</title><link>https://gaohongy.github.io/blog/posts/compile-link/elf-file-format-analysis/</link><pubDate>Thu, 13 Jun 2024 14:49:02 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/compile-link/elf-file-format-analysis/</guid><description>What is ELF ? ELF: Executable and Linkable Format, 可执行与可链接格式 ELF格式文件分类 文件类型 说明 实例 可重定位文件(Relocatable File) Linux的.o (对应Windo</description></item><item><title>Heterogeneous Compilation</title><link>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</link><pubDate>Fri, 07 Jun 2024 09:49:52 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</guid><description>与 CUDA Compilation 不同在于 The tools used in the CUDA compilation are all closed source except gcc, g++ etc., for example fatbinary and nvlink. We need to substitue these tools to tools in clang system. Clang Offload Bundler is used to combined different code for different machine structurel. Clang Offload Packager is used to embed device code into host code. Clang Linker Wrapper is used to .</description></item><item><title>Several Methods For Obtaining Time</title><link>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</link><pubDate>Tue, 04 Jun 2024 11:38:22 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</guid><description>We can reference this article
About the last method that using rdtsc assembly command to obtain time, there are some error prone points, we can reference to this article.
If you want to learn about the TST, please reference to this article.</description></item><item><title>SIMD Extension</title><link>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</link><pubDate>Mon, 03 Jun 2024 16:09:29 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</guid><description>说明 SIMD Extension 的各种函数中参数的顺序以及各种函数的实现机制都是遵循着机器在实际存储时采用的小端序，注意在和数组混用时可能会产生一定思维上的混乱。 Categories</description></item><item><title>OpenMP</title><link>https://gaohongy.github.io/blog/posts/hpc/openmp/</link><pubDate>Tue, 30 Apr 2024 20:49:00 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/openmp/</guid><description><![CDATA[Check the OpenMP version 1 2 3 4 5 6 7 8 9 10 #include &lt;stdio.h&gt; int main() { #ifdef _OPENMP printf(&#34;OpenMP version: %d\n&#34;, _OPENMP); #else printf(&#34;OpenMP is not supported.\n&#34;); #endif return 0; } If system supports the OpenMP, you will receive similar output results OpenMP version: 201511 &ldquo;201511&rdquo; means that this OpenMP is released in November 2015. Next, you need to go to this official website to search the]]></description></item><item><title>Matrix Multiplication</title><link>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</link><pubDate>Sun, 28 Apr 2024 10:00:06 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</guid><description>GEMM（General Matrix Multiplication）-通用矩阵乘 BLAS (Basic Linear Algebra Subprograms) - 基本线性代数子程序 SGEMM (Single precision General Matrix Multiply) - 单精度矩阵乘法 DGEMM (Double precision General Matrix Multiply) -</description></item><item><title>Debugging in Visual Studio Code</title><link>https://gaohongy.github.io/blog/posts/project-experience/debugging-in-visual-studio-code/</link><pubDate>Thu, 18 Apr 2024 11:48:47 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/project-experience/debugging-in-visual-studio-code/</guid><description>整体理解 从宏观上来讲，调试程序的两大场景： 单程序写完后直接运行调试 大型项目编译完成后，需要结合源码对某一个可执行程序进行执行流分析 实际上这看</description></item><item><title>Polymorphism</title><link>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</link><pubDate>Mon, 15 Apr 2024 11:54:10 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</guid><description>谈及多态主要是在考虑具有继承关系的多个类型之间的关系。考虑多态的核心在于引用或指针的 静态类型 与 动态类型 是可能不同的 静态多态 和 动态多态 的一个明</description></item></channel></rss>