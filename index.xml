<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title/><link>https://gaohongy.github.io/blog/</link><description/><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 14 Sep 2024 17:10:35 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Terminal</title><link>https://gaohongy.github.io/blog/posts/linux/terminal/</link><pubDate>Sat, 14 Sep 2024 17:10:35 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/linux/terminal/</guid><description><![CDATA[<table>
  <thead>
      <tr>
          <th style="text-align: left">特性</th>
          <th style="text-align: left">真实的虚拟终端 (VT)</th>
          <th style="text-align: left">伪终端 (PTS)</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">硬件依赖</td>
          <td style="text-align: left">直接与物理硬件（显示器、键盘）交互</td>
          <td style="text-align: left">软件仿真，不直接与物理硬件交互</td>
      </tr>
      <tr>
          <td style="text-align: left">设备文件</td>
          <td style="text-align: left">/dev/tty1, /dev/tty2 等</td>
          <td style="text-align: left">/dev/pts/0, /dev/pts/1 等</td>
      </tr>
      <tr>
          <td style="text-align: left">使用场景</td>
          <td style="text-align: left">物理机的控制台登录，无需图形界面</td>
          <td style="text-align: left">图形终端仿真器、远程登录（如 SSH）会话</td>
      </tr>
      <tr>
          <td style="text-align: left">固定数量</td>
          <td style="text-align: left">通常有 6 个或更多虚拟终端</td>
          <td style="text-align: left">动态创建，按需分配</td>
      </tr>
      <tr>
          <td style="text-align: left">终端切换方式</td>
          <td style="text-align: left">Ctrl + Alt + F1 到 Ctrl + Alt + F6</td>
          <td style="text-align: left">软件仿真器或通过网络远程连接，如 ssh 登录</td>
      </tr>
  </tbody>
</table>
<p>通过 <code>/proc/&lt;PID&gt;</code> 可以查看进程的相关信息，一些命令的实现也是基于这个文件</p>]]></description></item><item><title>Linux Device Drivers</title><link>https://gaohongy.github.io/blog/posts/linux/linux-device-drivers/</link><pubDate>Sat, 14 Sep 2024 14:57:57 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/linux/linux-device-drivers/</guid><description><![CDATA[<h2 id="io-设备" class="heading-element"><span>IO 设备</span>
  <a href="#io-%e8%ae%be%e5%a4%87" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>IO 设备的基本形态就是一些寄存器(以及一些 protocol，说明在寄存器接收到某些值时要做出何种处理） + 控制器，从而能够与 CPU 交互数据，通过 mmap 的方式映射到内存空间中，CPU 可以对这些寄存器的值进行修改</p>]]></description></item><item><title>Runtime</title><link>https://gaohongy.github.io/blog/posts/graph-computing/runtime/</link><pubDate>Wed, 11 Sep 2024 14:41:40 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/runtime/</guid><description><![CDATA[<p>在主板上增加 PLX 芯片以提供更多的 PCIe 通道</p>
<p>PCIe 设备插到 PCIe 插槽需要由 PLX 芯片提供支持</p>
<p>一个PCIe插槽在物理层面上确实只能插入一个设备。例如，你只能插入一张显卡或一块SSD到一个PCIe插槽中。但是通过PLX芯片等交换设备，可以让多个PCIe设备通过该插槽共享带宽并同时被RC识别和使用(PLX芯片实际上是在分配带宽，这并没有改变某一时刻 RC 只会和某个插槽上的一台设备进行通信的事实，对于资源有限的PCIe插槽环境比较有意义）</p>]]></description></item><item><title>Debugging With GDB</title><link>https://gaohongy.github.io/blog/posts/project-experience/debugging-with-gdb/</link><pubDate>Fri, 02 Aug 2024 10:58:33 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/project-experience/debugging-with-gdb/</guid><description><![CDATA[<h2 id="how-to-launch-a-program" class="heading-element"><span>How to launch a program</span>
  <a href="#how-to-launch-a-program" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>There are three ways to launch a program:</p>]]></description></item><item><title>Program Loading</title><link>https://gaohongy.github.io/blog/posts/compile-link/program-loading/</link><pubDate>Fri, 02 Aug 2024 09:54:09 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/compile-link/program-loading/</guid><description><![CDATA[<p>Before the program running, static loader or dynamic loader need to initialize the content of the progress stack which is stipulated by <a href="https://jyywiki.cn/OS/manuals/sysv-abi.pdf"target="_blank" rel="external nofollow noopener noreferrer">System V Application Binary Interface</a>.</p>
<p><a class="lightgallery" href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png</h2>"><img loading="lazy" src="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png" alt="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png" srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png?size=large 2x" data-title="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202408020952442.png" style="background: url(/blog/images/loading.min.svg) no-repeat center;" onload="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}this.dataset.lazyloaded='';" onerror="this.title=this.dataset.title;for(const i of ['style', 'data-title','onerror','onload']){this.removeAttribute(i);}"/></a></p>]]></description></item><item><title>ELF File Format Analysis</title><link>https://gaohongy.github.io/blog/posts/compile-link/elf-file-format-analysis/</link><pubDate>Thu, 13 Jun 2024 14:49:02 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/compile-link/elf-file-format-analysis/</guid><description><![CDATA[<h2 id="what-is-elf-" class="heading-element"><span>What is ELF ?</span>
  <a href="#what-is-elf-" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><blockquote>
<p>ELF: Executable and Linkable Format, 可执行与可链接格式</p>]]></description></item><item><title>Heterogeneous Compilation</title><link>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</link><pubDate>Fri, 07 Jun 2024 09:49:52 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</guid><description><![CDATA[<p>与 <a href="https://gaohongy.github.io/blog/posts/compile-link/cuda-compilation/"target="_blank" rel="external nofollow noopener noreferrer">CUDA Compilation</a> 不同在于</p>
<p>The tools used in the CUDA compilation are all closed source except gcc, g++ etc., for example fatbinary and nvlink. We need to substitue these tools to tools in clang system.</p>
<ol>
<li>Clang Offload Bundler is used to combined different code for different machine structurel.</li>
<li>Clang Offload Packager is used to embed device code into host code.</li>
<li>Clang Linker Wrapper is used to .</li>
</ol>
<p>这里面最复杂的感觉是怎么处理链接关系，如果仅仅说代码嵌入，从 CUDA 的流程来看，在 cudafe1.cpp include stub.c 生成 .o 这一步中 host code 中就已经包含了 device code，如果仅仅说 embed 的话，这显然就已经完成了，但是为何 CUDA 还进行后续那么多步骤，因为这一步生成的 .o 显然是无法运行的，device code 都还只是一个 extern signal，还需要同 CUDA runtime library 进行链接，这个过程该怎么进行比较难想。</p>]]></description></item><item><title>Several Methods For Obtaining Time</title><link>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</link><pubDate>Tue, 04 Jun 2024 11:38:22 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</guid><description><![CDATA[<p>We can reference <a href="http://www.wangkaixuan.tech/?p=840"target="_blank" rel="external nofollow noopener noreferrer">this article</a></p>
<p>About the last method that using rdtsc assembly command to obtain time, there are some error prone points, we can reference to <a href="http://www.wangkaixuan.tech/?p=901"target="_blank" rel="external nofollow noopener noreferrer">this article</a>.</p>
<p>If you want to learn about the TST, please reference to <a href="https://oliveryang.net/2015/09/pitfalls-of-TSC-usage/"target="_blank" rel="external nofollow noopener noreferrer">this article</a>.</p>]]></description></item><item><title>SIMD Extension</title><link>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</link><pubDate>Mon, 03 Jun 2024 16:09:29 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</guid><description><![CDATA[<h2 id="说明" class="heading-element"><span>说明</span>
  <a href="#%e8%af%b4%e6%98%8e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SIMD Extension 的各种函数中参数的顺序以及各种函数的实现机制都是遵循着机器在实际存储时采用的小端序，注意在和数组混用时可能会产生一定思维上的混乱。</p>]]></description></item></channel></rss>