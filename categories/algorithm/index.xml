<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Algorithm - Category -</title><link>https://gaohongy.github.io/blog/categories/algorithm/</link><description>Algorithm - Category |</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 26 Dec 2023 20:20:41 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/categories/algorithm/" rel="self" type="application/rss+xml"/><item><title>Branch Bound Algorithm</title><link>https://gaohongy.github.io/blog/posts/algorithm/branch-bound-algorithm/</link><pubDate>Tue, 26 Dec 2023 20:20:41 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/branch-bound-algorithm/</guid><description>分类 队列式分支限界 优先队列式分支限界</description></item><item><title>Dynamic Programming</title><link>https://gaohongy.github.io/blog/posts/algorithm/dynamic-programming/</link><pubDate>Tue, 26 Dec 2023 12:27:18 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/dynamic-programming/</guid><description>定义状态转移方程的关键在于对状态做出完整表示，举个例子，最长上升子序列问题中，不同的状态是一些子序列，以子序列的最后一项作为划分依据就可以完</description></item><item><title>Greedy Algorithm</title><link>https://gaohongy.github.io/blog/posts/algorithm/greedy-algorithm/</link><pubDate>Sun, 24 Dec 2023 18:28:42 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/greedy-algorithm/</guid><description>贪心策略正确性证明 归纳法 归纳法证明的核心逻辑：证明采用贪心策略执行到任意步数时获得的解都是最优解的一部分 数学表达: 算法执行到第k步时$(k \in</description></item><item><title>Divide and Conquer Algorithm</title><link>https://gaohongy.github.io/blog/posts/algorithm/divide-and-conquer-algorithm/</link><pubDate>Fri, 22 Dec 2023 17:41:46 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/divide-and-conquer-algorithm/</guid><description>4 种递归式求解方法 代入法 猜测一个界，然后用数学归纳法证明这个界是正确的。 猜测解的形式 用数学归纳法求出解中的常数，并证明解是正确的 猜测解这个难</description></item><item><title>Programming Complexity</title><link>https://gaohongy.github.io/blog/posts/algorithm/programming-complexity/</link><pubDate>Fri, 22 Dec 2023 15:26:55 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/programming-complexity/</guid><description>渐进符号及相应定理 $O$ $f(n)=O(g(n))$ 称 g(n)是 f(n)的一个渐近上界 当且仅当存在正的常数 c 和 $n_0$，使得对于所有的 $n \ge n_0$， 有 $f(n) \le cg(n)$。</description></item><item><title>Approximation Algorithm</title><link>https://gaohongy.github.io/blog/posts/algorithm/approximation-algorithm/</link><pubDate>Fri, 22 Dec 2023 10:20:37 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/approximation-algorithm/</guid><description>基本概念 近似比 近似算法产生解的代价：C， 最优解产生解的代价：$C^*$ $max(\frac{C}{C^*}, \frac{C^*}{C}) \le \rho(n)$ &amp;lt;=&amp;gt; 近似算法有近似比 $\rho(n)$, 近似算法是一个相对近似算法 特别的，如果算法</description></item><item><title>NP Completeness</title><link>https://gaohongy.github.io/blog/posts/algorithm/np-completeness/</link><pubDate>Sun, 26 Nov 2023 12:58:07 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/np-completeness/</guid><description>NP完全性的核心逻辑 NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单 有多项式时间算法的问题称为易解的，不存在多项式时间算法的问</description></item><item><title>BFS总结</title><link>https://gaohongy.github.io/blog/posts/algorithm/bfs/</link><pubDate>Thu, 08 Apr 2021 22:37:30 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/algorithm/bfs/</guid><description>说明 为了突出各类题目的区别，以下例题均选择较为简单的题目。不会涉及一些非常巧妙的技巧，摆脱一些细枝末节，以便更多地关注到题目类型本身 连通块问</description></item></channel></rss>