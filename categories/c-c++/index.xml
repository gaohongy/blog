<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>C-C++ - Category -</title><link>https://gaohongy.github.io/blog/categories/c-c++/</link><description>C-C++ - Category |</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 15 Apr 2024 11:54:10 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/categories/c-c++/" rel="self" type="application/rss+xml"/><item><title>Polymorphism</title><link>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</link><pubDate>Mon, 15 Apr 2024 11:54:10 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</guid><description><![CDATA[<p>谈及多态主要是在考虑具有继承关系的多个类型之间的关系。考虑多态的核心在于引用或指针的 <strong>静态类型</strong> 与 <strong>动态类型</strong> 是可能不同的</p>
<p>静态多态 和 动态多态 的一个明显的区别是 <strong>是 编译时 还是 运行时 解析调用</strong></p>]]></description></item><item><title>C C++ Const Keyword Unscramble</title><link>https://gaohongy.github.io/blog/posts/c-c++/c-c++-const-keyword-unscramble/</link><pubDate>Tue, 27 Feb 2024 09:09:43 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/c-c++-const-keyword-unscramble/</guid><description><![CDATA[<h2 id="embellish-raw-pointer" class="heading-element"><span>Embellish Raw Pointer</span>
  <a href="#embellish-raw-pointer" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>The collocation between const and original pointer is confused to many people. There are two usages of it. The key difference is that if the pointer is prohibited to modify or the data which is pointed by pointer is prohibited to modify.</p>]]></description></item><item><title>C++ asynchronous and synchronous mechanisms</title><link>https://gaohongy.github.io/blog/posts/c-c++/c++-asynchronous-and-synchronous-mechanisms/</link><pubDate>Sun, 10 Sep 2023 22:06:00 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/c++-asynchronous-and-synchronous-mechanisms/</guid><description><![CDATA[<h2 id="asynchronization-multithreading" class="heading-element"><span>Asynchronization (Multithreading)</span>
  <a href="#asynchronization-multithreading" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>The first thing we need to do is understanding the correlations between multithreading and parallel computing.</p>]]></description></item><item><title>C++ Smart Pointer</title><link>https://gaohongy.github.io/blog/posts/c-c++/c++-smart-pointer/</link><pubDate>Tue, 20 Jun 2023 23:04:00 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/c++-smart-pointer/</guid><description><![CDATA[<h2 id="原始指针" class="heading-element"><span>原始指针</span>
  <a href="#%e5%8e%9f%e5%a7%8b%e6%8c%87%e9%92%88" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题</p>]]></description></item><item><title>C++ Type Conversion</title><link>https://gaohongy.github.io/blog/posts/c-c++/c++-type-conversion/</link><pubDate>Sun, 18 Jun 2023 19:35:22 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/c++-type-conversion/</guid><description><![CDATA[<h2 id="普通类型" class="heading-element"><span>普通类型</span>
  <a href="#%e6%99%ae%e9%80%9a%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h2 id="类类型" class="heading-element"><span>类类型</span>
  <a href="#%e7%b1%bb%e7%b1%bb%e5%9e%8b" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>对于类类型,编译器只能自动执行一步隐式类型转换.例如从字符串字面值转换为string类型,但是无法继续将string隐式转换为其他类型</p>]]></description></item><item><title>Comparison of C++ object initialization method</title><link>https://gaohongy.github.io/blog/posts/c-c++/comparison-of-c++-object-initialization-method/</link><pubDate>Sun, 18 Jun 2023 17:18:40 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/comparison-of-c++-object-initialization-method/</guid><description><![CDATA[<p>在了解创建对象的方式之前，首先了解一下<strong>初始化</strong>和<strong>赋值</strong>两个操作，</p>
<ol>
<li>初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量</li>
<li>赋值是把对象的当前值擦除，用新值代替旧值，即赋值之前存在变量
让人困惑的是<code>=</code>既可以用于初始化，也可以用于赋值，不要认为初始化和赋值是相同的操作</li>
</ol>
<p>关于默认值（默认初始化），值和变量类型和位置决定</p>]]></description></item></channel></rss>