<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Graph-Computing - Category -</title><link>https://gaohongy.github.io/blog/categories/graph-computing/</link><description>Graph-Computing - Category |</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Wed, 11 Sep 2024 14:41:40 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/categories/graph-computing/" rel="self" type="application/rss+xml"/><item><title>Runtime</title><link>https://gaohongy.github.io/blog/posts/graph-computing/runtime/</link><pubDate>Wed, 11 Sep 2024 14:41:40 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/runtime/</guid><description><![CDATA[<p>在主板上增加 PLX 芯片以提供更多的 PCIe 通道</p>
<p>PCIe 设备插到 PCIe 插槽需要由 PLX 芯片提供支持</p>
<p>一个PCIe插槽在物理层面上确实只能插入一个设备。例如，你只能插入一张显卡或一块SSD到一个PCIe插槽中。但是通过PLX芯片等交换设备，可以让多个PCIe设备通过该插槽共享带宽并同时被RC识别和使用(PLX芯片实际上是在分配带宽，这并没有改变某一时刻 RC 只会和某个插槽上的一台设备进行通信的事实，对于资源有限的PCIe插槽环境比较有意义）</p>]]></description></item><item><title>Function Simulator</title><link>https://gaohongy.github.io/blog/posts/graph-computing/function-simulator/</link><pubDate>Fri, 23 Aug 2024 15:33:50 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/function-simulator/</guid><description><![CDATA[<p>The key class of function simulator is <code>TopUnit</code>. We can use <code>TopUnit.CycleStep()</code> to begin the execution of simulator.</p>
<p>In <code>CycleStep()</code>, we will call the <code>Frontend()</code> and <code>Backend()</code>, the former is used to update the many types of counters and the latter is used to execute instructions sequence.</p>
<p>In <code>Backend()</code>, we will call the following functions one by one</p>
<ul>
<li><code>BackendCommit()</code></li>
<li><code>BackendMemory()</code></li>
<li><code>BackendExecute()</code></li>
<li><code>BackendSchedule()</code></li>
</ul>
<p>Among all these functions, the third function <code>BackendExecute()</code> will execute all the instructions.</p>]]></description></item><item><title>Graph Compiler</title><link>https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/</link><pubDate>Thu, 07 Mar 2024 21:26:29 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/</guid><description><![CDATA[<h2 id="对于系统结构的理解" class="heading-element"><span>对于系统结构的理解</span>
  <a href="#%e5%af%b9%e4%ba%8e%e7%b3%bb%e7%bb%9f%e7%bb%93%e6%9e%84%e7%9a%84%e7%90%86%e8%a7%a3" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>主要是对于 应用层代码，编译层 和 运行时库 之间关系的理解</p>]]></description></item><item><title>MLIR</title><link>https://gaohongy.github.io/blog/posts/graph-computing/mlir/</link><pubDate>Thu, 07 Mar 2024 21:26:29 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/mlir/</guid><description><![CDATA[<h2 id="ir" class="heading-element"><span>IR</span>
  <a href="#ir" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>LLVM<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的概念，通过 IR 可以自由实现前后端的组合。</p>]]></description></item><item><title>Legion Source Code Analysis</title><link>https://gaohongy.github.io/blog/posts/graph-computing/legion-source-code-analysis/</link><pubDate>Tue, 05 Mar 2024 20:17:06 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/legion-source-code-analysis/</guid><description><![CDATA[<h2 id="项目文件分类" class="heading-element"><span>项目文件分类</span>
  <a href="#%e9%a1%b9%e7%9b%ae%e6%96%87%e4%bb%b6%e5%88%86%e7%b1%bb" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="storage" class="heading-element"><span>Storage</span>
  <a href="#storage" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><ol start="2">
<li>GPU_Graph_Storage.[cuh]</li>
<li>GPUGraphStore.[cu/cuh]</li>
</ol>
<blockquote>
<p>这两个的区别可能在于下面的是图的逻辑存储结构，上面的是物理存储结构(因为涉及到了CSR)</p>]]></description></item><item><title>Graph Computing</title><link>https://gaohongy.github.io/blog/posts/graph-computing/graph-computing/</link><pubDate>Thu, 29 Feb 2024 15:59:15 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/graph-computing/</guid><description><![CDATA[<h2 id="图计算现有研究和发展现状" class="heading-element"><span>图计算现有研究和发展现状</span>
  <a href="#%e5%9b%be%e8%ae%a1%e7%ae%97%e7%8e%b0%e6%9c%89%e7%a0%94%e7%a9%b6%e5%92%8c%e5%8f%91%e5%b1%95%e7%8e%b0%e7%8a%b6" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>通用图计算软件类型：</p>]]></description></item></channel></rss>