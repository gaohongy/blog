<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>HPC - Category -</title><link>https://gaohongy.github.io/blog/categories/hpc/</link><description>HPC - Category |</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 04 Jun 2024 11:38:22 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/categories/hpc/" rel="self" type="application/rss+xml"/><item><title>Several Methods For Obtaining Time</title><link>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</link><pubDate>Tue, 04 Jun 2024 11:38:22 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</guid><description><![CDATA[<p>We can reference <a href="http://www.wangkaixuan.tech/?p=840"target="_blank" rel="external nofollow noopener noreferrer">this article</a></p>
<p>About the last method that using rdtsc assembly command to obtain time, there are some error prone points, we can reference to <a href="http://www.wangkaixuan.tech/?p=901"target="_blank" rel="external nofollow noopener noreferrer">this article</a>.</p>
<p>If you want to learn about the TST, please reference to <a href="https://oliveryang.net/2015/09/pitfalls-of-TSC-usage/"target="_blank" rel="external nofollow noopener noreferrer">this article</a>.</p>]]></description></item><item><title>SIMD Extension</title><link>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</link><pubDate>Mon, 03 Jun 2024 16:09:29 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</guid><description><![CDATA[<h2 id="说明" class="heading-element"><span>说明</span>
  <a href="#%e8%af%b4%e6%98%8e" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>SIMD Extension 的各种函数中参数的顺序以及各种函数的实现机制都是遵循着机器在实际存储时采用的小端序，注意在和数组混用时可能会产生一定思维上的混乱。</p>]]></description></item><item><title>OpenMP</title><link>https://gaohongy.github.io/blog/posts/hpc/openmp/</link><pubDate>Tue, 30 Apr 2024 20:49:00 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/openmp/</guid><description><![CDATA[<h2 id="check-the-openmp-version" class="heading-element"><span>Check the OpenMP version</span>
  <a href="#check-the-openmp-version" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-cpp" data-lang="cpp"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="cp">#ifdef _OPENMP
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;OpenMP version: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">_OPENMP</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;OpenMP is not supported.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></td></tr></table>
</div>
</div><p>If system supports the OpenMP, you will receive similar output results</p>]]></description></item><item><title>Matrix Multiplication</title><link>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</link><pubDate>Sun, 28 Apr 2024 10:00:06 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</guid><description><![CDATA[<ol>
<li>GEMM（General Matrix Multiplication）-通用矩阵乘</li>
<li>BLAS (Basic Linear Algebra Subprograms) - 基本线性代数子程序</li>
<li>SGEMM (Single precision General Matrix Multiply) - 单精度矩阵乘法</li>
<li>DGEMM (Double precision General Matrix Multiply) - 双精度矩阵乘法</li>
<li>CGEMM (Complex single precision General Matrix Multiply) - 单精度复数矩阵乘法</li>
<li>ZGEMM (Complex double precision General Matrix Multiply) - 双精度复数矩阵乘法</li>
</ol>
<h2 id="matrix--vector" class="heading-element"><span>Matrix &amp; Vector</span>
  <a href="#matrix--vector" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li>
<p>SPMV (Sparse Matrix-Vector multiplication)</p>]]></description></item><item><title>Memory Alignment</title><link>https://gaohongy.github.io/blog/posts/hpc/memory-alignment/</link><pubDate>Sat, 23 Mar 2024 21:08:23 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/memory-alignment/</guid><description><![CDATA[<p>内存的编址单位是字节</p>
<p>但是内存 IO 的单位是字长，此数值应当和 数据通路 的宽度有关，当数据通路为 32 位时，那么一次内存 IO 就会读取4B数据<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<blockquote>
<p>对于上述内容，存在两点需要说明：</p>]]></description></item><item><title>Parallel Computing</title><link>https://gaohongy.github.io/blog/posts/hpc/parallel-computing/</link><pubDate>Mon, 29 Jan 2024 23:41:59 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/parallel-computing/</guid><description><![CDATA[<h2 id="law" class="heading-element"><span>Law</span>
  <a href="#law" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>并行计算领域的两个关键定律就是 Amdahl 和 Gustafson，从不同角度诠释了 <strong>加速比</strong> 与 <strong>系统串行化程度</strong>、<strong>CPU核心数</strong> 之间的关系</p>]]></description></item><item><title>Kokkos Source Code Analysis</title><link>https://gaohongy.github.io/blog/posts/hpc/kokkos-source-code-analysis/</link><pubDate>Fri, 05 Jan 2024 17:39:32 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/kokkos-source-code-analysis/</guid><description><![CDATA[<h2 id="usage" class="heading-element"><span>Usage</span>
  <a href="#usage" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><h3 id="install--cmake" class="heading-element"><span>Install &amp; CMake</span>
  <a href="#install--cmake" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h3><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">cd</span> some_software-1.4.2
</span></span><span class="line"><span class="cl">mkdir build
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> build
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">cmake .. 
</span></span><span class="line"><span class="cl">cmake --build . <span class="c1"># It is equivalent to make</span>
</span></span><span class="line"><span class="cl">cmake --build . --target install <span class="c1"># It is equivalent to make install</span></span></span></code></pre></td></tr></table>
</div>
</div><p>After the above flow, we can use Kokkos by CMake directly.</p>]]></description></item><item><title>MPI</title><link>https://gaohongy.github.io/blog/posts/hpc/mpi/</link><pubDate>Tue, 12 Dec 2023 21:49:28 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/mpi/</guid><description><![CDATA[<p>mpicc, mpic++, mpicxx
mpiexec, mpirun
mpichversion</p>
<p>mpicc 仅可编译 .c 文件，编译 .cpp文件会报错
mpic++ 编译 .cpp 文件</p>
<p>MPI标准的不同实现：MPICH、MVAPICH、MVAPICH2、Open MPI</p>]]></description></item><item><title>C++ asynchronous and synchronous mechanisms</title><link>https://gaohongy.github.io/blog/posts/c-c++/c++-asynchronous-and-synchronous-mechanisms/</link><pubDate>Sun, 10 Sep 2023 22:06:00 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/c-c++/c++-asynchronous-and-synchronous-mechanisms/</guid><description><![CDATA[<h2 id="asynchronization-multithreading" class="heading-element"><span>Asynchronization (Multithreading)</span>
  <a href="#asynchronization-multithreading" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>The first thing we need to do is understanding the correlations between multithreading and parallel computing.</p>]]></description></item><item><title>GPU Structure and Programing</title><link>https://gaohongy.github.io/blog/posts/hpc/gpu-structure-and-programing/</link><pubDate>Wed, 31 May 2023 11:17:35 +0800</pubDate><author>Author</author><guid>https://gaohongy.github.io/blog/posts/hpc/gpu-structure-and-programing/</guid><description><![CDATA[<h2 id="todo" class="heading-element"><span>Todo</span>
  <a href="#todo" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><ul>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> L2 cache gpgpu-sim 源码分析</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> Bank conflict 的题目分析</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> warp occupancy 概念和计算</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 由broadcast式访问global memory引申的对于constant memory的理解和使用</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 并行化+访存优化，并行化中有一个branch divergence的问题</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 查找 DRAM burst突发传送官方文档说明</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 发现矩阵乘法是一个结合各种并行算法以及CUDA硬件架构知识的好的入手点，create一门课程 “从矩阵乘法入门并行计算-CUDA版”</li>
<li><i class="fa-regular fa-square fa-fw" aria-hidden="true"></i> 需要验证如果shared memory中的元素大小和bank大小不一致时，访问其中更小的数据是否会造成bank conflict。需要借助nvprof，但是nvprof在选择检测bank事件时无法正常工作</li>
</ul>
<blockquote>
<ul>
<li>CUDA C只是对标准C进行了语言级的扩展，通过增加一些修饰符使编译器可以确定哪些代码在主机上运行，哪些代码在设备上运行</li>
<li>GPU计算的应用前景很大程度上取决于能否从问题中发掘出大规模并行性</li>
</ul>
</blockquote>
<h2 id="宏观视角" class="heading-element"><span>宏观视角</span>
  <a href="#%e5%ae%8f%e8%a7%82%e8%a7%86%e8%a7%92" class="heading-mark">
    <svg class="octicon octicon-link" viewBox="0 0 16 16" version="1.1" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5 0 1 1 4.95 4.95l-2.5 2.5a3.5 3.5 0 0 1-4.95 0 .751.751 0 0 1 .018-1.042.751.751 0 0 1 1.042-.018 1.998 1.998 0 0 0 2.83 0l2.5-2.5a2.002 2.002 0 0 0-2.83-2.83l-1.25 1.25a.751.751 0 0 1-1.042-.018.751.751 0 0 1-.018-1.042Zm-4.69 9.64a1.998 1.998 0 0 0 2.83 0l1.25-1.25a.751.751 0 0 1 1.042.018.751.751 0 0 1 .018 1.042l-1.25 1.25a3.5 3.5 0 1 1-4.95-4.95l2.5-2.5a3.5 3.5 0 0 1 4.95 0 .751.751 0 0 1-.018 1.042.751.751 0 0 1-1.042.018 1.998 1.998 0 0 0-2.83 0l-2.5 2.5a1.998 1.998 0 0 0 0 2.83Z"></path></svg>
  </a>
</h2><p>高性能计算的第一性原理：访存优化。所有的努力（优化硬件设计，优化算法）都是在试图解决内存墙。</p>]]></description></item></channel></rss>