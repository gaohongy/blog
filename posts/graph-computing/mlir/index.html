<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>MLIR - </title><meta name=author content="ghy"><meta name=author-link content="https://github.com/gaohongy"><meta name=description content="目前涉及到两个关键的概念：MLIR 和 LLVM1。LLVM 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的"><meta name=keywords content='Hugo,FixIt'><meta itemprop=name content="MLIR"><meta itemprop=description content="目前涉及到两个关键的概念：MLIR 和 LLVM1。LLVM 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的"><meta itemprop=datePublished content="2024-03-07T21:26:29+08:00"><meta itemprop=dateModified content="2024-05-23T23:13:18+08:00"><meta itemprop=wordCount content="18770"><meta itemprop=keywords content="Graph-Computing"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/graph-computing/mlir/"><meta property="og:title" content="MLIR"><meta property="og:description" content="目前涉及到两个关键的概念：MLIR 和 LLVM1。LLVM 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-07T21:26:29+08:00"><meta property="article:modified_time" content="2024-05-23T23:13:18+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="MLIR"><meta name=twitter:description content="目前涉及到两个关键的概念：MLIR 和 LLVM1。LLVM 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/graph-computing/mlir/><link rel=prev href=https://gaohongy.github.io/blog/posts/graph-computing/legion-source-code-analysis/><link rel=next href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/><link rel=stylesheet href=/blog/css/style.min.css><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blog/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"MLIR","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/graph-computing\/mlir\/"},"genre":"posts","wordcount":18770,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/graph-computing\/mlir\/","datePublished":"2024-03-07T21:26:29+08:00","dateModified":"2024-05-23T23:13:18+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ghy"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item><a href=/blog/ title>主页</a></li><li class=breadcrumb-item><a href=/blog/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>MLIR</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>MLIR</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/gaohongy title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202205161528792.jpg data-title=ghy data-alt=ghy class=avatar style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;ghy</a></span>
<span class=post-category>收录于 <a href=/blog/categories/graph-computing/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Graph-Computing</a></span></div><div class=post-meta-line><span title="发布于 2024-03-07 21:26:29"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2024-03-07>2024-03-07</time></span>&nbsp;<span title="更新于 2024-05-23 23:13:18"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-23>2024-05-23</time></span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#对于-mlir-的理解>对于 MLIR 的理解</a><ul><li><a href=#降级转换机制>降级转换机制</a></li><li><a href=#mlir-语法>MLIR 语法</a></li><li><a href=#dialect-理解>Dialect 理解</a></li><li><a href=#mlir-interface>MLIR Interface</a><ul><li><a href=#memref>MemRef</a></li><li><a href=#使用-mlir-实现矩阵乘法>使用 MLIR 实现矩阵乘法</a></li></ul></li></ul></li><li><a href=#mlir-编译>MLIR 编译</a></li><li><a href=#mlir-tutorials>MLIR Tutorials</a><ul><li><a href=#chapter-1>Chapter 1</a></li><li><a href=#chapter-2>Chapter 2</a><ul><li><a href=#关于-opstd-是如何同-dialect模块dialecthdialectcpp相结合的>关于 Ops.td 是如何同 Dialect模块（Dialect.h，Dialect.cpp）相结合的？**</a></li><li><a href=#关于创建一个-op-所需要用到的类>关于创建一个 Op 所需要用到的类</a></li><li><a href=#随想疑问>随想疑问</a></li><li><a href=#chapter-2-展现出的问题>Chapter 2 展现出的问题</a></li></ul></li><li><a href=#chapter-3>Chapter 3</a><ul><li><a href=#c-实现-canonicalization>C++ 实现 canonicalization</a></li><li><a href=#使用-drr模块-实现-transformation>使用 DRR模块 实现 transformation</a></li><li><a href=#对-chapter-3-的理解和感悟>对 Chapter 3 的理解和感悟</a></li><li><a href=#compiler-pattern-match-transformations-分类>compiler pattern-match transformations 分类</a></li><li><a href=#关于-pattern-rewrite机制-的疑问>关于 Pattern Rewrite机制 的疑问</a></li></ul></li><li><a href=#chapter-4>Chapter 4</a></li></ul></li><li><a href=#mlir-python-bindings>MLIR Python Bindings</a><ul><li><a href=#生成-mlir-表达式-所需的模块mlir-mode>生成 MLIR 表达式 所需的模块：</a></li></ul></li><li><a href=#mlir-hello-world>mlir &ldquo;hello world&rdquo;</a><ul><li><a href=#定义-dialect>定义 Dialect</a></li><li><a href=#定义-operation>定义 operation</a></li><li><a href=#创建-pass>创建 pass</a><ul><li><a href=#方法-1---全人工实现>方法 1 - 全人工实现</a></li><li><a href=#方法-2---使用-tablegen>方法 2 - 使用 tablegen</a></li><li><a href=#方法-3---借助-canonicalization-framework>方法 3 - 借助 Canonicalization Framework</a></li><li><a href=#易错点及总结>易错点及总结</a></li></ul></li><li><a href=#创建-opt>创建 opt</a></li><li><a href=#cmakeliststxt解读>CMakeLists.txt解读</a></li><li><a href=#疑惑>疑惑</a></li></ul></li><li><a href=#buddy-mlir>buddy-mlir</a><ul><li><a href=#introduction>introduction</a></li><li><a href=#build>Build</a></li><li><a href=#structure>Structure</a></li><li><a href=#source-code-structure>source code structure</a></li><li><a href=#understanding>understanding</a></li><li><a href=#examples-introductoin-examples-introduction>Examples Introductoin</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></div><div class=content id=content data-end-flag=EOF><p>目前涉及到两个关键的概念：MLIR 和 LLVM<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>。LLVM 通过引入 IR 的概念，减轻了传统编译器前后端之间的强耦合关系。与此同时也凸显出了模块化的概念，通过 IR 可以自由实现前后端的组合。而MLIR和IR是同一类别的事物，差别在于其更加通用可扩展，可以用于描述和表示程序的结构和语义信息。</p><p>如果想要利用MLIR实现图计算的相关编译工作，可行的思路就是将MLIR转换为LLVM IR（LLVM的中间表示形式），然后利用LLVM提供的优化器和代码生成器将LLVM IR编译成目标平台的机器代码，简单来说就是利用LLVM的后端，这样，MLIR可以利用LLVM的强大优化和代码生成能力，为不同的编程模型和应用场景提供高效的编译器支持。</p><p>Just a guess:</p><p>gc: Graph Convolution（图卷积）
gnn: Graph Neural Networks（图神经网络）
gpm:</p><p>在了解 MLIR 过程中发现使用到了一个名为 TableGen 的工具，有一种说法是它是 一种声明式编程语言。似乎通过相关工具，可以将.td文件生成C++代码。粗浅理解似乎是为了能够运用某些公共组件</p><h2 id=对于-mlir-的理解>对于 MLIR 的理解</h2><ol><li><p>背景：在当前编译结构中，各种IR之间转换的效率和可迁移性不高
<a class=lightgallery href="https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp?size=large" data-thumbnail="https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp?size=small" data-sub-html="<h2>https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp</h2>"><img loading=lazy src=https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp srcset="https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp?size=small, https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp?size=medium 1.5x, https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp?size=large 2x" sizes=auto data-title=https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp data-alt=https://pic2.zhimg.com/80/v2-b6e62260b0faf1085f972d1eda6e4bb1_1440w.webp style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p></li><li><p>引入 MLIR 所期望做到的：使用一种一致性强的方式，为各种DSL提供一种中间表达形式，将他们集成为一套生态系统，编译到特定硬件平台的汇编语言上
<a class=lightgallery href="https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp?size=large" data-thumbnail="https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp?size=small" data-sub-html="<h2>https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp</h2>"><img loading=lazy src=https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp srcset="https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp?size=small, https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp?size=medium 1.5x, https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp?size=large 2x" sizes=auto data-title=https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp data-alt=https://pic2.zhimg.com/80/v2-4b2fa235edc4387378a84b8a3587efd9_1440w.webp style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p></li></ol><p>MLIR 表达式组成:
<a class=lightgallery href="https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp?size=large" data-thumbnail="https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp?size=small" data-sub-html="<h2>https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp</h2>"><img loading=lazy src=https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp srcset="https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp?size=small, https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp?size=medium 1.5x, https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp?size=large 2x" sizes=auto data-title=https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp data-alt=https://pic4.zhimg.com/80/v2-6d75286d07a53555437f2c436f718083_1440w.webp style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>MLIR 并不是一个端到端（从计算图到最后可执行程序这个全流程）的框架，只是一个基础架构</p><p>多层次表达 是 MLIR 的优点，这有利于各种优化机制的实现（这并不难理解，中间过程越多，那么优化的入手点就越多），但是另一方面中间过程越多，出错的机会也同样越多，具体是指 compiler’s pass pipeline and toolchain are difficult to configure</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403110950934.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>中间表达的意义在于逐层解析，逐层降低抽象而偏向硬件。高级语言的 AST 到 IR 之间存在较大差距，通过在中间架设 IR 可以对高级抽象进行渐进式变换和递降，降低这种差距变化的梯度，降低阶段转换的难度，同时只要提供 IR 就相当于我们可以为任何领域的代码实现设计特定的编译器。</p><p>但是带来的一个问题就是，每当增加一种实现时都会出现一种全新的 IR，而实际上可能这些 IR 之间存在一些共性的东西，通过增设 MLIR 这一层类似标准化的层次，可以使得中间的转化流程变得更加规范</p><p>根据High Performance GPU Code Generation for Matrix-Matrix Multiplication using MLIR: Some Early Results<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>的说法，原有的IR基础设施并不能有效地解决自动生成特定领域库的问题。特别是，很难使用单个IR来表示和转换高，中，低级别的抽象。</p><p>MLIR 用于解决编程语言、编译器和硬件之间的交互问题，它的出现是为了应对日益复杂的编程语言和硬件架构</p><p>MLIR提供了一个统一的中间表示（IR），可以作为不同编程语言编译器和LLVM后端之间的桥梁。</p><p>通过自定义 dialect，可以实现语言扩充 和 实现特定领域的编译优化</p><p><a href=https://www.zhihu.com/question/442964082 target=_blank rel="external nofollow noopener noreferrer">如何评价MLIR项目中Linalg Dialect的设计思想？</a> 各种回答中，有两点思想对于理解 MLIR 有一定帮助：</p><ol><li>MLIR 或许可以看为一个 IR Template</li><li>MLIR 的核心工作在于各种 Dialect 之间的转换。对于目前的项目，假设存在一种机制可以从 C++ 源代码转化到某种 Dialect，之后在不同 Dialect 中来回转换。不过不是很理解的是编译层到底在整体架构中处于什么地位，如果说是以第三方库的形式为框架层提供服务，那么这种服务的接口又是什么，难道就像 MLIR 中原生的这些类型一样？我们需要做的就是编写td文件创建各种 Dialect、operation等？编译层的生成物应当是 host 端和 device 端的类汇编语言，通过具体硬件平台的工具链完成执行流程</li></ol><h3 id=降级转换机制>降级转换机制</h3><ol><li><p>Lowering（降级）的主要目标是将一个高级抽象表示转换为一个更低级别、更具体的表示。通常不会改变 IR 的属性，而只是将其转换为具有更具体语义的形式。例如，将高级的 vector dialect 转换为底层的 LLVM dialect，这只是对 IR 进行了降级，但它仍然是 MLIR IR，并且具有相同的属性和结构。</p></li><li><p>Translation（翻译）是将一个表示转换为另一个表示的过程，可能会改变 IR 的属性，并将其转换为不同的语言或表示形式。例如，将 MLIR IR 翻译为 LLVM IR。</p></li></ol><p>无论是降级还是翻译，本质上都可以算作一种<strong>转换</strong>，都需要依托 Pass 机制来实现，只是说两个阶段在转换时用到的 Pass 并不相同</p><p>如果仅仅是用 MLIR 原生的 Dialect，那么 lowering 过程是可以直接通过 <code>mlir-opt</code> 来实现的，translation 过程可以直接通过 <code>mlir-translate</code> 来实现</p><p>但是如果说需要用到 custom dialect，这个 lowering 和 translation 过程就需要通过代码实现了，通过 MLIR 提供的接口来进行接入</p><hr><p>2024/04/22 对上述内容进行修正：</p><p>按照最新的理解，实际上 lowering 可能并不一定仅仅表示 Dialect 之间的转化。</p><p>lowering 更核心的含义是 表示从一种抽象级别到另一种更底层的抽象级别的转换，而从高层抽象 Dialect 转换为 低层抽象 Dialect，以及从一种形式的 IR 转换到另一种更底层的 IR，这两种情况显然都是符合这种从高层到低层抽象级别的转换概念的。</p><p>所以说不必过于纠结所谓的 lowering, transformation, conversation 这些概念之间到底有什么详细的区别</p><p>因为从本质上来说，MLIR 中最核心的工作就是转换，无论是 Dialect 转换还是 IR 转换，而这些转换工具都可以抽象说为是 pass，它们在不同的层次和不同的粒度上执行转换，不同的 pass 有不同的作用范围、优化目标和实现方式，但是它们都是用于转换和优化MLIR程序的工具，简单对 pass 进行分类，如下所示（可能不全）</p><ol><li>Dialect Conversion Passes：用于在不同的Dialect之间进行转换，例如将MLIR程序转换为LLVM Dialect。</li><li>Lowering Passes：用于将高级抽象表示降低为更底层的表示，例如将高级Tensor表示降低为LLVM IR。</li><li>Backend Passes：用于生成目标代码或与特定硬件/平台相关的表示。</li><li>Transformation Passes：用于对程序进行结构上的转换，例如循环平铺、循环分块等。</li><li>Optimization Passes：用于优化MLIR程序，例如常见的优化技术包括死代码消除、常量折叠、循环优化等。</li><li>Analysis Passes：用于对程序进行静态分析，例如数据流分析、依赖分析等。</li><li>Verification Passes：用于验证程序的正确性，例如检查程序是否符合特定的规范。</li><li>Instrumentation Passes：用于在程序中插入额外的代码以收集性能数据或调试信息</li></ol><h3 id=mlir-语法>MLIR 语法</h3><p>MLIR 的源代码文档可见 <a href=https://mlir.llvm.org/doxygen/namespacemlir.html target=_blank rel="external nofollow noopener noreferrer">mlir Namespace Reference</a>，此文档是 mlir 的最外层的命名空间，因此可从此找到所有和 mlir 相关的代码</p><p>MLIR 采用类型后置表达，而且在需要用到的位置都需要注明常量或者变量的类型，例如:</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%result</span> <span class=p>=</span> call <span class=nf>@myfunc</span><span class=p>()</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>index</span>
</span></span><span class=line><span class=cl>    <span class=kt>vector</span><span class=p>.</span>print <span class=nv>%result</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@myfunc</span><span class=p>()</span> <span class=p>-&gt;</span> <span class=k>index</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%c0</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>1</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span> <span class=nv>%c0</span> <span class=p>:</span> <span class=k>index</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>注意看上述代码中的<code>@myfunc() : () -> index</code>（当然这里还用到了类似lambda中的后置返回值类型的表达方法），以及<code>%result : index</code>（虽然说目前还没有找到<code>index</code>代表常量的什么证据，但是可以姑且就这么认为）,以及<code>1:index</code>，它们都是将类型放置在了常量或者变量的后面，即类型后置表达</p><p>需要明确的是在上述的各种语法中，点运算符后的实际是一个 operation，从偏向编程语言的角度来说，它们实际上就是一个个的 function，只是表现形式上有些类似变量声明的语法</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=c>// Integer constant
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c>// Equivalent generic form
</span></span></span><span class=line><span class=cl><span class=c></span><span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;arith.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span></span></span></code></pre></td></tr></table></div></div><p>在官方文档的 arith Dialect 中有这么一段代码，它们两个是等价的，考虑下面那一种形式</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>arith<span class=p>.</span><span class=kt>constant</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nl>value =</span> <span class=m>42</span> <span class=p>:</span> <span class=k>i32</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=k>i32</span></span></span></code></pre></td></tr></table></div></div><p>考虑 MLIR 采用的后置类型表达，这实际就等价于编程语言中的</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>i32</span> <span class=n>arith</span><span class=o>::</span><span class=n>constant</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>i32</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>42</span><span class=p>;</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>不同点就在于类型以及作用域的表达方式发生了改变</p><p>MLIR 内置的数据类型：<a href=https://mlir.llvm.org/docs/Dialects/Builtin/#indextype target=_blank rel="external nofollow noopener noreferrer">Builtin Dialect</a></p><p>对于 <code>mlir-opt</code> 命令携带的选项中那些 <code>convert</code>，目前的理解是代码中使用到了哪些 Dialect，如果想要利用 <code>mlir-cpu-runner</code> 执行，那就需要添加一个从这个 Dialect low 到 LLVM Dialect 的选项，例如：</p><p>如果代码中使用到了 vector Dialect 和 math Dialect，那么就需要添加两个选项：</p><ul><li><code>-convert-vector-to-llvm</code></li><li><code>-convert-math-to-llvm</code></li></ul><p>从 MLIR 提供的原生 Dialect convert (官方说法是 standard dialect) 到 LLVM Dialect 的相关介绍可以参考 &ldquo;<a href=https://fuchsia.googlesource.com/third_party/llvm-project/+/refs/tags/llvmorg-11.0.0-rc5/mlir/docs/ConversionToLLVMDialect.md target=_blank rel="external nofollow noopener noreferrer">Conversion to the LLVM Dialect</a>&rdquo;</p><h3 id=dialect-理解>Dialect 理解</h3><p><a class=lightgallery href="https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png?size=large" data-thumbnail="https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png?size=small" data-sub-html="<h2>https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png</h2>"><img loading=lazy src=https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png srcset="https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png?size=small, https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png?size=medium 1.5x, https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png?size=large 2x" sizes=auto data-title=https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png data-alt=https://img2024.cnblogs.com/blog/1898659/202404/1898659-20240414150832414-966035897.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p><a href=https://discourse.llvm.org/t/codegen-dialect-overview/2723 target=_blank rel="external nofollow noopener noreferrer">Codegen Dialect Overview</a></p><h3 id=mlir-interface>MLIR Interface</h3><p><strong>背景问题</strong></p><p>简单来说MLIR多层级的设计为其带来了便利，但是也同样带来了问题。</p><p>在不同的Dialect层次进行Operation转换或者做变换（Pass）的时候我们需要明确每个Dialect下的每个Operation的具体语意，否则就可能会转换或变换失败</p><p>Interface并不是Operation的核心，而是一些通用变换的核心</p><p><a href=https://aijishu.com/a/1060000000291910#item-8 target=_blank rel="external nofollow noopener noreferrer">MLIR中的Interfaces</a></p><p><a href=https://aijishu.com/a/1060000000452940 target=_blank rel="external nofollow noopener noreferrer">MLIR概述</a></p><h4 id=memref>MemRef</h4><p>In-memory representation of a tensor</p><p>The only way to access the element of a memref is through <code>load</code> and <code>store</code> operation.</p><h4 id=使用-mlir-实现矩阵乘法>使用 MLIR 实现矩阵乘法</h4><p>所需的基本元素：</p><ol><li>多维数组定义及取数操作</li></ol><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl><span class=nv>%v</span> <span class=p>=</span> arith<span class=p>.</span><span class=kt>constant</span> dense<span class=p>&lt;[[</span><span class=m>1</span><span class=p>,</span> <span class=m>2</span><span class=p>],</span> <span class=p>[</span><span class=m>2</span><span class=p>,</span> <span class=m>3</span><span class=p>]]&gt;</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x2x</span><span class=k>i32</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=kt>vector</span><span class=p>.</span>print <span class=nv>%v</span> <span class=p>:</span> <span class=kt>vector</span><span class=p>&lt;</span><span class=m>2x2x</span><span class=k>i32</span><span class=p>&gt;</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li><p>循环语句</p></li><li><p>加减乘除数值运算</p></li></ol><h2 id=mlir-编译>MLIR 编译</h2><ol><li>如果需要用到<a href=https://mlir.llvm.org/docs/Bindings/Python/#building target=_blank rel="external nofollow noopener noreferrer">Python Bindings</a>，在<a href=https://mlir.llvm.org/getting_started/ target=_blank rel="external nofollow noopener noreferrer">MLIR Getting Started</a>给出的编译命令之外是需要添加额外的编译选项的，完整示例如下所示：</li></ol><p>同时需要注意文档中提到的对于部分python包的依赖，这部分需要在编译之前进行安装</p><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>cmake -G Ninja ../llvm <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -DLLVM_ENABLE_PROJECTS<span class=o>=</span>mlir <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -DLLVM_BUILD_EXAMPLES<span class=o>=</span>ON <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>    -DLLVM_TARGETS_TO_BUILD<span class=o>=</span><span class=s2>&#34;Native&#34;</span> <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DCMAKE_BUILD_TYPE<span class=o>=</span>Debug <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DLLVM_USE_SPLIT_DWARF<span class=o>=</span>ON <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DLLVM_ENABLE_ASSERTIONS<span class=o>=</span>ON <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DCMAKE_C_COMPILER<span class=o>=</span>clang <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DCMAKE_CXX_COMPILER<span class=o>=</span>clang++ <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DLLVM_ENABLE_LLD<span class=o>=</span>ON <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DMLIR_ENABLE_BINDINGS_PYTHON<span class=o>=</span>ON <span class=se>\
</span></span></span><span class=line><span class=cl><span class=se></span>	-DPython3_EXECUTABLE<span class=o>=</span><span class=s2>&#34;/opt/homebrew/bin/python3&#34;</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li><p>compiler这个项目所包含的CMakeLists.txt中写死了一些路径，这些都需要进行修改</p></li><li><p>compiler项目在CMakeLists.txt中使用到了一些<code>find_package()</code>，涉及到numpy和pybind11，需要通过<code>CMAKE_PREFIX_PATH</code>手动指定路径</p></li></ol><h2 id=mlir-tutorials>MLIR Tutorials</h2><p>在 llvm 的项目源码中，同MLIR Tutorials相关的需要关注的是两个路径下的文件:</p><ul><li><code>/Users/gaohongyu/llvm/mlir/test/Examples/Toy</code>：存放的是 toy 语言的源程序</li><li><code>/Users/gaohongyu/llvm/mlir/examples/toy</code>：存放的是实现 toy 语言获取 AST，MLIR 表达式等工具的源代码 (产生的工具可执行文件在<code>build/bin</code>目录中)</li></ul><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191134543.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=chapter-1>Chapter 1</h3><blockquote><p>Toy Language and AST</p></blockquote><p>这一部分主要内容就是创造了一种新的语言，叫做Toy，然后实现了一个简易的语法分析器，仅仅能够获得toy源程序对应的抽象语法树。所以说这一节的重点就是抽象语法树</p><p>需要使用到的命令：<code>~/llvm/build/bin/toyc-ch1 /Users/gaohongyu/llvm/mlir/test/Examples/Toy/Ch1/ast.toy --emit=ast</code></p><p>意思是通过<code>toyc-ch1</code>程序生成<code>ast.toy</code>程序的抽象语法树</p><p>实际上，这里采用 Toy 语言进行分析可能会给初学者带来一点困惑，因为这很容易让初学者陷入这个语言本身，而忽略了 MLIR 到底想做一件什么事情。</p><p>实际上，MLIR 采用一种自创的 Toy 语言，这是为了完整的展示从最开始的源程序，首先转换为 AST，然后进一步翻译为 MLIR 表达式，然后通过 lowering，逐步转换到可执行程序的全流程。而采用 Toy 并不是说 MLIR 只是应用于编译一门新的语言（当然它有这个功能），将 Toy 改为 python 或者 C++ 等其他语言也是一样的，关键并不在于 MLIR 所面对的是什么语言所形成的应用，而是 MLIR 面对的是一个应用这件事情本身，它要做的就是把这个应用通过 MLIR 的各个阶段，逐步翻译到我们所期望得到的东西，而 Chapter 1 所展现的从 源代码 转换为 AST 只是这个过程中的一环，并且这一环和 MLIR 并没有什么关系，因为 源代码 -> AST 往往是语言本身所支持的。MLIR 关注的是从 AST 到 MLIR表达式的转换，以及 MLIR 表达式后续的变化。</p><p>上面提到，从 源程序 到 AST 的转换过程实际并不需要 MLIR 的介入，对于常见的编程语言，例如 python，官方是有提供 ast 包来实现这一点的。只不过由于 toy 是一个自创的语言，所以 Chapter 1 的代码主要做的就是解析抽象语法树。</p><h3 id=chapter-2>Chapter 2</h3><blockquote><p>Emitting Basic MLIR</p></blockquote><p>在第一节中已经生成了 Toy 语言源程序的 AST，这一节就是要根据 AST 结合 Dialect 来生成 MLIR表达式</p><p><a class=lightgallery href="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;size=large" data-thumbnail="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;size=small" data-sub-html="<h2>https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1</h2>"><img loading=lazy src="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" srcset="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;size=small, https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;size=medium 1.5x, https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1&amp;size=large 2x" sizes=auto data-title="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" data-alt="https://mmbiz.qpic.cn/mmbiz_png/SdQCib1UzF3tN9fRfXZhWRgL2OLr400ESibMbgibPJfUrSLDicq855g64h5cz6CHn4lstoRPJ2KjGbG2q43ANqSPmg/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" class="suffix-invalid suffix-invalid__small suffix-invalid__large" style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>Ch2/toyc.cpp 相较于 Ch1/toy.cpp相比，有一个区别就是程序接收的参数多了一个：</p><p>这是Ch1/toy.cpp中和程序参数相关的内容：</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=n>cl</span><span class=o>::</span><span class=n>opt</span><span class=o>&lt;</span><span class=k>enum</span> <span class=nc>Action</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>emitAction</span><span class=p>(</span><span class=s>&#34;emit&#34;</span><span class=p>,</span> <span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;Select the kind of output desired&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>               <span class=n>cl</span><span class=o>::</span><span class=n>values</span><span class=p>(</span><span class=n>clEnumValN</span><span class=p>(</span><span class=n>DumpAST</span><span class=p>,</span> <span class=s>&#34;ast&#34;</span><span class=p>,</span> <span class=s>&#34;output the AST dump&#34;</span><span class=p>)));</span></span></span></code></pre></td></tr></table></div></div><p>这是Ch2/toy.cpp中和程序参数相关的内容：</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=n>cl</span><span class=o>::</span><span class=n>opt</span><span class=o>&lt;</span><span class=k>enum</span> <span class=nc>Action</span><span class=o>&gt;</span> <span class=n>emitAction</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=s>&#34;emit&#34;</span><span class=p>,</span> <span class=n>cl</span><span class=o>::</span><span class=n>desc</span><span class=p>(</span><span class=s>&#34;Select the kind of output desired&#34;</span><span class=p>),</span>
</span></span><span class=line><span class=cl>    <span class=n>cl</span><span class=o>::</span><span class=n>values</span><span class=p>(</span><span class=n>clEnumValN</span><span class=p>(</span><span class=n>DumpAST</span><span class=p>,</span> <span class=s>&#34;ast&#34;</span><span class=p>,</span> <span class=s>&#34;output the AST dump&#34;</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>    <span class=n>cl</span><span class=o>::</span><span class=n>values</span><span class=p>(</span><span class=n>clEnumValN</span><span class=p>(</span><span class=n>DumpMLIR</span><span class=p>,</span> <span class=s>&#34;mlir&#34;</span><span class=p>,</span> <span class=s>&#34;output the MLIR dump&#34;</span><span class=p>)));</span></span></span></code></pre></td></tr></table></div></div><p>区别就在于编译生成的toyc-ch2不仅能够生成toy源程序的抽象语法树，还能够生成对应的mlir表达式</p><h4 id=关于-opstd-是如何同-dialect模块dialecthdialectcpp相结合的>关于 Ops.td 是如何同 Dialect模块（Dialect.h，Dialect.cpp）相结合的？**</h4><p>通过Ops.td可以生成以下这些.inc文件:</p><ol><li>Dialect.h.inc: Dialect Declarations</li><li>Dialect.cpp.inc: Dialect Definitions</li><li>Ops.h.inc: Op Declarations</li><li>Ops.cpp.inc: Op Definitions</li></ol><p>而 Dialect 模块则使用到了这些文件：</p><ol><li>Dialect.h 负责引入 .h.inc，即 Declarations, 包括 Dialect.h.inc 和 Ops.h.inc</li><li>Dialect.cpp 负责引入 .cpp.inc，即 Definitions，包括 Dialect.cpp.inc 和 Ops.cpp.inc</li></ol><p>所以说，关于 dialect 本身 和 其 操作 等内容，都是在.td文件中说明，然后通过 tablegen 工具结合选项生成所需要的内容</p><p>Dialect.h 负责引入头文件这件事情并不难理解，那么如何理解 Dialect.cpp 和 Ops.cpp.inc 都具备的对于 Op Definition 功能这件事情？</p><p>以 <code>TransposeOp::build</code> 为例:</p><p>Ops.cpp.inc 中的相关内容为：</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>build</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Type</span> <span class=n>resultType0</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Value</span> <span class=n>input</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addOperands</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addTypes</span><span class=p>(</span><span class=n>resultType0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>build</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>odsBuilder</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>TypeRange</span> <span class=n>resultTypes</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Value</span> <span class=n>input</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addOperands</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>resultTypes</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1u</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;mismatched number of results&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addTypes</span><span class=p>(</span><span class=n>resultTypes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>build</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>odsState</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>TypeRange</span> <span class=n>resultTypes</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>ValueRange</span> <span class=n>operands</span><span class=p>,</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>ArrayRef</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>NamedAttribute</span><span class=o>&gt;</span> <span class=n>attributes</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>operands</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1u</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;mismatched number of parameters&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addOperands</span><span class=p>(</span><span class=n>operands</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addAttributes</span><span class=p>(</span><span class=n>attributes</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>assert</span><span class=p>(</span><span class=n>resultTypes</span><span class=p>.</span><span class=n>size</span><span class=p>()</span> <span class=o>==</span> <span class=mi>1u</span> <span class=o>&amp;&amp;</span> <span class=s>&#34;mismatched number of return types&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>odsState</span><span class=p>.</span><span class=n>addTypes</span><span class=p>(</span><span class=n>resultTypes</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>Dialect.cpp 中的相关内容为：</p><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>build</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>OpBuilder</span> <span class=o>&amp;</span><span class=n>builder</span><span class=p>,</span> <span class=n>mlir</span><span class=o>::</span><span class=n>OperationState</span> <span class=o>&amp;</span><span class=n>state</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>mlir</span><span class=o>::</span><span class=n>Value</span> <span class=n>value</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>addTypes</span><span class=p>(</span><span class=n>UnrankedTensorType</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>builder</span><span class=p>.</span><span class=n>getF64Type</span><span class=p>()));</span>
</span></span><span class=line><span class=cl>  <span class=n>state</span><span class=p>.</span><span class=n>addOperands</span><span class=p>(</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>目前还未搞懂这两者之间有何关联，不过 Ops.cpp.inc 还有额外的工作，就是在 Dialect.cpp 最开始的 dialect 初始化时为 dialect 指定操作：</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>ToyDialect</span><span class=o>::</span><span class=n>initialize</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>addOperations</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl><span class=cp>#define GET_OP_LIST
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;toy/Ops.cpp.inc&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>      <span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=关于创建一个-op-所需要用到的类>关于创建一个 Op 所需要用到的类</h4><p>以 Transpose Op 为例，根据 Ops.cpp.inc 的内容，和 transpose op 相关的有以下内容:</p><ol><li>TransposeOpGenericAdaptorBase</li><li>TransposeOpGenericAdaptor</li><li>TransposeOpAdaptor</li><li>TransposeOp</li></ol><h4 id=随想疑问>随想疑问</h4><p>一直在思考，toy tutorial 给出的这个示例到底对于实际的应用场景有何启发作用？</p><p>实际上toy是一门新创造出的语言，是为了展示MLIR的各项特点而出现的，获取抽象语法树，获取MLIR表达式的工具都是项目自行实现的。</p><p>如果考虑真实的场景，例如用C++实现的代码，哪怕是框架，通过cmake都可以完成编译，引入MLIR难道就是为了替换掉整个编译流程中的前端和中端，用人工实现MLIR的方式逐层降级？首先编译层的上层是框架层，在我的理解中，我们可以把这个框架和Tensorflow或者Pytorch等价来看，但是在我看来，无论是不是新的框架，只要不是新的语言，理论上都可以用现有的编译工具完成编译，非要做这个编译层，非要用MLIR逐层降级只是为了提高性能，优化性能，使得每一层的优化都能够做到极致，而不是仅仅依靠现有编译器采用的那些优化。</p><p>那么有一个问题是：我们要站在哪个起点来分析这件事。toy是一门新的语言，所以说最基础的解析器都需要全新实现，也就是说面对toy这个场景就应当是一无所有的。但是现有项目是用C++实现的，MLIRGen这个工具对于现在的场景是存在的，肯定需要做的是写Dialect，那结合Dialect生成MLIR表达式这个过程是谁负责的？</p><p>突然感觉我们的重点就是写Dialect，结合编程框架中的一些数据结构，在Dialect中把需要完成的内容完成，考虑一层一层是怎么降级的。我觉得像：</p><p>1.是怎么从源程序解析得到的AST？(这个问题不考虑，暂时不重要）
2.MLIRGen是怎么结合Dialect生成的一层表达（每一次Dialect的加入都会形成一层中间层），主要是类和类之间是怎么关联起来的
3. .td文件通过tablegen能生成很多东西，这些东西都怎么用？
4. .td结合tablegen生成的一大堆东西 和 Dialect.cpp又是什么关系，或者说Dialect.cpp到底负责干什么的？</p><ol><li>我现在比较纠结的就是各个部分的联动关系，我不知道要写的内容到底要怎么发挥出它的作用</li><li>不太理解如果想要完成一层降级都需要做些什么，只知道要写dialect，但是这dialect是怎么对降级起到作用的？通过生成MLIR表达式或许是，所以说就是让dialect为生成MLIR表达式做出贡献</li></ol><p>如果对toy ch2这个内容来说，是否可以假设现在有MLIRGen的工具，但是还没有相关的dialect，任务就是编写dialect实现MLIR表达式的生成。（因为后续教程的内容是例如表达式优化和降级的内容，如果让dialect在生成MLIR表达式这个过程中发挥作用我觉得是整个任务的基础）</p><p>如何理解 Dialect？</p><p>Dialects provide a grouping mechanism for abstraction under a unique namespace</p><p>MLIR is designed to allow all IR elements, such as attributes, operations, and types,</p><p>自定义 Dialect 同 MLIR 结合的方式：</p><p>C++实现Dialect：</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ToyDialect</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>::</span><span class=n>Dialect</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=k>explicit</span> <span class=n>ToyDialect</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>ctx</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>getDialectNamespace</span><span class=p>()</span> <span class=p>{</span> <span class=k>return</span> <span class=s>&#34;toy&#34;</span><span class=p>;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>initialize</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>借助tablegen工具实现Dialect：</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def Toy_Dialect : Dialect {
</span></span><span class=line><span class=cl>  let name = &#34;toy&#34;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  let summary = &#34;A high-level dialect for analyzing and optimizing the &#34;
</span></span><span class=line><span class=cl>                &#34;Toy language&#34;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  let description = [{
</span></span><span class=line><span class=cl>  }];
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  let cppNamespace = &#34;toy&#34;;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>因为这一节的内容的主要目的就是探索从 抽象语法树AST 转为 MLIR表达式 的过程，所以说 Ch2 相较于 Ch1 增加的从模块上来将，就将增加 生成MLIR表达式所需的3个模块</p><p>具体模块对应的文件是：</p><ul><li>MLIRGen模块：<code>mlil/MLIRGen.cpp</code> 和 <code>include/toy/MLIRGen.h</code></li><li>Dialect模块：<code>mlir/Dialect.cpp</code> 和 <code>include/toy/Dialect.h</code></li><li>TableGen模块：<code>include/toy/Ops.td</code></li></ul><ol><li>从抽象语法树 生成 MLIR表达式</li></ol><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1># AST 中 toy源程序中 transpose(a) 语句对应的内容</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>Call</span> <span class=s1>&#39;transpose&#39;</span> <span class=p>[</span> <span class=err>@</span><span class=n>codegen</span><span class=o>.</span><span class=n>toy</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>10</span>
</span></span><span class=line><span class=cl>  <span class=k>var</span><span class=p>:</span> <span class=n>a</span> <span class=err>@</span><span class=n>codegen</span><span class=o>.</span><span class=n>toy</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>20</span>
</span></span><span class=line><span class=cl><span class=p>]</span></span></span></code></pre></td></tr></table></div></div><p>经过 MLIRGen 以下代码的加工处理，将 AST 转变为了 MLIR 表达式，其中的关键在于<code>if (callee == "transpose")</code>，即当程序扫描到<code>transpose</code>关键词时，就会返回构造出的 transpose 的 MLIR表达式中的节点，即第一步的内容</p><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>Value</span> <span class=n>mlirGen</span><span class=p>(</span><span class=n>CallExprAST</span> <span class=o>&amp;</span><span class=n>call</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>callee</span> <span class=o>=</span> <span class=n>call</span><span class=p>.</span><span class=n>getCallee</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=k>auto</span> <span class=n>location</span> <span class=o>=</span> <span class=n>loc</span><span class=p>(</span><span class=n>call</span><span class=p>.</span><span class=n>loc</span><span class=p>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Codegen the operands first.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=n>SmallVector</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>Value</span><span class=p>,</span> <span class=mi>4</span><span class=o>&gt;</span> <span class=n>operands</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>expr</span> <span class=p>:</span> <span class=n>call</span><span class=p>.</span><span class=n>getArgs</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>auto</span> <span class=n>arg</span> <span class=o>=</span> <span class=n>mlirGen</span><span class=p>(</span><span class=o>*</span><span class=n>expr</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>arg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>operands</span><span class=p>.</span><span class=n>push_back</span><span class=p>(</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Builtin calls have their custom operation, meaning this is a
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// straightforward emission.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>if</span> <span class=p>(</span><span class=n>callee</span> <span class=o>==</span> <span class=s>&#34;transpose&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>call</span><span class=p>.</span><span class=n>getArgs</span><span class=p>().</span><span class=n>size</span><span class=p>()</span> <span class=o>!=</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=n>emitError</span><span class=p>(</span><span class=n>location</span><span class=p>,</span> <span class=s>&#34;MLIR codegen encountered an error: toy.transpose &#34;</span>
</span></span><span class=line><span class=cl>                          <span class=s>&#34;does not accept multiple arguments&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>builder</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>TransposeOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>location</span><span class=p>,</span> <span class=n>operands</span><span class=p>[</span><span class=mi>0</span><span class=p>]);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=c1>// Otherwise this is a call to a user-defined function. Calls to
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// user-defined functions are mapped to a custom call that takes the callee
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=c1>// name as an attribute.
</span></span></span><span class=line><span class=cl><span class=c1></span>  <span class=k>return</span> <span class=n>builder</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>GenericCallOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>location</span><span class=p>,</span> <span class=n>callee</span><span class=p>,</span> <span class=n>operands</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>不过存在一个问题是 在构造MLIR表达式节点时，利用到了一个 <code>TransposeOp</code>类，它应当表示的是源程序和MLIR表达式中的 <code>transpose</code>操作，这个类从何而来？</p><p>我目前的理解是，所有数据类型都是在td文件中以一种声明式语法来说明的，后续需要用到哪些类型的文件则通过<code>mlir-tblgen</code>工具来生成。那么如何理解Dialect模块，我的理解是TableGen模块提供的只是一些基本原料，但是这些原料究竟怎么用到项目中，是由Dialect模块来决定的或者说设置的。所以说我们需要通过td文件对于源程序中涉及到的结构进行抽象。</p><p>实际上，从 <code>mlir-tblgen</code> 的 help 信息可以看出，tb文件可以生成很多格式的信息文件</p><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span><span class=lnt>53
</span><span class=lnt>54
</span><span class=lnt>55
</span><span class=lnt>56
</span><span class=lnt>57
</span><span class=lnt>58
</span><span class=lnt>59
</span><span class=lnt>60
</span><span class=lnt>61
</span><span class=lnt>62
</span><span class=lnt>63
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>--gen-attr-interface-decls                        - Generate attribute interface declarations
</span></span><span class=line><span class=cl>--gen-attr-interface-defs                         - Generate attribute interface definitions
</span></span><span class=line><span class=cl>--gen-attr-interface-docs                         - Generate attribute interface documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-attrdef-decls                               - Generate AttrDef declarations
</span></span><span class=line><span class=cl>--gen-attrdef-defs                                - Generate AttrDef definitions
</span></span><span class=line><span class=cl>--gen-attrdef-doc                                 - Generate dialect attribute documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-avail-interface-decls                       - Generate availability interface declarations
</span></span><span class=line><span class=cl>--gen-avail-interface-defs                        - Generate op interface definitions
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-bytecode                                    - Generate dialect bytecode readers/writers
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-convertible-llvmir-intrinsics               - Generate list of convertible LLVM IR intrinsics
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-dialect-decls                               - Generate dialect declarations
</span></span><span class=line><span class=cl>--gen-dialect-defs                                - Generate dialect definitions
</span></span><span class=line><span class=cl>--gen-dialect-doc                                 - Generate dialect documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-directive-decl                              - Generate declarations <span class=k>for</span> directives <span class=o>(</span>OpenMP/OpenACC etc.<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-enum-decls                                  - Generate enum utility declarations
</span></span><span class=line><span class=cl>--gen-enum-defs                                   - Generate enum utility definitions
</span></span><span class=line><span class=cl>--gen-enum-from-llvmir-conversions                - Generate conversions of EnumAttrs from LLVM IR
</span></span><span class=line><span class=cl>--gen-enum-to-llvmir-conversions                  - Generate conversions of EnumAttrs to LLVM IR
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-intr-from-llvmir-conversions                - Generate conversions of intrinsics from LLVM IR
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-llvmir-conversions                          - Generate LLVM IR conversions
</span></span><span class=line><span class=cl>--gen-llvmir-intrinsics                           - Generate LLVM IR intrinsics
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-op-decls                                    - Generate op declarations
</span></span><span class=line><span class=cl>--gen-op-defs                                     - Generate op definitions
</span></span><span class=line><span class=cl>--gen-op-doc                                      - Generate dialect documentation
</span></span><span class=line><span class=cl>--gen-op-from-llvmir-conversions                  - Generate conversions of operations from LLVM IR
</span></span><span class=line><span class=cl>--gen-op-interface-decls                          - Generate op interface declarations
</span></span><span class=line><span class=cl>--gen-op-interface-defs                           - Generate op interface definitions
</span></span><span class=line><span class=cl>--gen-op-interface-docs                           - Generate op interface documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-pass-capi-header                            - Generate pass C API header
</span></span><span class=line><span class=cl>--gen-pass-capi-impl                              - Generate pass C API implementation
</span></span><span class=line><span class=cl>--gen-pass-decls                                  - Generate pass declarations
</span></span><span class=line><span class=cl>--gen-pass-doc                                    - Generate pass documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-python-enum-bindings                        - Generate Python bindings <span class=k>for</span> enum attributes
</span></span><span class=line><span class=cl>--gen-python-op-bindings                          - Generate Python bindings <span class=k>for</span> MLIR Ops
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-rewriters                                   - Generate pattern rewriters
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-spirv-attr-utils                            - Generate SPIR-V attribute utility definitions
</span></span><span class=line><span class=cl>--gen-spirv-avail-impls                           - Generate SPIR-V operation utility definitions
</span></span><span class=line><span class=cl>--gen-spirv-capability-implication                - Generate utility <span class=k>function</span> to <span class=k>return</span> implied capabilities <span class=k>for</span> a given capability
</span></span><span class=line><span class=cl>--gen-spirv-enum-avail-decls                      - Generate SPIR-V enum availability declarations
</span></span><span class=line><span class=cl>--gen-spirv-enum-avail-defs                       - Generate SPIR-V enum availability definitions
</span></span><span class=line><span class=cl>--gen-spirv-serialization                         - Generate SPIR-V <span class=o>(</span>de<span class=o>)</span>serialization utilities and functions
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-type-interface-decls                        - Generate <span class=nb>type</span> interface declarations
</span></span><span class=line><span class=cl>--gen-type-interface-defs                         - Generate <span class=nb>type</span> interface definitions
</span></span><span class=line><span class=cl>--gen-type-interface-docs                         - Generate <span class=nb>type</span> interface documentation
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>--gen-typedef-decls                               - Generate TypeDef declarations
</span></span><span class=line><span class=cl>--gen-typedef-defs                                - Generate TypeDef definitions
</span></span><span class=line><span class=cl>--gen-typedef-doc                                 - Generate dialect <span class=nb>type</span> documentation</span></span></code></pre></td></tr></table></div></div><p>怎么理解这个方言？我目前的看法就是适配器，方言也同时说明了不同的人有不同的说法，同样的对于transpose来说，细节可能也不同，所以才被称之为方言</p><p>但是说通过多层IR逐步降级，这个降级是怎么表现的还是不太明白</p><p>根据<a href="https://mlir.llvm.org/docs/Tutorials/Toy/Ch-2/#:~:text=This%20is%20the%20C%2B%2B%20definition%20of%20a%20dialect%2C%20but%20MLIR%20also%20supports%20defining%20dialects%20declaratively%20via%20tablegen." target=_blank rel="external nofollow noopener noreferrer">This is the C++ definition of a dialect, but MLIR also supports defining dialects declaratively via tablegen.</a>的说法，td文件写的其实就是dialect，这个dialect可以直接通过C++代码进行定义，同时也可以使用tablegen结合td文件生成</p><h4 id=chapter-2-展现出的问题>Chapter 2 展现出的问题</h4><p>以下是通过 <code>toyc-ch2 codegen.toy --emit=mlir</code>生成的 mlir表达式</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>module</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>toy</span><span class=o>.</span><span class=k>func</span> <span class=err>@</span><span class=n>multiply_transpose</span><span class=p>(</span><span class=o>%</span><span class=n>arg0</span><span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>4</span><span class=p>:</span><span class=mi>1</span><span class=p>),</span> <span class=o>%</span><span class=n>arg1</span><span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>4</span><span class=p>:</span><span class=mi>1</span><span class=p>))</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>0</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=o>%</span><span class=n>arg0</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>to</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>10</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>1</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=o>%</span><span class=n>arg1</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>to</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>2</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>mul</span> <span class=o>%</span><span class=mi>0</span><span class=p>,</span> <span class=o>%</span><span class=mi>1</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>25</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>toy</span><span class=o>.</span><span class=k>return</span> <span class=o>%</span><span class=mi>2</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>4</span><span class=p>:</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=n>toy</span><span class=o>.</span><span class=k>func</span> <span class=err>@</span><span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>0</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>constant</span> <span class=n>dense</span><span class=o>&lt;</span><span class=p>[[</span><span class=mf>1.000000e+00</span><span class=p>,</span> <span class=mf>2.000000e+00</span><span class=p>,</span> <span class=mf>3.000000e+00</span><span class=p>],</span> <span class=p>[</span><span class=mf>4.000000e+00</span><span class=p>,</span> <span class=mf>5.000000e+00</span><span class=p>,</span> <span class=mf>6.000000e+00</span><span class=p>]]</span><span class=o>&gt;</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>9</span><span class=p>:</span><span class=mi>17</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>1</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>%</span><span class=mi>0</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>to</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>9</span><span class=p>:</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>2</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>constant</span> <span class=n>dense</span><span class=o>&lt;</span><span class=p>[</span><span class=mf>1.000000e+00</span><span class=p>,</span> <span class=mf>2.000000e+00</span><span class=p>,</span> <span class=mf>3.000000e+00</span><span class=p>,</span> <span class=mf>4.000000e+00</span><span class=p>,</span> <span class=mf>5.000000e+00</span><span class=p>,</span> <span class=mf>6.000000e+00</span><span class=p>]</span><span class=o>&gt;</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>6</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>10</span><span class=p>:</span><span class=mi>17</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>3</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>reshape</span><span class=p>(</span><span class=o>%</span><span class=mi>2</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>6</span><span class=n>xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>to</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>10</span><span class=p>:</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>4</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>generic_call</span> <span class=err>@</span><span class=n>multiply_transpose</span><span class=p>(</span><span class=o>%</span><span class=mi>1</span><span class=p>,</span> <span class=o>%</span><span class=mi>3</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>11</span><span class=p>:</span><span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>5</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>generic_call</span> <span class=err>@</span><span class=n>multiply_transpose</span><span class=p>(</span><span class=o>%</span><span class=mi>3</span><span class=p>,</span> <span class=o>%</span><span class=mi>1</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>12</span><span class=p>:</span><span class=mi>11</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>toy</span><span class=o>.</span><span class=n>print</span> <span class=o>%</span><span class=mi>5</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>13</span><span class=p>:</span><span class=mi>3</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>toy</span><span class=o>.</span><span class=k>return</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>8</span><span class=p>:</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>8</span><span class=p>:</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>loc</span><span class=p>(</span><span class=n>unknown</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><p>可以看出这个层次下的 mlir表达式 是严格按照代码逐句翻译后的结果，例如下面两句是 源代码 和 对应的mlir表达式，实际上从 tensor&lt;*xf64> transpose到 tensor&lt;*xf64> 显然是没有意义的，这是一步冗余的操作，所以 Chapter 3 就着手通过 表达式优化 来解决这个问题</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>var</span> <span class=n>a</span><span class=o>&lt;</span><span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=o>&gt;</span> <span class=o>=</span> <span class=p>[[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>],</span> <span class=p>[</span><span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=mi>6</span><span class=p>]];</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>%</span><span class=mi>0</span> <span class=o>=</span> <span class=n>toy</span><span class=o>.</span><span class=n>transpose</span><span class=p>(</span><span class=o>%</span><span class=n>arg0</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=n>to</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xf64</span><span class=o>&gt;</span> <span class=n>loc</span><span class=p>(</span><span class=s2>&#34;codegen.toy&#34;</span><span class=p>:</span><span class=mi>5</span><span class=p>:</span><span class=mi>10</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><h3 id=chapter-3>Chapter 3</h3><blockquote><p>High-level Language-Specific Analysis and Transformation</p></blockquote><p>关于表达式变形消除冗余在整个流程中的位置：</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191137970.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>Chapter 3 的展开逻辑本质上是遵循了 Chapter 2 遗留下来的问题，不过其重新提出了一个 <code>transpose(transpose(X)) -> X</code> 的问题，讲述如何解决这个问题。需要注意的是本节一共举了为两个操作添加优化方法的示例，它们采用了不同的方法， transpose操作 采用了 C++ 实现(对应ToyCombine.cpp)，reshape操作 采用了 DRR模块(对应ToyCombine.td)</p><p>这一节中，共涉及到整体架构的三部分；
<a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201132203.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>这一节对应到的是 MLIR 的 Pattern Rewrite机制，用于对IR做一些通用变换优化，还负责Op的规范化以及Dialect间以及Dialect内部的Op转换，我感觉就是架构图中提到的 transformation 和 canonicalization</p><h4 id=c-实现-canonicalization>C++ 实现 canonicalization</h4><p>表达式的变形优化 在 MLIR 的场景下被称为 rewrite</p><p>想要实现 rewrite 需要进行以下几点：</p><ol><li>实现一个 RewritePattern，即一个继承了<code>mlir::OpRewritePattern&lt;></code>的类</li></ol><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SimplifyRedundantTranspose</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>::</span><span class=n>OpRewritePattern</span><span class=o>&lt;</span><span class=n>TransposeOp</span><span class=o>&gt;</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>当继承这个<code>OpRewritePattern</code>类后，需要重写<code>matchAndRewri</code>方法</p></blockquote><ol start=2><li>rewrite能够被应用，需要通过 canonicalization pass。需要做的工作一方面是让 规范化器知道有这个 rewrite 的存在，另一方面就是让其运用上这一 rewrite。所以这一步就是实现注册工作</li></ol><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>getCanonicalizationPatterns</span><span class=p>(</span><span class=n>RewritePatternSet</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>results</span><span class=p>.</span><span class=n>add</span><span class=o>&lt;</span><span class=n>SimplifyRedundantTranspose</span><span class=o>&gt;</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>不过有一点疑问是，这里只是类方法的定义，并没有找到对此方法的调用，那么是什么时候真正执行的注册?</p><p>关于这个问题，官方文档中有提到一个 canonicalization framework，虽然在第2点中说注册是为了让 规范化器 知道有这个rewrite的存在，但是本质上可能是为了让这个 优化框架 了解到这个rewrite的存在。有一种可能就是只要我们为一个操作定义了<code>getCanonicalizationPatterns</code>方法，那么 MLIR 在面对这个操作类的时候，就一定能检测到它是具备这个优化方法的，那么在下一步就能够真正实现这种优化。</p><blockquote><p>真实的实现机制需要去看 MLIR 实现的源码是怎么处理的，我们暂且可以认为这样做就是满足 MLIR对于实现一个方法的优化 所做出的规定，也就是说 MLIR 提供了一种标准化的模版，我们只需要按照模版的要求去做，那么就可以为这个操作实现这种优化（实际上 Chapter 4 给出了支持这种看法的证据，详见Chapter 4）</p></blockquote><ol start=3><li>规范化器 的 代码原型 就是 <code>mlir::PassManager</code>，即我们需要利用它来真正运用上第一步实现的 rewrite</li></ol><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>PassManager</span> <span class=n>pm</span><span class=p>(</span><span class=n>module</span><span class=p>.</span><span class=n>get</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>pm</span><span class=p>.</span><span class=n>addNestedPass</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>toy</span><span class=o>::</span><span class=n>FuncOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>createCanonicalizerPass</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><h4 id=使用-drr模块-实现-transformation>使用 DRR模块 实现 transformation</h4><p>相较于C++实现，使用 DRR模块 的优点似乎就在于省去了后两步的注册和应用到规范化器的两项操作，只需要实现一个继承关系即可</p><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Pattern</span><span class=o>&lt;</span>
</span></span><span class=line><span class=cl>    <span class=n>dag</span> <span class=n>sourcePattern</span><span class=p>,</span> <span class=n>list</span><span class=o>&lt;</span><span class=n>dag</span><span class=o>&gt;</span> <span class=n>resultPatterns</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>list</span><span class=o>&lt;</span><span class=n>dag</span><span class=o>&gt;</span> <span class=n>additionalConstraints</span> <span class=o>=</span> <span class=p>[],</span>
</span></span><span class=line><span class=cl>    <span class=n>dag</span> <span class=n>benefitsAdded</span> <span class=o>=</span> <span class=p>(</span><span class=n>addBenefit</span> <span class=mi>0</span><span class=p>)</span><span class=o>&gt;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>def</span> <span class=nl>ReshapeReshapeOptPattern</span> <span class=p>:</span> <span class=n>Pat</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ReshapeOp</span><span class=p>(</span><span class=n>ReshapeOp</span> <span class=err>$</span><span class=n>arg</span><span class=p>)),</span>
</span></span><span class=line><span class=cl>                                   <span class=p>(</span><span class=n>ReshapeOp</span> <span class=err>$</span><span class=n>arg</span><span class=p>)</span><span class=o>&gt;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>不过教程中还额外给出了另外两种实现方式，那两种只是说在基础之上，额外添加了其他信息：</p><ol><li>增加了参数限制：只需要实现一个<code>Constraint</code>类的子类，并且将该子类在创建模式时添加到模版参数之中</li><li>当限制条件比较复杂时，可以通过实现一个<code>NativeCodeCall</code>的子类添加原生的C++语句实现，同样在创建模式时将其添加到模版参数之中</li></ol><h4 id=对-chapter-3-的理解和感悟>对 Chapter 3 的理解和感悟</h4><p>这样来说，是不是可以理解为 rewrite 就是一种 pass</p><p>通过这一部分内容，更加加深了对于 MLIR 似乎就和 SpringBoot 那种东西一样，我们似乎完全可以把他们当作普通的框架，为操作添加优化就是必须要为操作类定义<code>getCanonicalizationPatterns</code>方法，这就好像在其他那些框架中所要求做的类似</p><h4 id=compiler-pattern-match-transformations-分类>compiler pattern-match transformations 分类</h4><ol><li>local</li></ol><p>有两种方法用于实现transformation：</p><ul><li>Imperative, C++ pattern-match and rewrite</li><li>Declarative, rule-based pattern-match and rewrite(Declarative Rewrite Rules (DRR)模块)(此时要求之前的op定义是通过ods模块实现的，否则只能采用C++代码手动实现transformation了)</li></ul><p>到这里，架构图中涉及到的两个模块就都出现了</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403191146250.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=2><li>global</li></ol><h4 id=关于-pattern-rewrite机制-的疑问>关于 Pattern Rewrite机制 的疑问</h4><p>在这个机制下，存在一些名称极为类似暂时还不清楚用途的类，例如</p><ul><li><code>RewriterBase</code></li><li><code>PatternRewriter</code></li></ul><p>以上两者关系见</p><p><a href=https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase.html#details target=_blank rel="external nofollow noopener noreferrer"><a class=lightgallery href="https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png?size=large" data-thumbnail="https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png?size=small" data-sub-html="<h2>https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png</h2>"><img loading=lazy src=https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png srcset="https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png?size=small, https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png?size=medium 1.5x, https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png?size=large 2x" sizes=auto data-title=https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png data-alt=https://mlir.llvm.org/doxygen/classmlir_1_1RewriterBase__inherit__graph.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></a></p><ul><li><code>RewritePattern</code></li><li><code>OpRewritePattern</code></li></ul><p>上面这 4 个类是不同的，区别在于前者核心是 rewriter，后者核心是 pattern</p><p>这两个 pattern 之间的继承关系如下：</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403211147117.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=chapter-4>Chapter 4</h3><blockquote><p>Enabling Generic Transformation with Interfaces</p></blockquote><p>在 Chapter 3 的 C++ 实现 transformation 一节中留下了一个疑问，即在给一个 operation 应用一种 模式patter，或者说希望重写它时，我们是定义了<code>TransposeOp::getCanonicalizationPatterns</code>这一方法，当时我们疑问在于代码中只是定义了但是并没有在任何位置看到调用它的代码，那么其是如何发挥作用的？</p><p>在 Chapter 4 开头给出，<code>getCanonicalizationPatterns</code> 实际是一个钩子函数，作用于operations之上，通过钩子函数实现为 operation 添加额外功能的方法并不难理解，这也是软件开发中常见的一种方法</p><p>不过钩子函数从何而来，是需要我们自行创建（如果是这样的话，又需要在哪个环节进行创建），还是 MLIR 本身对于 operation 就声明了一些固定的钩子函数？</p><p>关于这个问题，我们进行了如下的探究：</p><ol><li>关于 <code>TransposeOp</code>，源头应当位于 <code>Ops.td</code>，所以我们回到这一文件</li></ol><p>文件中主要包含 2 部分内容，一是对于 <code>Dialect</code> 的说明，二是对于 operation 的说明</p><p>对于 <code>Dialect</code> 的说明：</p><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def Toy_Dialect : Dialect {
</span></span><span class=line><span class=cl>  let name = &#34;toy&#34;;
</span></span><span class=line><span class=cl>  let cppNamespace = &#34;::mlir::toy&#34;;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>对于 operation 的说明：</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Toy_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :
</span></span><span class=line><span class=cl>    Op&lt;Toy_Dialect, mnemonic, traits&gt;;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>def TransposeOp : Toy_Op&lt;&#34;transpose&#34;&gt;{
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>由此可见，关于 operation 的继承关系是 TransposeOp -> Toy_Op -> Op</p><ol start=2><li>由于 td 只是声明性语言，并不代码最终的代码实现，所以我们对 cpp 文件下的实际的 TransposeOp类 进行了追踪，发现其实际声明位于 Ops.h.inc，同时声明内容为</li></ol><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>TransposeOp</span> <span class=o>:</span> <span class=k>public</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Op</span><span class=o>&lt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=kt>void</span> <span class=nf>getCanonicalizationPatterns</span><span class=p>(</span><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>RewritePatternSet</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span> <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>由于 Ops.h.inc 是有 Ops.td 生成的，但是在 Ops.td 中并没有显示给出 getCanonicalizationPatterns 的声明，说明这一方法应当是通过继承关系得到的(在llvm源码中，确实有找到 和 getCanonicalizationPatterns 相关的内容，不过还未完全分析透彻逻辑关系）,说明只要是继承了 mlir::Op 的子类，都应当是能够使用这个钩子函数的</p><p>官方定义的毕竟是有限且不够灵活的，所以 MLIR 就提出了 interface 的概念，用户可以自定义实现各种钩子函数（感觉这就是一个组件化工具正常的发展流程，官方提供一些，然后官方开放接口，第三方可自行实现接入）</p><p>本 Chapter 提及的也是 Dialect 的一个子部分</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403201134960.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>引入的情景是 tensor 的形状推导</p><p>目前感觉 Chapter 4 所介绍的 Interface 只是对于 Chapter 3 所介绍的用于表达式优化的 pattern 在功能性上的一种扩充，所以说并不需要把其当作一种新的技术点</p><h2 id=mlir-python-bindings>MLIR Python Bindings</h2><p>MLIR 表达式的构建在此之前都是通过 C++ 代码实现的，</p><p>法斯特豪斯博客里面给的也是一个创建 operation 的流程，应该是将 c++源程序 解析为 MLIR表达式这个过程，而不是对 MLIR 表达式进行降级这个过程</p><p>按照我目前的理解，python binding 是用在 frontend 的，用在将 python源程序 解析为 MLIR表达式这个过程，就像将 C++源程序 解析为 MLIR表达式</p><p>将源程序解析为 MLIR 表达式是 frontend 的工作，而对 MLIR 表达式进行降级是 middleend 的工作</p><p>python binding 关注的是 frontend 的工作，或者说其就是用于实现 MLIRGen 模块的</p><p>只要理解了 frontend + backend 这个结构，python binding存在的意义就不难理解了，后续的关键问题就是为了实现将 python 解析为 MLIR 表达式，需要写哪些内容</p><p>而 frontend 的重点就是 MLIRGen，这包含两部分工作：一是 源代码 生成 AST，这一步和 MLIR 并没有关联；二是 AST 生成 MLIR 表达式，在这一步中 MLIR 才开始介入</p><p>因为 MLIR 本身是 C++ 实现的，tablegen 工具最终生成的也同样为 C++ 代码，所以通过 C++ 实现从一种 语言源程序 转换为 MLIR 表达式，这个过程是很自然的(C++ 代码调用 C++ 代码)。而使用 python 实现 MLIR 表达式生成，需要利用 tablegen 生成的 C++ 代码内容，但是又无法直接使用，所以就需要通过 python binding，将 C++ 内容生成 python 接口，以供 python 实现的 MLIRGen 模块使用，因此我们首先了解一下 C++ 代码实现的 MLIRGen 模块所需要进行的工作，以便更好迁移到 python 实现上。</p><h3 id=生成-mlir-表达式-所需的模块mlir-mode>生成 MLIR 表达式 所需的模块：<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></h3><ol><li>TableGen模块(生产线的零件): 通过.td文件定义了各种操作的类（这部分也叫做Operation Definition Specification (ODS)框架）(我理解这部分也可以通过手动编写C++代码实现，只是说可能写起来比较繁琐，同时在不同的场景下可能存在类似的需求，如果总是手动编写会带来很大的重复工作量，所以说一般通过td文件结合TableGen工具来生成)</li><li>Dialect模块(生产线的机械臂): 负责定义各种操作和分析，为操作添加相应的类型和操作数的值</li><li>MLIRGen模块(生产线履带): 遍历抽象语法树(AST)，构造 MLIR 节点</li></ol><blockquote><p>TableGen模块在编译时向Dialect模块提供支持</p></blockquote><p>我理解着上述这 3 个模块之间的关系，或者说作用流程，大概是 TableGen 模块生成的是一种类似模版的东西，然后 Dialect 像是具体的适配器，为模版添加不同的属性，这样两阶段分离的设计可以做到 模版 和 数据 解耦合，同时做到 模版 的复用，最后再通过 MLIRGen 将添加了具体属性的模版 生成为 MLIR 节点</p><p><a class=lightgallery href="https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp?size=large" data-thumbnail="https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp?size=small" data-sub-html="<h2>https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp</h2>"><img loading=lazy src=https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp srcset="https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp?size=small, https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp?size=medium 1.5x, https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp?size=large 2x" sizes=auto data-title=https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp data-alt=https://pic4.zhimg.com/80/v2-95f6bf7b8482ab5a4d8541d16ba6cf7b_1440w.webp style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>关注图中TransposeOp的指向</p><p>从项目的编译结果来看，build/python 下的文件都是通过工具生成的，那么直观来理解，我们只需要编写好 tablegen 的内容以及 pybind 所涉及到的接口，通过 pybind 提供的 cmake 即可根据 tablegen 生成的 c++ 内容生成对应的 python 内容，然后直接在 MLIRGen 模块中使用即可。</p><h2 id=mlir-hello-world>mlir &ldquo;hello world&rdquo;</h2><p>假设现在有下面这样一段 mlir，我们的目标是让其能够在机器上跑起来</p><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>func</span><span class=o>.</span><span class=k>func</span> <span class=err>@</span><span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>0</span> <span class=o>=</span> <span class=s2>&#34;hello.constant&#34;</span><span class=p>()</span> <span class=p>{</span><span class=n>value</span> <span class=o>=</span> <span class=n>dense</span><span class=o>&lt;</span><span class=p>[[</span><span class=mf>1.000000e+00</span><span class=p>,</span> <span class=mf>2.000000e+00</span><span class=p>,</span> <span class=mf>3.000000e+00</span><span class=p>],</span> <span class=p>[</span><span class=mf>4.000000e+00</span><span class=p>,</span> <span class=mf>5.000000e+00</span><span class=p>,</span> <span class=mf>6.000000e+00</span><span class=p>]]</span><span class=o>&gt;</span> <span class=p>:</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>}</span> <span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;hello.print&#34;</span><span class=p>(</span><span class=o>%</span><span class=mi>0</span><span class=p>)</span> <span class=p>:</span> <span class=p>(</span><span class=n>tensor</span><span class=o>&lt;</span><span class=mi>2</span><span class=n>x3xf64</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=定义-dialect>定义 Dialect</h3><p>这里面涉及到一个 hello Dialect，其至少需要 constant 和 print 两个 operation</p><p>从项目文件结构上来说，和目前需要的文件包含两部分：HelloDialect.[h/td] 和 HelloOps.[h/td]，前者对应 Dialect，后者对应 operation</p><p>主要需要做的是两件事：1. 创建新的 Dialect 2. 创建 operation 基类</p><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def Hello_Dialect : Dialect {
</span></span><span class=line><span class=cl>    // 定义名字空间 namespace，对应 C++ 的 getDialectNamespace 方法返回值
</span></span><span class=line><span class=cl>    let name = &#34;hello&#34;;
</span></span><span class=line><span class=cl>    ...
</span></span><span class=line><span class=cl>    let cppNamespace = &#34;::hello&#34;;
</span></span><span class=line><span class=cl>    // 该设置用于激活 materializeConstant 方法，这使得可以例如 Canonicalize 优化
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class Hello_Op&lt;string mnemonic, list&lt;Trait&gt; traits = []&gt; :
</span></span><span class=line><span class=cl>        Op&lt;Hello_Dialect, mnemonic, traits&gt;;</span></span></code></pre></td></tr></table></div></div><h3 id=定义-operation>定义 operation</h3><p>使用 <code>mlir-tblgen</code> 工具对 HelloOps.td 进行转换可以得到对于 operation 的声明，其中包含的类的继承关系为</p><ul><li>constant operation</li></ul><p>ConstantOpAdaptor -> ConstantOpGenericAdaptor -> ConstantOpGenericAdaptorBase (前者继承后者)</p><p>核心的 ConstantOp 继承的是 ::mlir::Op，不过其会利用到上述 3 种类</p><ul><li>print operation</li></ul><p>PrintOpAdaptor -> PrintOpGenericAdaptor -> PrintOpGenericAdaptorBase</p><p>新的 operation 一般至少包含 4 个元素（实际上并不知道这几种字段都负责什么）</p><ul><li>summary</li><li>builders</li><li>arguments</li><li>results</li></ul><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>def</span> <span class=nf>ConstantOp</span> <span class=p>:</span> <span class=n>Hello_Op</span><span class=o>&lt;</span><span class=s2>&#34;constant&#34;</span><span class=p>,</span> <span class=p>[</span><span class=n>Pure</span><span class=p>]</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=o>//</span> <span class=err>一行关于这个</span> <span class=n>Op</span> <span class=err>的介绍</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>summary</span> <span class=o>=</span> <span class=s2>&#34;constant&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>builders</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>    <span class=n>OpBuilder</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ins</span> <span class=s2>&#34;mlir::DenseElementsAttr&#34;</span><span class=p>:</span><span class=o>$</span><span class=n>value</span><span class=p>),</span> <span class=p>[{</span>
</span></span><span class=line><span class=cl>      <span class=n>build</span><span class=p>(</span><span class=o>$</span><span class=n>_builder</span><span class=p>,</span> <span class=o>$</span><span class=n>_state</span><span class=p>,</span> <span class=n>value</span><span class=o>.</span><span class=n>getType</span><span class=p>(),</span> <span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}]</span><span class=o>&gt;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>OpBuilder</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ins</span> <span class=s2>&#34;double&#34;</span><span class=p>:</span><span class=o>$</span><span class=n>value</span><span class=p>)</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=o>...</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>arguments</span> <span class=o>=</span> <span class=p>(</span><span class=n>ins</span> <span class=n>F64ElementsAttr</span><span class=p>:</span><span class=o>$</span><span class=n>value</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>results</span> <span class=o>=</span> <span class=p>(</span><span class=n>outs</span> <span class=n>F64Tensor</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h3 id=创建-pass>创建 pass</h3><p>如果只看 mlir-hello，那么 pass 实际上只用于了 lowering 的过程，但是实际上 lowering 和 transformation 两个过程使用到的都属于 pass，后续的描述由于是在看 mlir-hello 时所写，所有有可能偏向于 lowering，但是你需要知道的是 pass 也可同样应用于 transformation。简单点来理解，只要涉及到形式上的变化，都可以使用 pass 来完成。</p><p>同时 pass 的实现可以通过手写 C++ 实现，也可以通过利用 DRR（Declarative Rewrite Rule）框架来实现</p><p><strong>降级到底在降什么？</strong></p><p>HelloDialect 是我们自定义出的 dialect，而我们最终的目标是对接到 LLVM backend，这些自定义 dialect 显然是做不到的，但是 MLIR 本身提供的一些 dialect 可以做到，可能 LLVM 为它们提供了对接方式。</p><p>所以说我们所需要做的，一方面是在自定义 dialect 之间实现转化，另一方面是需要把 自定义dialect 转换到 MLIR提供的 dialect（可以理解为标准库）上</p><p>这部分工作除了需要用到 dialect 和 operation 作为基本原料，还需要 HelloPasses.h 来注册pass，即从一种 dialect 转换到另一种 dialect。仅注册还不行，还需要 LowerToAffine.cpp 的具体实现</p><hr><p>以上提到了两个文件 HelloPasses.h 和 LowerToAffine.cpp，不过在实际的项目中并不一定就只有这两个文件，可能会进行很多拆分，不过我们只需要掌握这两个文件所要完成的核心工作即可适应各种项目</p><h4 id=方法-1---全人工实现>方法 1 - 全人工实现</h4><blockquote><p>此部分遵循 mlir-hello 项目的实现方式</p></blockquote><ol><li>pass 注册</li></ol><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=n>createLowerToAffinePass</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><p>所谓注册，其实就是创建了一个 pass 的函数钩子</p><ol start=2><li>pass实现</li></ol><p>2.1 编写操作的 lowering</p><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>ConstantOpLowering</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>::</span><span class=n>OpRewritePattern</span><span class=o>&lt;</span><span class=n>hello</span><span class=o>::</span><span class=n>ConstantOp</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span>
</span></span><span class=line><span class=cl>  <span class=n>matchAndRewrite</span><span class=p>(</span><span class=n>hello</span><span class=o>::</span><span class=n>ConstantOp</span> <span class=n>op</span><span class=p>,</span> <span class=n>mlir</span><span class=o>::</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span> <span class=k>final</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>首先不考虑具体的实现细节，观察这部分代码的核心有以下几点：</p><ul><li>定义为 class XxxOpLowering</li><li>继承自 mlir::OpRewritePattern<a href=xxx::XxxOp>xxx::XxxOp</a></li><li>重载 matchAndRewrite 函数，做具体实现</li><li>XxxOpLowering 最终将作为模板参数传入新 pass 的 mlir::RewritePatternSet<xxxoplowering>(这一点并不在此函数中实现，而实在下一部分)</li></ul><p>2.2 实现 dialect 到 dialect 的转换（将 lowering 加入 pass）</p><blockquote><p>实际项目中，这一步会划分为 声明(.h 文件中) 和 实现(.cpp 文件中) 两部分，一般 runOnOperation() 的实现会置于 cpp 文件中，这里为了描述上的简洁就合并在一起了</p></blockquote><div class=highlight id=id-31><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>HelloToAffineLowerPass</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>::</span><span class=n>PassWrapper</span><span class=o>&lt;</span><span class=n>HelloToAffineLowerPass</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                               <span class=n>mlir</span><span class=o>::</span><span class=n>OperationPass</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>ModuleOp</span><span class=o>&gt;&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>  <span class=n>MLIR_DEFINE_EXPLICIT_INTERNAL_INLINE_TYPE_ID</span><span class=p>(</span><span class=n>HelloToAffineLowerPass</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=n>getDependentDialects</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>DialectRegistry</span> <span class=o>&amp;</span><span class=n>registry</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>registry</span><span class=p>.</span><span class=n>insert</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>affine</span><span class=o>::</span><span class=n>AffineDialect</span><span class=p>,</span> <span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                    <span class=n>mlir</span><span class=o>::</span><span class=n>memref</span><span class=o>::</span><span class=n>MemRefDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=kt>void</span> <span class=nf>runOnOperation</span><span class=p>()</span> <span class=k>final</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mlir</span><span class=o>::</span><span class=n>RewritePatternSet</span> <span class=n>patterns</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=n>patterns</span><span class=p>.</span><span class=n>add</span><span class=o>&lt;</span><span class=n>ConstantOpLowering</span><span class=p>,</span> <span class=n>PrintOpLowering</span><span class=o>&gt;</span><span class=p>(</span><span class=o>&amp;</span><span class=n>getContext</span><span class=p>());</span>
</span></span><span class=line><span class=cl>  <span class=p>};</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>这里的重点在于实现了 <code>runOnOperation()</code> 方法, 在此方法中完成上一步所提及的 lowering 作为模版参数传入 pass</p><p>2.3 完成函数钩子</p><div class=highlight id=id-32><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=n>hello</span><span class=o>::</span><span class=n>createLowerToAffinePass</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>std</span><span class=o>::</span><span class=n>make_unique</span><span class=o>&lt;</span><span class=n>HelloToAffineLowerPass</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p><strong>如何理解这一 function hook?</strong></p><p>从 <a href=https://mlir.llvm.org/docs/PassManagement/#declarative-pass-specification target=_blank rel="external nofollow noopener noreferrer">official website - Pass Infrastructure - Declarative Pass Specification</a> 中可以找到在使用 td 声明 pass 时，指定 constructor 的 作用为</p><blockquote><p>A constructor must be provided to specify how to create a default instance of MyPass.</p></blockquote><p>而为 constructor 指定的内容就是我们创建的 function hook，因此这一 function hook 的作用即为 指出如何创建一个 pass 的实例</p><hr><p>所以综合以上所有内容来看，创建一个 pass，其实就是 create 了一个 <code>unique_str</code>，这个智能指针指向了一个类，这个类实现了 <code>runOnOperation()</code>方法，并且在这个方法中有指定操作的匹配重写规则</p><h4 id=方法-2---使用-tablegen>方法 2 - 使用 tablegen</h4><p>在人工实现中，创建 pass 时，我们是手动继承的 <code>mlir::PassWrapper</code> 类。</p><p>而使用 tablegen 时，首先会在 td 文件中给出一个对 pass 的继承，如以下代码所示。</p><div class=highlight id=id-33><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>def ConvertGraphToMatrix <span class=p>:</span> Pass<span class=p>&lt;</span><span class=s>&#34;convert-graph-to-matrix&#34;</span><span class=p>,</span> <span class=s>&#34;ModuleOp&#34;</span><span class=p>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  let <span class=nl>summary =</span> <span class=s>&#34;Convert Graph Ops to Matrix Ops&#34;</span><span class=err>;</span>
</span></span><span class=line><span class=cl>  let <span class=nl>constructor =</span> <span class=s>&#34;compiler::createConvertGraphToMatrix()&#34;</span><span class=err>;</span>
</span></span><span class=line><span class=cl>  let <span class=nl>dependentDialects =</span> <span class=p>[</span><span class=s>&#34;compiler::graph::GraphDialect&#34;</span><span class=p>,</span> <span class=s>&#34;compiler::matrix::MatrixDialect&#34;</span><span class=p>]</span><span class=err>;</span>
</span></span><span class=line><span class=cl>  let <span class=nl>options =</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>]</span><span class=err>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>而这部分代码经过 tablegen 转换后所形成的类，以及相关的继承关系为：<code>ConvertGraphToMatrixBase</code> -> <code>mlir::OperationPass</code>。</p><p>这里出现了两种不同的基类（我个人理解全人工实现下也一样可以采用 <code>OperationPass</code>），<code>PassWrapper</code> 和 <code>OperationPass</code>，它们二者之间也有着一定继承关系</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405231613671.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>之后的操作其实就与全人工实现的方式类似了，不同之处在于创建包含 <code>runOnOperation()</code> 方法的类时，不再去继承 <code>mlir::PassWrapper</code> 类，而是直接继承 <code>ConvertGraphToMatrixBase</code>。</p><p>然后其他需要做的事情并没有改变。</p><p>那么不禁让人产生一种疑问，当我们采用 tablegen 时，除了在创建包含<code>runOnOperation()</code> 方法的类时，多增加了编写 td 文件的一步，其他流程并没有减少，相当于使用 td 反而让流程变得更加复杂了。</p><p>实际上，如果我们在 td 中给定了 <code>constructor</code>，我们看 td 文件生成的内容时，就会发现其中包含着 pass 的 function hook，但是目前简单的测试下，还无法正常直接使用这些 function hook，利用的仍然是人工给出的内容，后续可以再进行其他测试，按照理解，当使用 tablegen 并且指定 <code>constructor</code> 时，应当就无需人工声明和定义 function hook 了，即只需要重写 <code>matchAndRewrite()</code> 和 <code>runOnOperation()</code>, 从而通过 tablegen 简化代码编写。</p><p>同时需要注意的是，mlir-hello 这里为了降低理解上的难度，并没有采用 td 文件来实现 pass 的声明，而是直接利用了 C++ 代码</p><h4 id=方法-3---借助-canonicalization-framework>方法 3 - 借助 Canonicalization Framework</h4><p>canonicalization function 同 pass 的关系为，canonicalization function 可以认为是一种 pass，但是 pass 所执行的并不一定是 canonicalization 功能。</p><p>以 transpose 操作为例，如果为此 operation 指定了一个消除重复转置的规范化器 canonicalization，那么在发生重复转置后可以对此操作进行规范化，以进行表达式优化，然而这种效果是通过自定义 pass 同样可以实现的。</p><p>但是 pass 的概念则更加宽泛一些，不同 Dialect 之间的转换以及 IR 之间的转换都可以称之为 pass，但是这从含义上来说就不属于规范化。</p><p>因此在实际应用中，是否采用 Canonicalization Framework 只需要考虑是否进行的一种对于操作的规范化，如果是则采用规范化器，反之如果仅仅是转换，则应当采用 pass。</p><blockquote><p>据说只需要实现 <code>matchAndRewrite</code> 方法即可，暂时没有实验过</p></blockquote><p>2024/04/24，在<a href=http://giantpandacv.com/project/%E9%83%A8%E7%BD%B2%E4%BC%98%E5%8C%96/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8/%E3%80%90%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BC%96%E8%AF%91%E5%99%A8%E3%80%91%E5%8D%81%E4%B8%89%EF%BC%8C%E5%A6%82%E4%BD%95%E5%9C%A8MLIR%E9%87%8C%E9%9D%A2%E5%86%99Pass%EF%BC%9F/#ctranspose target=_blank rel="external nofollow noopener noreferrer">【从零开始学深度学习编译器】十三，如何在 MLIR 里面写 Pass？</a> 这篇文章中，看到了另一种使用 pass 的方式，即借助于 归范化框架（Canonicalization Framework），与上述的流程相比，相同之处在于仍然需要给出实现了 <code>matchAndRewrite</code> 方法的类，但是 function hook 和 实现了 <code>runOnOperation</code> 方法的类都无需给出。只需要在创建 operation 时添加一个选项 <code>let hasCanonicalizer = 1;</code>，并且给出 <code>xxxOp::getCanonicalizationPatterns()</code> 的实现，最后在 opt 工具中注册另一种 pass 即可。</p><p>这里给出一个示例，展示在使用 Canonicalization Framework 时所需要进行的所有操作</p><ol><li>operation tablegen 文件中添加 <code>let hasCanonicalizer = 1;</code></li></ol><div class=highlight id=id-34><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=n>def</span><span class=w> </span><span class=n>TransposeOp</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=n>Toy_Op</span><span class=o>&lt;</span><span class=s2>&#34;transpose&#34;</span><span class=p>,</span><span class=w> </span><span class=p>[</span><span class=n>Pure</span><span class=p>]</span><span class=o>&gt;</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>summary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;transpose operation&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>arguments</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ins</span><span class=w> </span><span class=n>F64Tensor</span><span class=p>:</span><span class=err>$</span><span class=n>input</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>results</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>outs</span><span class=w> </span><span class=n>F64Tensor</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>assemblyFormat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=o>`</span><span class=p>(</span><span class=o>`</span><span class=w> </span><span class=err>$</span><span class=n>input</span><span class=w> </span><span class=o>`</span><span class=p>:</span><span class=o>`</span><span class=w> </span><span class=nf>type</span><span class=p>(</span><span class=err>$</span><span class=n>input</span><span class=p>)</span><span class=w> </span><span class=o>`</span><span class=p>)</span><span class=o>`</span><span class=w> </span><span class=n>attr</span><span class=o>-</span><span class=n>dict</span><span class=w> </span><span class=o>`</span><span class=k>to</span><span class=o>`</span><span class=w> </span><span class=nf>type</span><span class=p>(</span><span class=n>results</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>}</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>Enable</span><span class=w> </span><span class=n>registering</span><span class=w> </span><span class=n>canonicalization</span><span class=w> </span><span class=n>patterns</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=n>this</span><span class=w> </span><span class=n>operation</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>hasCanonicalizer</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>Allow</span><span class=w> </span><span class=n>building</span><span class=w> </span><span class=n>a</span><span class=w> </span><span class=n>TransposeOp</span><span class=w> </span><span class=k>with</span><span class=w> </span><span class=k>from</span><span class=w> </span><span class=n>the</span><span class=w> </span><span class=n>input</span><span class=w> </span><span class=n>operand</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>builders</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OpBuilder</span><span class=o>&lt;</span><span class=p>(</span><span class=n>ins</span><span class=w> </span><span class=s2>&#34;Value&#34;</span><span class=p>:</span><span class=err>$</span><span class=n>input</span><span class=p>)</span><span class=o>&gt;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>Indicate</span><span class=w> </span><span class=n>that</span><span class=w> </span><span class=n>additional</span><span class=w> </span><span class=n>verification</span><span class=w> </span><span class=k>for</span><span class=w> </span><span class=n>this</span><span class=w> </span><span class=n>operation</span><span class=w> </span><span class=k>is</span><span class=w> </span><span class=n>necessary</span><span class=p>.</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>hasVerifier</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>重写 <code>matchAndRewrite</code> 方法</li></ol><div class=highlight id=id-35><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/IR/MLIRContext.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/IR/PatternMatch.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/IR/Value.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;mlir/Support/LogicalResult.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;toy/Dialect.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>using</span> <span class=k>namespace</span> <span class=n>mlir</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>using</span> <span class=k>namespace</span> <span class=n>toy</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>SimplifyRedundantTranspose</span> <span class=o>:</span> <span class=k>public</span> <span class=n>mlir</span><span class=o>::</span><span class=n>OpRewritePattern</span><span class=o>&lt;</span><span class=n>TransposeOp</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>SimplifyRedundantTranspose</span><span class=p>(</span><span class=n>mlir</span><span class=o>::</span><span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=o>:</span> <span class=n>OpRewritePattern</span><span class=o>&lt;</span><span class=n>TransposeOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>context</span><span class=p>,</span> <span class=cm>/*benefit=*/</span><span class=mi>1</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=n>mlir</span><span class=o>::</span><span class=n>LogicalResult</span>
</span></span><span class=line><span class=cl>  <span class=n>matchAndRewrite</span><span class=p>(</span><span class=n>TransposeOp</span> <span class=n>op</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                  <span class=n>mlir</span><span class=o>::</span><span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span> <span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>mlir</span><span class=o>::</span><span class=n>Value</span> <span class=n>transposeInput</span> <span class=o>=</span> <span class=n>op</span><span class=p>.</span><span class=n>getOperand</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>TransposeOp</span> <span class=n>transposeInputOp</span> <span class=o>=</span> <span class=n>transposeInput</span><span class=p>.</span><span class=n>getDefiningOp</span><span class=o>&lt;</span><span class=n>TransposeOp</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>transposeInputOp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>      <span class=k>return</span> <span class=n>failure</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>rewriter</span><span class=p>.</span><span class=n>replaceOp</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=p>{</span><span class=n>transposeInputOp</span><span class=p>.</span><span class=n>getOperand</span><span class=p>()});</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=nf>success</span><span class=p>();</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>定义 <code>getCanonicalizationPatterns</code> 方法</li></ol><p>在第一步中指定 <code>let hasCanonicalizer = 1;</code> 就是在 tablegen 的生层文件中生成了 <code>getCanonicalizationPatterns</code> 方法的声明，需要由人工给出定义，并且在其中添加第二步中重写了 <code>matchAndRewrite</code> 方法的类</p><div class=highlight id=id-36><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>TransposeOp</span><span class=o>::</span><span class=n>getCanonicalizationPatterns</span><span class=p>(</span><span class=n>RewritePatternSet</span> <span class=o>&amp;</span><span class=n>results</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                              <span class=n>MLIRContext</span> <span class=o>*</span><span class=n>context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>results</span><span class=p>.</span><span class=n>add</span><span class=o>&lt;</span><span class=n>SimplifyRedundantTranspose</span><span class=o>&gt;</span><span class=p>(</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h4 id=易错点及总结>易错点及总结</h4><p>无论利用什么辅助工具，在最终编译出的代码中都一定包含了方法1-全人工实现所涉及到的全部组件，辅助工具只是帮助我们在背后实现了它们</p><p>pass 这里很容易产生一个思维误区，即实现一个 pass 必须包含全部流程。从<a href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/#backend target=_blank rel="external nofollow noopener noreferrer">graph_compiler backend 2.执行 pass pipeline</a>的函数调用栈中，我们可以看出 pass 的执行流程，function hook 紧跟着的是 <code>runOnOperation()</code>，然后是 <code>matchAndRewrite()</code>，实际上这里调用 <code>matchAndRewrite()</code> 并不是必须的流程，graph_compiler 的 matrix 部分涉及到的两个 pass：<code>RegisterAllocPass</code> 和 <code>CodeGenPass</code> 就并没有使用到 <code>matchAndRewrite()</code></p><h3 id=创建-opt>创建 opt</h3><p>分析到这里会给人一种迷惑，似乎我们已经实现了这个降级的过程。</p><p>但是仔细考虑一下，截止到目前我们都创建了什么？dialect, operation，operation重写规则 和 pass</p><p>而我们的目的是什么？将 mlir 转变为可以对接到 LLVM backend 的内容。</p><p>可以发现，我们目前创建的这些东西就像是原材料一样，我们需要一个媒介，将它们和 mlir 进行链接，实现内容转换，而 opt 起到的就是这种作用。简单来说，opt 就是利用已有的工作接口完成一个 lowering 的流程描述</p><p><strong>如何理解 hello-opt 这类工具？</strong></p><p>mlir 片段确实是摆在这里了，所需要的 Dialect 和 对应的 operation 也都写好了，但是问题是他们之间如何建立起联系来？</p><p>hello-opt 充当的就是这个桥梁作用，简单理解它可以将 mlir片段 作为输入，利用声明好的 Dialect 和 operation 对 mlir 进行一系列 lowering 和 transformation 操作，从而最终转化为 LLVM IR 或者其他什么格式，从而接入到 LLVM backend 中</p><hr><p>opt 类工具采用的一般的操作流程：</p><ol><li>向 contex 中 加载 dialect</li></ol><div class=highlight id=id-37><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=o>&gt;</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>使用 pass 完成 lowering 和 transformation</li></ol><div class=highlight id=id-38><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>PassManager</span> <span class=n>pm</span><span class=p>(</span><span class=o>&amp;</span><span class=n>context</span><span class=p>);;</span>
</span></span><span class=line><span class=cl><span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>compiler</span><span class=o>::</span><span class=n>createConvertGraphToMatrix</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>pm</span><span class=p>.</span><span class=n>run</span><span class=p>(</span><span class=n>module_</span><span class=p>.</span><span class=n>get</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><p>对于 mlir-hello 来说，lowering 和 transformation 是两个界限清晰的过程。它使用 <code>PassManager</code> 仅仅完成了 lowering 的过程，transformation 的过程是通过其他 llvm 接口来实现的。不过对于 graph_compiler 来说，pass 不仅完成了 lowering，也完成了 transformation 的过程</p><h3 id=cmakeliststxt解读>CMakeLists.txt解读</h3><p>&ndash; CMAKE_BINARY_DIR: 项目的 build 目录: /home/xxx/project/build</p><p>&ndash; LLVM_INCLUDE_DIRS: 采用的 llvm 下的两个和 llvm 相关的 include 路径: /home/xxx/llvm/llvm/include;/home/xxx/llvm/build/include</p><p>&ndash; MLIR_INCLUDE_DIRS: 采用的 llvm 下的两个和 mlir 相关的 include 路径: /home/xxx/llvm/mlir/include;/home/xxx/llvm/build/tools/mlir/include</p><p>&ndash; PROJECT_SOURCE_DIR: 项目根路径: /home/xxx/project</p><p>&ndash; PROJECT_BINARY_DIR: 项目 build 路径: /home/xxx/project/build</p><h3 id=疑惑>疑惑</h3><p>在 mlir-hello 的 LowerToAffine.cpp 中，存在一个如下的方法调用</p><div class=highlight id=id-39><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>rewriter</span><span class=p>.</span><span class=n>modifyOpInPlace</span><span class=p>(</span><span class=n>op</span><span class=p>,</span> <span class=p>[</span><span class=o>&amp;</span><span class=p>]</span> <span class=p>{</span> <span class=n>op</span><span class=o>-&gt;</span><span class=n>setOperands</span><span class=p>(</span><span class=n>adaptor</span><span class=p>.</span><span class=n>getOperands</span><span class=p>());</span> <span class=p>});</span></span></span></code></pre></td></tr></table></div></div><p>但是编译老是报错</p><blockquote><p>error: ‘class mlir::ConversionPatternRewriter’ has no member named ‘modifyOpInPlace’</p></blockquote><p>但是通过 clangd 又可以定位到此方法的位置，在 llvm 的 install 目录下，同时发现在源码中确实没有这一方法，这就非常神奇了</p><h2 id=buddy-mlir>buddy-mlir</h2><h3 id=introduction>introduction</h3><ol><li><p>同 MLIR 的关联：reuse the MLIR infrastructure and LLVM backend tools</p></li><li><p>MLIR 之外的特点：</p></li></ol><ul><li>optimization tool</li><li>auto-config mechanism</li></ul><p>Buddy-MLIR 包含一些基于 MLIR infrastructure 实现的算法，需要利用到 MLIR Dialect 和 Op</p><p>MLIR 作为一种基础设施，实际上是不去负责端到端的这个编译流程的，那么说上层应用（例如pytorch、tensorflow等）如何对接到下层形式各样的硬件上就是目前的难题，尤其是目前形式各样的异构芯片的出现更加剧了这种问题。</p><blockquote><p>关于不负责端到端的编译流程的具像化理解，从目前的使用和理解来看，MLIR 并没有提供前端，其只提供了和 MLIR 表达式相关的一些工具和一些原生的 Dialect，只用这些是不足以完成从上层应用到下层硬件之间的对接的，所以说其不负责端到端的编译流程。更多的感觉是提供了一种框架，给出了一种约束，开发者可以利用这种模式来实现各种各样的编译流程。</p></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403281051700.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>但是 Buddy-MLIR 对于解决这种问题提供了什么样的解决方案呢？从上图来看，如果说 MLIR 是一些积木的话，那么 Buddy-MLIR 的意图似乎是利用这些积木，搭建起一个城堡，通过为前中后端提供 Dialect，帮助上层的例如 pytorch 应用能够部署到底层具体的硬件上</p><p>但是我没太明白在 Buddy Compiler 的项目中插入如此多的 Example 是什么意思，感觉这些 Example 更多的应该是 MLIR 所提供的，用于展示其 Dialect 的用法，不知道放在这里和其本身的设计思想之间有什么关系。</p><blockquote><p>不过如果你看了代码，或者说<a href=https://buddy.isrc.ac.cn/ target=_blank rel="external nofollow noopener noreferrer">Buddy Compiler As A Service (Buddy-CAAS)</a>，你会发现 Buddy-MLIR 项目中给出的 IR Level Examples 其实就是 MLIR 原生提供的 Dialect 的使用示例，在项目中，对应着 <code>examples/MLIR*</code>这些目录。这些示例是通过 <code>mlir-opt</code>, <code>mlir-translate</code> 和 <code>mlir-cpu-runner</code> 可以直接 lowering、translation 以及 run 的。所以我理解就是首先通过这些示例让学习者可以更好地理解 MLIR 中各种概念的存在形式，所以入门 MLIR 时不妨直接从了解 MLIR 的原生 Dialect 入手，逐渐搞懂各种概念，然后再去了解如何自行创建 Dialect 或者 operation 等。官方教程从 Toy 的示例开始，直接就自定义 Dialect，确实让人很难理解各种模块存在的内在机理</p></blockquote><p>llvm-as 可以将 LLVM IR 转变为 LLVM IR bitcode</p><p>llc 可以将 LLVM IR bitcode 转变为 assembler source text, ASCII text</p><p>llc 也可以直接将 LLVM IR 转变为 assembler source text, ASCII text</p><p>但是并没有真正运行起来，不过就是说即便不考虑后续如何执行，翻译到 LLVM IR 这一层级也就 OK 了</p><h3 id=build>Build</h3><p>在第一步构建过程中遇到几个坑点：</p><ol><li><p>The target building platform of MLIR is uncompleted，because <a href=https://mlir.llvm.org/getting_started/ target=_blank rel="external nofollow noopener noreferrer">MLIR Getting Started</a> asks that we can use the build option <code>-DLLVM_TARGETS_TO_BUILD="Native;NVPTX;AMDGPU"</code>, but the buddy-mlir needs the <code>RISCV</code> platform data, so we need to recompile the MLIR</p></li><li><p>I learn about the process of building buddy-compiler needs the mlir compiling data from the option <code>-DMLIR_DIR=$PWD/../llvm/build/lib/cmake/mlir</code> and <code>-DLLVM_DIR=$PWD/../llvm/build/lib/cmake/llvm</code>, so I think a idea that create a soft link of llvm project for the buddy-compiler. But when I build the buddy-compiler, I get the error message that cmake cannot find some files about RISCV, until I get some tips from the slack</p></li></ol><p><a class=lightgallery href="https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png?size=large" data-thumbnail="https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png?size=small" data-sub-html="<h2>https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png</h2>"><img loading=lazy src=https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png srcset="https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png?size=small, https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png?size=medium 1.5x, https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png?size=large 2x" sizes=auto data-title=https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png data-alt=https://img2024.cnblogs.com/blog/1898659/202403/1898659-20240324100837179-389572672.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>执行之后就能够正常build了，但是里面不确定的因素有二，其一是 我手动创建软链接确实也起到了增加submodule的功能，因为执行 git submodule update &ndash;init 之后并没有重复 git clone llvm- project，但是不太清楚执行之后到底产生了什么其他的额外影响(主要怀疑会不会执行后修改了什么变量），使得 cmake 就能够找到相关文件了；其二是 submodule 并不仅仅只有 llvm 这一个，还存在另外一个，不确定是不是因为之前缺少这个子模块从而导致build失败（不过这一点是可以验证的，只需要注释掉这部分，只 git submodule llvm-project 那部分，查看是否可以完成 build 就可以，按理说应该不太行）</p><h3 id=structure>Structure</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403241200921.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>目前的困惑在于 buddy-mlir 是否可以看为是对 mlir 的一种封装，如果是的话，封装了啥，如果不是，那它相较于 mlir 又有何区别或者说设计的意义在哪里</p><h3 id=source-code-structure>source code structure</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403251627454.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=understanding>understanding</h3><p>Bud Dialect 展示了自定义 Dialect，并降级到 MLIR提供的基础设施上（从代码来看就是一些 llvm 项目下的 Dialect）</p><p>include目录下包含了.td，lib下的 conversion 中实现了降级的代码</p><p>pass 机制，pattern rewrite机制，interface</p><p>目前粗浅的理解就是 pattern rewrite 就是所谓表达式优化和降级的过程（即无论是表达式优化还是降级，都是通过rewrite实现的），这个过程中使用到的东西从概念上来讲就是各种 pass，而各种 pass 在实际命名上就是各种 dialect。而operation的概念在整个流程中是一直存在的。每一个 dialect 或许就可以看为是一个层次，每个层次下都有不同抽象级别的，与当前层次对应的 operation 表述</p><p>（这篇文章<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjY4NTk0NQ==&amp;mid=2247499540&amp;idx=1&amp;sn=c88146d7f00d83d8671fe6214d4416d4&amp;chksm=9f834582a8f4cc94ffda8d2b6b217d02ac0e7434579a8c3282813c6bfe89ff9644744bc2e968&amp;scene=178&amp;cur_album_id=2099721001268740096#rd" target=_blank rel="external nofollow noopener noreferrer">如何在MLIR里面写Pass</a></p><p>从 examples 下的 IR Level Examples 了解到了通过 MLIR tool chain 可以直接执行 MLIR 表达式</p><p>才领悟到我们似乎可以将 MLIR 当作一门普通的语言，其同样具备相关的<a href=https://mlir.llvm.org/docs/LangRef/ target=_blank rel="external nofollow noopener noreferrer">语法</a>，我们可以借助它的语法实现一些算法，但是带来的疑问是如果仅仅通过 MLIR 就能够完成所有操作，那我们为什么不直接写 MLIR 了，而是还需要去写 C++ 代码，那些 operation 又要起到什么作用。</p><p>关于这个疑问，我们大概可以从 <code>mlir-opt --help</code> 命令的输出结果中得到一点启发，其中 <code>--convert-vector-to-llvm</code> 选项的内容是</p><blockquote><p>&ndash;convert-vector-to-llvm - Lower the operations from the vector dialect into the LLVM dialect</p></blockquote><p>注意上面提到两个 dialect：vector dialect 和 LLVM dialect</p><p>同时在命令输出中还包含了以下内容：</p><blockquote><p>Available Dialects: acc, affine, amdgpu, amx, arith, arm_neon, arm_sme, arm_sve, async, bufferization, builtin, cf, complex, dlti, emitc, func, gpu, index, irdl, linalg, llvm, math, memref, mesh, ml_program, mpi, nvgpu, nvvm, omp, pdl, pdl_interp, quant, rocdl, scf, shape, sparse_tensor, spirv, tensor, test, test_dyn, tosa, transform, ub, vector, x86vector, xegpu</p></blockquote><p>那么也就是说上面这些以及<code>mlir-opt</code>命令能够携带的参数中使用到的dialect，实际都是 MLIR 项目中自带的一些 dialect，或者说是原生的</p><p>但是，在实际的应用场景下，我们所需要用到的 dialect 并不仅仅是这些，我们往往需要用到其他类型的，结合实际场景的，所以这就是我们为什么需要自己编写 dialect 的原因</p><p>所以首先通过直接借用 mlir 的相关工具和原生的 dialect，直接编写 MLIR 代码，能够帮助我们了解</p><p>Buddy-MLIR 提供的 IR Level Examples，主要包含三部分：</p><ul><li>low</li><li>translate</li><li>run</li></ul><p>在降级环节(low)中，始终都是 MLIR，即便是 <code>mlir-opt</code> 应用了例如 <code>--convert-func-to-llvm</code> 这类选项，但是也只是说用 llvm dialect 进行了降级，但是其属于 MLIR 的本质并没有改变，证据可见</p><blockquote><p>&ndash;convert-func-to-llvm - Convert from the Func dialect to the LLVM dialect</p></blockquote><p>然而在翻译环节(translate)，注意是translate而非transformation，才是真正完成从 MLIR 到 其他 IR 的转变，证据可见 <code>mlir-translate</code> 采用的选项 <code>--mlir-to-llvmir</code></p><blockquote><p>&ndash;mlir-to-llvmir - Translate MLIR to LLVMIR</p></blockquote><p>而在运行环节，由于 <code>mlir-cpu-runner</code> JIT 实际运行的是 MLIR，所以其只能处理</p><p>这里给出的这些 example，利用到的 Dialect 都是 LLVM 项目，准确地说是 MLIR 中预置的，所以可以通过各种 mlir 工具来实现降级和翻译。如果想要实现自定义的Dialect，那就和创建一个例如 compiler 的项目相同了。</p><p><strong>Buddy-MLIR 项目框架重点</strong></p><ol><li><p><code>include</code>下的td文件负责给出 Dialect 和 Operation 的说明，后续在编译过程中通过 <code>llvm-tblgen</code> 生成所需的各种文件</p></li><li><p><code>lib</code> 下的 <code>Conversion</code> 负责给出 lowering pipeline，将 custom dialect&rsquo;s operation lowering 到 MLIR&rsquo;s standard dialect，从而将 custom dialect 接入 MLIR ecosystem</p></li><li><p><code>example</code> 下给出的实际就是如何使用 buddy-mlir 的示例。Buddy-MLIR 为使用者在<code>frontend</code>中提供了上层应用和 buddy-mlir 进行交互的接口数据结构，然后Buddy-MLIR 应用了MLIR 提供的一个 C/C++ 的前端接口功能，完成了端到端的应用构建</p></li></ol><blockquote><p>不过有一个疑问是，buddy-mlir 向上层提供接口的方式是提供了一个 Memref 数据结构，难道通过这一个数据结构就能够完成</p></blockquote><p>简单来说就是 buddy-mlir 向上层提供了C函数接口，上层C应用只需要直接调用函数即可（不过在 <code>ConvOpt/edge-detection.cpp</code> 的示例中使用到了<code>_mlir_ciface_conv_2d</code>函数，但是此函数并没有找到相关定义，不过它利用到了buddy-opt以及llvm的相关工具，可能和它们有关，具体的实现机制还有待商榷）。所以说项目需要做的就是提供好相关 dialect、operation，为上层应用提供好调用接口</p><p>从 Buddy-MLIR 提供的 BudDialect example 就可以看出，在 <code>examples/BudDialect</code> 提供的是一些 mlir 文件，其中用到的一些 mlir 语法实际上都是属于 BudDialect 的。但是通过 <code>buddy-opt</code> 就可以降级到 MLIR，这里涉及到两个问题：</p><ol><li><code>buddy-opt</code> 哪里来？</li><li>为什么 <code>buddy-opt</code> 可以把自定义的 BudDialect 降级到 MLIR？</li></ol><p><code>buddy-opt</code> 是在 tools 中实现的一个工具，我们可以先简单认为它利用了在 midend 中给出的和 BudDialect 相关的内容，这其中就包含不同 dialect 转换所需要用到的内容。也就是说我们只需要实现了 dialect 体系中的相关内容，通过利用 MLIR 提供的接口就可以简单创建出相关的工具，从而实现 lowering 或者 transformation 的过程</p><p>对于 BudDialect 的构建过程，理论上在不添加 <code>buddy-opt</code> 的情况下，虽然什么都做不了，但是也应当可以正常通过编译，只是说没有 <code>buddy-opt</code> 确实没办法做出什么效果。然后再加入 <code>buddy-opt</code> 完成编译。</p><h3 id=examples-introductoin-examples-introduction>Examples Introductoin <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></h3><h2 id=reference>Reference</h2><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://gaohongy.github.io/blog/posts/compile-link/c-c++-compile-link/#llvm target=_blank rel="external nofollow noopener noreferrer">LLVM</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://arxiv.org/abs/2108.13191 target=_blank rel="external nofollow noopener noreferrer">High Performance GPU Code Generation for Matrix-Matrix Multiplication using MLIR: Some Early Results</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href=https://zhuanlan.zhihu.com/p/102565792 target=_blank rel="external nofollow noopener noreferrer">MLIR的生产线</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p><a href=https://github.com/buddy-compiler/buddy-mlir/blob/main/examples/README.md target=_blank rel="external nofollow noopener noreferrer">buddy-mlir Examples</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-05-23 23:13:18">更新于 2024-05-23&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=https://github.com/gaohongy/blog/edit/main/content/posts/Graph-Computing/MLIR.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/graph-computing/legion-source-code-analysis/ class=post-nav-item rel=prev title="Legion Source Code Analysis"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Legion Source Code Analysis</a>
<a href=/blog/posts/graph-computing/graph-compiler/ class=post-nav-item rel=next title="Graph Compiler">Graph Compiler<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/katex/katex.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/copy-tex.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/blog/js/theme.min.js defer></script></body></html>