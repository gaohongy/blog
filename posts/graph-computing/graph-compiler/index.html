<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>Graph Compiler - </title><meta name=author content="ghy"><meta name=author-link content="https://github.com/gaohongy"><meta name=description content="整体理解 从关键技术那张图上，能够了解到CGA_Framework就是那个统一编程框架 王老师说我们做图学习还有编译的部分 我目前对于统一编程框架"><meta name=keywords content='Hugo,FixIt'><meta itemprop=name content="Graph Compiler"><meta itemprop=description content="整体理解 从关键技术那张图上，能够了解到CGA_Framework就是那个统一编程框架 王老师说我们做图学习还有编译的部分 我目前对于统一编程框架"><meta itemprop=datePublished content="2024-03-07T21:26:29+08:00"><meta itemprop=dateModified content="2024-05-08T17:26:33+08:00"><meta itemprop=wordCount content="12336"><meta itemprop=keywords content="Graph-Computing"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/"><meta property="og:title" content="Graph Compiler"><meta property="og:description" content="整体理解 从关键技术那张图上，能够了解到CGA_Framework就是那个统一编程框架 王老师说我们做图学习还有编译的部分 我目前对于统一编程框架"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-07T21:26:29+08:00"><meta property="article:modified_time" content="2024-05-08T17:26:33+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Graph Compiler"><meta name=twitter:description content="整体理解 从关键技术那张图上，能够了解到CGA_Framework就是那个统一编程框架 王老师说我们做图学习还有编译的部分 我目前对于统一编程框架"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/><link rel=prev href=https://gaohongy.github.io/blog/posts/graph-computing/mlir/><link rel=next href=https://gaohongy.github.io/blog/posts/hpc/memory-alignment/><link rel=stylesheet href=/blog/css/style.min.css><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blog/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Graph Compiler","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/graph-computing\/graph-compiler\/"},"genre":"posts","wordcount":12336,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/graph-computing\/graph-compiler\/","datePublished":"2024-03-07T21:26:29+08:00","dateModified":"2024-05-08T17:26:33+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ghy"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item><a href=/blog/ title>主页</a></li><li class=breadcrumb-item><a href=/blog/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>Graph Compiler</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>Graph Compiler</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/gaohongy title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202205161528792.jpg data-title=ghy data-alt=ghy class=avatar style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;ghy</a></span>
<span class=post-category>收录于 <a href=/blog/categories/graph-computing/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Graph-Computing</a></span></div><div class=post-meta-line><span title="发布于 2024-03-07 21:26:29"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2024-03-07>2024-03-07</time></span>&nbsp;<span title="更新于 2024-05-08 17:26:33"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2024-05-08>2024-05-08</time></span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#整体理解>整体理解</a><ul><li><a href=#疑惑>疑惑</a></li></ul></li><li><a href=#cga_framework>CGA_Framework</a></li><li><a href=#graph-algorithm-compiler-for-asichttpszhwikipediaorgwikie789b9e6ae8ae68789e794a8e7a98de9ab94e99bbbe8b7af>graph algorithm compiler for <a href=https://zh.wikipedia.org/wiki/%E7%89%B9%E6%AE%8A%E6%87%89%E7%94%A8%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF>asic</a></a><ul><li><a href=#目录结构分析>目录结构分析</a></li><li><a href=#graph-dialect-op-attr-type-分析>graph dialect-op-attr-type 分析</a></li><li><a href=#matrix-dialect-op-attr-type-分析>matrix dialect-op-attr-type 分析</a></li><li><a href=#sssp-转-matrix-运算方法>sssp 转 matrix 运算方法</a></li><li><a href=#执行流程分析>执行流程分析</a><ul><li><a href=#frontend>frontend</a><ul><li><a href=#mlirgenpy-文件内容>MLIRGen.py 文件内容</a></li><li><a href=#python-转-mlir-流程分析>python 转 MLIR 流程分析</a></li></ul></li><li><a href=#backend>backend</a><ul><li><a href=#graphtomatrix>GraphToMatrix</a></li><li><a href=#codegen>CodeGen</a></li></ul></li><li><a href=#run>run</a></li></ul></li><li><a href=#疑惑-1>疑惑</a></li></ul></li><li><a href=#polygeist>Polygeist</a></li><li><a href=#work-plan>work plan</a><ul><li><a href=#2024411>2024/4/11</a></li><li><a href=#2024428>2024/4/28</a></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></div><div class=content id=content data-end-flag=EOF><h2 id=整体理解>整体理解</h2><p>从关键技术那张图上，能够了解到CGA_Framework就是那个统一编程框架</p><p>王老师说我们做图学习还有编译的部分</p><p>我目前对于统一编程框架的理解是：目前项目中的include下面的各种.h文件提供的就是C++接口的功能，而apps则是使用这些接口的示例程序，apps就应当是等价于实际使用这个统一编程框架的用户所编写的代码</p><p>统一编程框架位于框架层，要注意到其上还存在一个应用层，应用层和框架层的接口应当是 GraphScope 和 DGL。也就是说用户仍然是利用GraphScope 和 DGL，来完成图计算、图挖掘和图学习的任务，但是开发者需要提供从GraphScope和DGL到统一编程框架的转换机制（<strong>对应着任务中的“用户透明的代码自动转换机制"</strong>)，目前猜测自动代码生成技术就是来负责实现这种转换的</p><p>这种转换应该是在存在着统一编程框架和Graph
现在涉及到几个关键词，自动代码生成，领域特定语言DSL，中间表达IR</p><p>从领域特定语言的作用机制来说，库从某种意义上来说本身就是一种DSL，如何从DSL转到另一种语言，这里如果借助IR，似乎再通过llvm IR以及llvm backend，那就直接变成了可执行程序，所以没有想到如何实现这种语言的转换，所以猜测的可能是通过automatic code generation，但是还并不了解这个自动代码生成的机制，不过用户透明的代码自动转换机制肯定是通过某种机制来实现的</p><p>编译层的作用可能是实现高层次代码转换为中间表达IR，逐层下降逐层优化</p><p>根据项目结构图，我对于目前任务的理解是，有三项任务，一是实现统一编程框架、二是实现dgl到统一编程框架的用户无感转换、三是实现统一编程框架的编译层。
对于前两项任务的理解，在项目图中，图学习部分在应用层和框架层之间的联系有两点，一是直接利用统一编程框架，二是首先利用dgl，然后dgl转换到统一编程框架。</p><p>所以说我的疑问就是：</p><ol><li><p>在统一编程框架中，和图学习相关的组件应当有哪些，采用什么样的项目模式（对图学习本身就不太清楚，都还不知道图学习都包含什么部分）</p></li><li><p>dgl到统一编程框架的用户无感转换，这个转换依据的是什么，或者说这种转换机制是什么</p></li><li><p>从框架层到编译层，MLIR是如何发挥的作用，编译层的设计目标是什么</p></li><li><p>在 Toy Tutorial Chapter 3 给出了 基于DRR模块实现 transformation，在 td中声明 Pat 的子类。但是/Users/gaohongyu/Graduate/Graph-Calculation/project/compiler/compiler/include/compiler/Dialect/Graph/Transforms/Passes.td 都是继承 Pass 的子类，暂时还不清楚继承 Pass 的子类作用</p></li></ol><p>两层IR表示 Graph IR 和 Matrix IR，对应 IR 分别在 <code>include/compiler/Dialect/Graph</code> 和 <code>include/compiler/Dialect/Matrix</code></p><ol><li>完整表示 IR</li><li>自动编译优化（表达式优化）</li><li>图-矩阵转换（lowering），最后要转到 LLVM IR</li></ol><p><a href=https://www.mubu.com/doc/CuigbBIo7Q target=_blank rel="external nofollow noopener noreferrer">GraphOps.td 结构</a></p><p>首先说，lib 存放的就是对各种东西的定义，都是各种实现。
<code>lib/Dialect/Interfaces/</code> 这里虽然说给起的名字是 interface，但是目前的代码中并没有使用到 MLIR interface 的代码，以 For.cpp 为例，
主要内就 2 项：</p><ol><li>对于 operation of For 的定义</li><li>表达式优化，重写，代码层面即为 继承 <code>OpRewritePattern</code> 类的子类实现</li></ol><p>看代码过程中遇到一个新的概念 SSA，Static Single Assignment，即静态单变量。编译器会将同名变量分解为两个变量，便于进行各类优化</p><p>2024/03/21组会疑问解答；</p><ol><li>关于 统一编程框架 和 编译层 之间的联动关系，是谁决定谁，可以把编译层那个东西看为是一个第三方的库，为统一编程框架提供服务</li><li>之前疑问的是编译层需要对图操作进行描述，怎么知道图操作有什么，或者说编译层都需要写哪些东西？这个应该要和上一个问题联系一下，既然是实现第三方库，那么所实现的操作就应当是尽可能全面的，不是说统一编程框架需要什么编译层提供什么，而是说统一编程框架要跟着编译层走，所以我理解着就得尽可能多想一下有哪些需要的操作</li></ol><h3 id=疑惑>疑惑</h3><ol><li>pybind 用在了哪里？目前的 CGA_Framework 中并没有涉及到，而且目前的 CGA_Framework 并没有包含框架图中所提及的 C++接口</li></ol><p>按照我的理解，对于应用层而言，CGA_Framework 暴露的是 python，CGA 框架本身使用 C++ 实现，然后通过 pybind 向应用层提供 python module，就像是下面的简单示例 <sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// example.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;pybind11/pybind11.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>add</span><span class=p>(</span><span class=kt>int</span> <span class=n>i</span><span class=p>,</span> <span class=kt>int</span> <span class=n>j</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>i</span> <span class=o>+</span> <span class=n>j</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>PYBIND11_MODULE</span><span class=p>(</span><span class=n>example</span><span class=p>,</span> <span class=n>m</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>doc</span><span class=p>()</span> <span class=o>=</span> <span class=s>&#34;pybind11 example plugin&#34;</span><span class=p>;</span> <span class=c1>// optional module docstring
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>m</span><span class=p>.</span><span class=n>def</span><span class=p>(</span><span class=s>&#34;add&#34;</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>add</span><span class=p>,</span> <span class=s>&#34;A function that adds two numbers&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>对于上述 C++ 代码，采用如下编译命令</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>c++ -O3 -Wall -shared -std<span class=o>=</span>c++11 -fPIC <span class=k>$(</span>python3 -m pybind11 --includes<span class=k>)</span> example.cpp -o example<span class=k>$(</span>python3-config --extension-suffix<span class=k>)</span></span></span></code></pre></td></tr></table></div></div><p>然后会生成一个动态链接库 example.cpython-39-x86_64-linux-gnu.so</p><p>当以下 python 源程序同动态链接库处于同一目录时，即可执行</p><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># main.py</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>example</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nb>print</span><span class=p>(</span><span class=n>example</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>))</span></span></span></code></pre></td></tr></table></div></div><p>将上述简单示例对应到当前系统下，按照我的理解，CGA_Framework 充当的就是 example.cpp 的角色，main.py 即应用层实现的应用，同时也是编译层所面对的源程序。不过在现有代码中，无论是应用层还是编译层都不符合这种实现框架。</p><h2 id=cga_framework>CGA_Framework</h2><p>Graph Generalization:</p><table><thead><tr><th>组件</th><th>包含</th><th>功能</th></tr></thead><tbody><tr><td>gc(graph computing)</td><td>GcComp(graph convolution component), GcProg(graph convolution program), GraphC(graph convolution)</td><td></td></tr><tr><td>gnn(graph neural network)</td><td></td><td>图神经网络</td></tr><tr><td>gpm(graph partitioning method)</td><td></td><td>图划分</td></tr><tr><td>mat(matrix)</td><td></td><td>各种矩阵格式表示以及矩阵运算</td></tr><tr><td>utils</td><td></td><td>小工具</td></tr><tr><td>vec</td><td></td><td>像是容器类，会管理实际的数据</td></tr><tr><td>converter.h</td><td>-</td><td>数据加载</td></tr></tbody></table><p>GNN:</p><p>共给出了3种图神经网络模型：</p><ul><li>GAT（Graph Attention Network）</li><li>GCN（Graph Convolutional Network）：</li><li>GIN（Graph Isomorphism Network）</li></ul><p>在具体的实现上，三种神经网络模型都实现了2个类，分别继承 GnnComp 和 GnnProg</p><p>SSA 意为静态单赋值（Static Single Assignment）。SSA 是一种中间表示（IR）的形式，常用于编译器优化和静态分析中。在 SSA 中，每个变量在其定义处只能被赋值一次，并且每个变量必须在使用之前被明确地赋值。这意味着在 SSA 中，变量的赋值是静态的，因此称为“静态单赋值”。</p><h2 id=graph-algorithm-compiler-for-asichttpszhwikipediaorgwikie789b9e6ae8ae68789e794a8e7a98de9ab94e99bbbe8b7af>graph algorithm compiler for <a href=https://zh.wikipedia.org/wiki/%E7%89%B9%E6%AE%8A%E6%87%89%E7%94%A8%E7%A9%8D%E9%AB%94%E9%9B%BB%E8%B7%AF target=_blank rel="external nofollow noopener noreferrer">asic</a></h2><p>项目编译有个坑点，在各种依赖项都准备好之后，编译 graph_compiler 仍然会报下面的错误，会发现问题出在 <code>graph_compiler/python/CMakeLists.txt</code>中</p><p>其中的语句<code>set(Python3_EXECUTABLE "")</code>这里直接写死了 python3 的路径，所以怎么都找不到</p><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>CMake Error at /home/hongyu_gao/cmake-3.27.2-linux-x86_64/share/cmake-3.27/Modules/FindPackageHandleStandardArgs.cmake:230 (message):
</span></span><span class=line><span class=cl>  Could NOT find Python3 (missing: Python3_INCLUDE_DIRS
</span></span><span class=line><span class=cl>  Python3_NumPy_INCLUDE_DIRS Interpreter Development.Module NumPy)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      Reason given by package: 
</span></span><span class=line><span class=cl>          Interpreter: Cannot run the interpreter &#34;/home/hongyu_gao/anaconda3/envs/mlir/bin/python&#34;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Call Stack (most recent call first):
</span></span><span class=line><span class=cl>  /home/hongyu_gao/cmake-3.27.2-linux-x86_64/share/cmake-3.27/Modules/FindPackageHandleStandardArgs.cmake:600 (_FPHSA_FAILURE_MESSAGE)
</span></span><span class=line><span class=cl>  /home/hongyu_gao/cmake-3.27.2-linux-x86_64/share/cmake-3.27/Modules/FindPython/Support.cmake:3824 (find_package_handle_standard_args)
</span></span><span class=line><span class=cl>  /home/hongyu_gao/cmake-3.27.2-linux-x86_64/share/cmake-3.27/Modules/FindPython3.cmake:545 (include)
</span></span><span class=line><span class=cl>  /home/hongyu_gao/llvm-install/lib/cmake/mlir/MLIRDetectPythonEnv.cmake:21 (find_package)
</span></span><span class=line><span class=cl>  python/CMakeLists.txt:6 (mlir_configure_python_dev_packages)</span></span></code></pre></td></tr></table></div></div><p>2024/04/17 的一次编译突然发现出现新的错误了，不奇怪为什么会有这个错误，奇怪的是既然错误存在为什么之前编译都是正常的，这次就出问题了</p><p>问题出自 graph_compiler/include/compiler/Builder/DSAConfig.h 其中的 <code>typedef uint32_t u32;</code>，编译报错</p><blockquote><p>unknown type name &lsquo;uint32_t&rsquo;</p></blockquote><p>实际添加上 <code>&lt;cstdint></code> 即可</p><h3 id=目录结构分析>目录结构分析</h3><ol><li>test</li></ol><p>cga: construct, gather, apply, 一种计算模式，能够将图算法转变为矩阵运算</p><ul><li>bfs.py: 广度优先搜索</li><li>CGAConverter.py: 与计算图算法相关的转换器或者工具函数</li><li>gat.py: Graph Attention Network, 图注意力网络</li><li>gcn.py: Graph Convolutional Network, 图卷积网络</li><li>pagerank.py: 计算图中结点的重要性或者网络中的页面排名</li><li>sssp.py: Single-Source Shortest Path, 单源最短路径</li></ul><hr><p><a href=https://graphscope.io/ target=_blank rel="external nofollow noopener noreferrer">graphscope</a>: 一站式图计算平台</p><hr><p>从系统架构图来看，test 中应当还包含 <a href=https://www.dgl.ai/ target=_blank rel="external nofollow noopener noreferrer">DGL(DEEP GRAPH LIBRARY)</a>(Deep Learning on Graphs)的内容</p><ol start=2><li>include/compiler/Conversion + lib/Conversion</li></ol><p>graph dialect 转为 matrix dialct 所需要的内容（声明 + 实现）</p><ul><li><p>Conversion.h 负责声明 pass 的 function hook，对应 mlir-hello 创建 pass 的第 1 步</p></li><li><p>Passes.td 声明应用 lowering 的类，对应 mlir-hello 创建 pass 的第 2.2 步的声明 (Passes.h 负责引入 Passes.td 生成的头文件内容，可以理解为目录下的 Passes.h + Passes.td => 最终的 Passes.h)</p></li><li><p>GraphToMatrixPass.cpp 定义 lowering，给出 应用 lowering 的类 的实现以及完成 pass 的 function hook，对应 mlir-hello 的 2.1，2.2中的实现 和 2.3</p></li></ul><ol start=3><li>include/compiler/Builder + lib/Builder</li></ol><ul><li>DSAConfig.h: 模拟器参数配置信息</li><li>Instruction.h：类汇编指令类，包含多种构造函数</li><li>InstrBuilder.h / InstrBuilder.cpp: 构造指令，目前似乎只用到了其中的 <code>store()</code> 将生成的类汇编指令输出到文件中</li><li>RegisterAllocator.h: 暂时还没有涉及到</li></ul><ol start=4><li>operation interface 结构</li></ol><p>interface 本质上来说属于通用接口，并不独属于某个 operation，所以 td 声明是独立于任何 dialect 的，位于 include/Interfaces + lib/Interfaces。</p><p>当某个具体的 dialect 所具备的 operation 需要使用某个 operation时，那么由此 dialect 单独实现 interface 绑定的 function。例如 matrix 的 operation Matrix_GraphExerConfigOp 绑定了接口 CodeGenInterface，而 CodeGenInterface 绑定的 方法 是 emit_Instr，那么在 lib/Dialect/Matrix/Interfaces/GraphExerConfigOp.cpp 中需要给出 emit_Instr 的具体实现</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=graph-dialect-op-attr-type-分析>graph dialect-op-attr-type 分析</h3><ol><li><p>dialect 这是最基本的内容，就无需多言</p></li><li><p>Graph Attributes</p></li></ol><p>目前对于 MLIR 中的 attribute 机制不是很了解，目前能够从代码中很明显能够看出的内容就是：</p><p>创建 attribute 和创建 operation 一样，都需要创建一个 基类，然后在创建具体的 attribute 时继承此基类</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>class Graph_Attr&lt;string attrName, string attrMnemonic, list&lt;Trait&gt; traits = []&gt;
</span></span><span class=line><span class=cl>    : AttrDef&lt;Graph_Dialect, attrName, traits&gt; {
</span></span><span class=line><span class=cl>  let mnemonic = attrMnemonic;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>现在代码中包含的具体 attr 包含以下几类：</p><ul><li>Graph_ConstructAttr</li><li>Graph_GatherAttr</li><li>Graph_ApplyAttr</li><li>Graph_CGAComputeAttr</li></ul><blockquote><p>实际在上述内容之外，还有一个名叫 <code>AnyStrAttrOf</code> 的内容，目前还不太清楚其作用</p></blockquote><ol start=3><li>Graph Types</li></ol><p>这个内容暂时不太理解，先过</p><ol start=4><li>Graph Op</li></ol><ul><li>None</li><li>loadGraph</li><li>loadPattern</li><li>loadWeight</li><li>loadWeight</li><li>loadVertexProp</li></ul><ol start=5><li>CGA Op</li></ol><ul><li>gc</li><li>GnnConv</li><li>GPM（Graph Partitioning Method， 图分割方法）</li></ul><ol start=6><li>Custom Operator Op</li></ol><ul><li>tensor_constant</li><li>struct_access</li></ul><ol start=7><li>GNN Op</li></ol><ul><li>linear</li><li>LeakyRelu</li><li>Concat</li><li>Relu</li><li>Softmax</li><li>WeightedSum</li><li>TensorElementFieldDetach</li></ul><h3 id=matrix-dialect-op-attr-type-分析>matrix dialect-op-attr-type 分析</h3><ol><li>matrix operation</li></ol><ul><li>GConfig</li><li>SExpandV</li><li>graphExerRun</li><li>QPUSHV</li><li>QFork</li><li>QLoad</li><li>GPush</li><li>GStart</li><li>Gwait</li></ul><ol start=2><li>matrix type</li></ol><ul><li>AnyTensorOrNone</li><li>AnyScalar</li><li>Matrix_Queue</li></ul><ol start=3><li>matrix attribute</li></ol><ul><li>TraversalDirectionMode (tr_dirc_mode)</li><li>OutputToDstBufferMode (dst_Buff_mode)</li><li>EdgeFIFOMode (edge_fifo_mode)</li><li>MulALUMode (mul_alu_mode)</li><li>AddALUMode (add_alu_mode)</li></ul><h3 id=sssp-转-matrix-运算方法>sssp 转 matrix 运算方法</h3><p>通过消息传递的方式实现</p><h3 id=执行流程分析>执行流程分析</h3><p>graph_compiler 的源代码位于 <code>tools/main.cpp</code></p><p>其执行流程包括 3 个步骤：</p><ol><li><p>frontend: 源程序 -> AST抽象语法树 -> 未经 lowering 和 transformation 的 MLIR，通过 MLIRGen.py 实现，将 .py 生成 out.mlir</p></li><li><p>backend: 未经 lowering 和 transformation 的 MLIR -> 经过 lowering 和 transformation 的 MLIR -> 汇编代码，通过 asm_generator 实现，将 out.mlir 生成 out.asm</p></li><li><p>run: 汇编代码 -> 执行，通过 硬件模拟器 实现，执行 out.asm</p></li></ol><blockquote><p>关于 frontend 和 backend 的划分方式，与下图所展示的编译原理中的阶段划分方式相同。而当前场景下的中间代码指的就是 MLIR</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403122106578.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p></blockquote><h4 id=frontend>frontend</h4><p>此阶段运用了 <code>python/transform/MLIRGen.py</code> 将 python 代码解析为 MLIR, 生成的结果位于 out.mlir</p><p>具体的执行流程为：</p><ol><li><code>mlir_gen()</code> 通过 python 提供的 ast 模块 解析了 待执行的 python 文件 <code>test/dsl/test_dsl.py</code>，获得了抽象语法树</li><li>通过 <code>DSLtoMLIRConverter()</code> 将抽象语法树 解析为 MLIR（在此环节只使用到了 Graph Dialect)，它的具体实现主要就是对<code>__init__()</code>下的各个字段通过后续给出的各种<code>convert()</code>的结果进行赋值</li><li>将解析得到的 使用了 Graph Dialect 的 MLIR 表达式 写入文件 out.mlir</li></ol><p>因为现在还属于测试阶段，底层硬件还没有提供，所以运行采用的是模拟器的方式。那么无论是 backend 还是 run 实际上是怎么实现的似乎并不重要。</p><p>同时在这个示例中，抽象语法树 到 MLIR表达式 的生成都是由 python 完成的，那自行创建的那些 Dialect，那些 C++ 代码又该如何发挥作用？</p><p>C++ 代码发挥作用的方式就是通过 <a href=https://gaohongy.github.io/blog/posts/graph-computing/mlir/#mlir-python-bindings target=_blank rel="external nofollow noopener noreferrer">MLIR Python Bindings</a> 供给 python 实现的 MLIRGen 模块使用。</p><p>其实我觉得目前的疑问底层的核心在于两点：</p><ul><li><p>上层应用到底是什么样的存在形式，编译层又该以何种方式为上层提供支持（是提供一些C头文件或者库供应用层使用，还是说应用层正常使用 python 编写算法，然后编译层提供一些工具来完成编译？）</p></li><li><p>编译层的编译结果是什么，似乎需要转到算子层面（这和目前的测试范例确实不太符合）</p></li></ul><h5 id=mlirgenpy-文件内容>MLIRGen.py 文件内容</h5><p>对于 MLIRGen.py 文件，整体可以划分为 3 部分</p><ol><li>程序入口</li></ol><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>parser</span> <span class=o>=</span> <span class=n>argparse</span><span class=o>.</span><span class=n>ArgumentParser</span><span class=p>(</span><span class=n>description</span><span class=o>=</span><span class=s1>&#39;Convert DSL to MLIR.&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>parser</span><span class=o>.</span><span class=n>add_argument</span><span class=p>(</span><span class=s1>&#39;test_dsl_file&#39;</span><span class=p>,</span> <span class=nb>type</span><span class=o>=</span><span class=nb>str</span><span class=p>,</span> <span class=n>help</span><span class=o>=</span><span class=s1>&#39;The path to the test DSL file&#39;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>args</span> <span class=o>=</span> <span class=n>parser</span><span class=o>.</span><span class=n>parse_args</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mlir_gen</span><span class=p>(</span><span class=n>args</span><span class=o>.</span><span class=n>test_dsl_file</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>全局函数</li></ol><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>def</span> <span class=nf>add_parent_attr</span><span class=p>(</span><span class=n>node</span><span class=p>,</span> <span class=n>parent</span><span class=o>=</span><span class=kc>None</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>collect_function_defs</span><span class=p>(</span><span class=n>tree</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=nb>dict</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>mlir_gen</span><span class=p>(</span><span class=n>test_dsl_file</span><span class=p>:</span> <span class=nb>str</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><ol start=3><li>类</li></ol><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=k>class</span> <span class=nc>DSLtoMLIRConverter</span><span class=p>(</span><span class=n>ast</span><span class=o>.</span><span class=n>NodeVisitor</span><span class=p>):</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>BuiltinGatherMultOps</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>BuiltinGatherAddOps</span>
</span></span><span class=line><span class=cl>  <span class=k>class</span> <span class=nc>BuiltinApplyOps</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=fm>__init__</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>module</span> <span class=p>:</span> <span class=n>ir</span><span class=o>.</span><span class=n>Module</span><span class=p>,</span> <span class=n>ctx</span> <span class=p>:</span> <span class=n>ir</span><span class=o>.</span><span class=n>Context</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_factory</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>preprocess</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ast_root</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>Module</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>construct_convert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>gather_mult_convert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>gather_add_convert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>apply_convert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>ast_root</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_main_func</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>:</span><span class=n>ast</span><span class=o>.</span><span class=n>FunctionDef</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_Return</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_Assign</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span><span class=p>:</span><span class=n>ast</span><span class=o>.</span><span class=n>Assign</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_Constant</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>Constant</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_BinOp</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>BinOp</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>convert_Call</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=n>node</span> <span class=p>:</span> <span class=n>ast</span><span class=o>.</span><span class=n>Call</span><span class=p>)</span></span></span></code></pre></td></tr></table></div></div><h5 id=python-转-mlir-流程分析>python 转 MLIR 流程分析</h5><p>与 MLIR 的 lowering 类似，都会存在一个 module 的变量，此变量最后的内容为源代码生成的 MLIR。该变量的创建利用到了 MLIR 提供的 python 库 mlir.ir</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202405071121649.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>从 <code>gather_mult_convert()</code> 的实现可以看出，目前已经考虑了 add_weight_，即能够解析 sssp.py 文件</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261451914.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h4 id=backend>backend</h4><p>此阶段运用了 <code>asm_generator</code>, 将前端生成的 MLIR 解析为 汇编代码，生成的结果位于 out.asm</p><p>在第一部分提到一个疑问，就是说在从源程序转到MLIR一整个过程中，完全没有 Dialect 的现身，所以以为现在提供的这个测试完全没有涉及到 MLIR Dialect 的部分，一时间对于整个系统的结构又变得模糊了。但是通过查看 <code>asm_generator</code> 的源码，在其中发现了 MLIR Dialect 的身影</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>compiler</span><span class=o>::</span><span class=n>graph</span><span class=o>::</span><span class=n>GraphDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>compiler</span><span class=o>::</span><span class=n>matrix</span><span class=o>::</span><span class=n>MatrixDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>arith</span><span class=o>::</span><span class=n>ArithDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>scf</span><span class=o>::</span><span class=n>SCFDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>tensor</span><span class=o>::</span><span class=n>TensorDialect</span><span class=o>&gt;</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><p>因为 backend 的工作就是把 MLIR 翻译为 类汇编语言，所以这部分的工作总结来说就是实现转换，宏观上进行划分分为 2 部分：</p><ol><li>配置 dialect 和 pass</li></ol><p>比较神奇的是，对于 pass 和 dialect 的配置操作似乎都重复进行了 2 次，对于疑似重复 load 的问题放到 疑惑 一节进行阐述，</p><hr><p>如果暂时不管可能的重复 load 问题，从函数调用栈可以看出 dialect 的加载流程，对于 dialect 配置的程序入口是 <code>asm_generator.cpp</code> 中的 <code>context.loadDialect&lt;mlir::func::FuncDialect>();</code></p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231030014.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>函数调用栈中虽然包含了多个 <code>getOrLoadDialect</code>，但是本质上的调用关系还是符合下面右侧部分的流程</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p></blockquote><p>在上述函数调用栈中，后两个强调的内容和 dialect 的加载相关，这个我们先不管，重点看一下前两个内容</p><p>前两项内容完成了 dialect 的初始化工作，值得注意的一点是在写 dialect 的 初始化函数 <code>initialize()</code> 并不是人为给出的名称，那么应当是 ODS 模块规定的内容，然后在写 dialect 对应的 cpp 实现时，需要人为给出其实现，整体的结构关系如下图所示</p><p>同时可见，dialect 的初始化工作就是的就是为 dialect 添加 operation, attribute 和 type</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231043067.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=2><li>执行 pass pipeline</li></ol><p>pass 包含两种形式转换，其一是 graph to matrix，其二是 matrix to code</p><p>而 BFS 转为 CGA 的实现关键也就在于 graph to matrix 这部分</p><p>输入是 python 代码转换出来的 mlir 表达式，输出是什么目前还不确定，因为只能确定最后 codegen 生成的是类汇编语言，至于中间过程还需要通过代码来确定</p><p>pass 执行这部分理解起来比较困难是因为，启动方式是通过 <code>pm.run(module_.get());</code>，pass 处理的过程都是 PassManager 在背后完成的</p><p>PassManager 的作用更像是一个托管器，用户只需要给它提供 pass 的 function hook，即 <code>pm.addPass(compiler::createConvertGraphToMatrix());</code>,后续由 PassManager 负责启动 pass 的实际执行流程，具体流程如下：</p><p>在<a href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/#%E5%88%9B%E5%BB%BA-pass target=_blank rel="external nofollow noopener noreferrer">创建 pass</a>一节提到过，一个 pass 大致上由 3 部分组成：function hook, 实现了 <code>matchAndRewrite()</code> 的类 和 实现了 <code>runOnOperation()</code> 的类</p><p>以当前项目下的 GraphToMatrixPass 为例，这三部分如下图所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231143266.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>function hook 返回的是实现了 <code>runOnOperation()</code> 的类的智能指针，同时根据函数调用栈也可以看出 PassManager 对于 具体 pass 的执行入口就是 这里的 <code>runOnOperation()</code></p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231145369.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>由 PassManager 调用 <code>runOnOpeartion()</code> 之后，工作流就切换到具体的 pass 的执行上了. <code>matchAndRewrite()</code> 的入口在<code>applyPatternsAndFoldGreedily()</code>，详细调用关系如以下调用栈所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404231422719.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>关于 PassManager 的执行，有一个宏观上的执行情况，整体的 MLIR operation 内容都存储在 module 对象之中，PassManager 在具体执行时也会直接修改 module 中的内容</p><p>后续需要进入 GraphToMatrix 以及 CodeGen 两个子环节进行分析</p><h5 id=graphtomatrix>GraphToMatrix</h5><ol><li>MLIR 表达式内容和 td 文件内容对照关系，以 graph dialect MLIR 为例：</li></ol><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>module</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>func</span><span class=o>.</span><span class=k>func</span> <span class=err>@</span><span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>0</span> <span class=o>=</span> <span class=s2>&#34;graph.loadGraph&#34;</span><span class=p>()</span> <span class=o>&lt;</span><span class=p>{</span><span class=n>input_filename</span> <span class=o>=</span> <span class=s2>&#34;./test_graph&#34;</span><span class=p>}</span><span class=o>&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xi32</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>%</span><span class=mi>1</span> <span class=o>=</span> <span class=s2>&#34;graph.loadVertexProp&#34;</span><span class=p>()</span> <span class=o>&lt;</span><span class=p>{</span><span class=n>input_filename</span> <span class=o>=</span> <span class=s2>&#34;./test_vdata&#34;</span><span class=p>}</span><span class=o>&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=o>-&gt;</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xi32</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=s2>&#34;graph.gc&#34;</span><span class=p>(</span><span class=o>%</span><span class=mi>0</span><span class=p>,</span> <span class=o>%</span><span class=mi>1</span><span class=p>)</span> <span class=o>&lt;</span><span class=p>{</span><span class=n>active_mode</span> <span class=o>=</span> <span class=s2>&#34;PartialActive&#34;</span><span class=p>,</span> <span class=n>apply_mode</span> <span class=o>=</span> <span class=s2>&#34;Min_&#34;</span><span class=p>,</span> <span class=n>construct_mode</span> <span class=o>=</span> <span class=s2>&#34;Default&#34;</span><span class=p>,</span> <span class=n>gather_add_mode</span> <span class=o>=</span> <span class=s2>&#34;Min_&#34;</span><span class=p>,</span> <span class=n>gather_mult_mode</span> <span class=o>=</span> <span class=s2>&#34;Add_One_&#34;</span><span class=p>,</span> <span class=n>iteration_num</span> <span class=o>=</span> <span class=mi>100</span> <span class=p>:</span> <span class=n>i32</span><span class=p>,</span> <span class=n>start_id</span> <span class=o>=</span> <span class=mi>0</span> <span class=p>:</span> <span class=n>i32</span><span class=p>}</span><span class=o>&gt;</span> <span class=p>:</span> <span class=p>(</span><span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xi32</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>tensor</span><span class=o>&lt;*</span><span class=n>xi32</span><span class=o>&gt;</span><span class=p>)</span> <span class=o>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>其中，我们关注 2 项：graph.* 和 graph.gc 中的这些 key-value</p><p>graph.* 是在 td 文件中自定义的 operation 名称，比如这里的 gc</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mysql data-lang=mysql><span class=line><span class=cl><span class=n>def</span><span class=w> </span><span class=n>Graph_GcOp</span><span class=p>:</span><span class=w> </span><span class=n>Graph_BaseOp</span><span class=o>&lt;</span><span class=s2>&#34;gc&#34;</span><span class=o>&gt;</span><span class=w> </span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>summary</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;Graph Processing operator&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>description</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=err>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Graph</span><span class=w> </span><span class=n>Computing</span><span class=w> </span><span class=n>Program</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=err>}</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=n>let</span><span class=w> </span><span class=n>arguments</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>ins</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>AnyTensor</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>graphData</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>AnyTensor</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>vpropsData</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ConstructModeAttr</span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>construct_mode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>GatherMultModeAttr</span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>gather_mult_mode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>GatherAddModeAttr</span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>gather_add_mode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ApplyModeAttr</span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>apply_mode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ActiveModeAttr</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>active_mode</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OptionalAttr</span><span class=o>&lt;</span><span class=n>I32Attr</span><span class=o>&gt;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>iteration_num</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>OptionalAttr</span><span class=o>&lt;</span><span class=n>I32Attr</span><span class=o>&gt;</span><span class=w> </span><span class=p>:</span><span class=w> </span><span class=err>$</span><span class=n>start_id</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>let</span><span class=w> </span><span class=n>results</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>outs</span><span class=w> </span><span class=n>AnyRankedTensor</span><span class=p>:</span><span class=err>$</span><span class=n>vprops_output</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=o>//</span><span class=w> </span><span class=n>let</span><span class=w> </span><span class=n>assemblyFormat</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s2>&#34;`_`&#34;</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=err>}</span></span></span></code></pre></td></tr></table></div></div><p>MLIR 中的 key-value 中的 key 就是 td 文件中 <code>$</code> 后面的内容，在 GraphOps.h.inc 中存在对于这些 attributes 名称的注册函数</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>static</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>ArrayRef</span><span class=o>&lt;::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=o>&gt;</span> <span class=n>getAttributeNames</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>static</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span> <span class=n>attrNames</span><span class=p>[]</span> <span class=o>=</span> <span class=p>{</span><span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;active_mode&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;apply_mode&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;construct_mode&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;gather_add_mode&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;gather_mult_mode&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;iteration_num&#34;</span><span class=p>),</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>StringRef</span><span class=p>(</span><span class=s>&#34;start_id&#34;</span><span class=p>)};</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=o>::</span><span class=n>llvm</span><span class=o>::</span><span class=n>ArrayRef</span><span class=p>(</span><span class=n>attrNames</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>而其中的 value 来源于 对于 GraphOps.td 中所给出的 attributes</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>def ConstructModeAttr : AnyStrAttrOf&lt;[&#34;Default&#34;, &#34;Custom&#34;]&gt;;
</span></span><span class=line><span class=cl>def GatherMultModeAttr: AnyStrAttrOf&lt;[&#34;Add_One_&#34;, &#34;Add_Weight_&#34;, &#34;First_&#34;, &#34;Second_&#34;, &#34;Custom&#34;]&gt;;
</span></span><span class=line><span class=cl>def GatherAddModeAttr: AnyStrAttrOf&lt;[&#34;Add_&#34;, &#34;Sub_&#34;, &#34;Mult_&#34;, &#34;Div_&#34;, &#34;Min_&#34;, &#34;Max_&#34;, &#34;First_&#34;, &#34;Second_&#34;, &#34;Custom&#34;]&gt;;
</span></span><span class=line><span class=cl>def ApplyModeAttr : AnyStrAttrOf&lt;[&#34;Add_&#34;, &#34;Sub_&#34;, &#34;Mult_&#34;, &#34;Div_&#34;, &#34;Min_&#34;, &#34;Max_&#34;, &#34;First_&#34;, &#34;Second_&#34;, &#34;Custom&#34;]&gt;;</span></span></code></pre></td></tr></table></div></div><ol start=2><li>模式重写是如何匹配操作的</li></ol><div class=highlight id=id-14><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>LogicalResult</span> <span class=nf>matchAndRewrite</span><span class=p>(</span><span class=n>graph</span><span class=o>::</span><span class=n>GcOp</span> <span class=n>op</span><span class=p>,</span> <span class=n>PatternRewriter</span> <span class=o>&amp;</span><span class=n>rewriter</span><span class=p>)</span><span class=k>const</span> <span class=k>override</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span><span class=p>(</span><span class=n>op</span><span class=p>.</span><span class=n>getGatherMultMode</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;Add_One_&#34;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>          <span class=n>mul_mode</span> <span class=o>=</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUModeAttr</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>rewriter</span><span class=p>.</span><span class=n>getContext</span><span class=p>(),</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUMode</span><span class=o>::</span><span class=n>PLUS1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><blockquote><p>GraphToMatrixPass.cpp</p></blockquote><p>op 可以直接调用 <code>getGatherMultMode()</code> 是因为 op 是 graph::GcOp 类的对象，自然是有这个方法的。同时也是通过这一参数实现的仅匹配 graph.gc operation。</p><p>不过从这里产生一个疑惑，即 graph:GcOp 的名称是如何得到的 GcOp，详细描述转到疑惑一节</p><ol start=3><li>从 graph dialect 转变为 matrix dialect 生成的 MLIR</li></ol><div class=highlight id=id-15><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;graph.loadGraph&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>input_filename =</span> <span class=s>&#34;./test_graph&#34;</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;graph.loadVertexProp&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>input_filename =</span> <span class=s>&#34;./test_vdata&#34;</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;matrix.GConfig&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>add_alu =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>add_alu_mode MIN<span class=p>&gt;,</span> <span class=nl>edge_fifo =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>edge_fifo_mode ON<span class=p>&gt;,</span> <span class=nl>mul_alu =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>mul_alu_mode PLUS1<span class=p>&gt;,</span> <span class=nl>new_spm_loc =</span> <span class=m>4194304</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>old_spm_loc =</span> <span class=m>4194304</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>out_to_dst =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>dst_Buff_mode ON<span class=p>&gt;,</span> <span class=nl>traversal_dirc =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>tr_dirc_mode PUSH<span class=p>&gt;}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> none
</span></span><span class=line><span class=cl>    <span class=s>&#34;matrix.graphExerRun&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>iter_num =</span> <span class=m>100</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>root_id =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=4><li>增加 +weight 操作的模式重写</li></ol><ul><li><p>需要理解 gc 这个操作所带的 attribute 包含一项 <code>GatherMultModeAttr: $gather_mult_mode</code>，并且此属性所包含的值有 <code>def GatherMultModeAttr: AnyStrAttrOf&lt;["Add_One_", "Add_Weight_", "First_", "Second_", "Custom"]>;</code> 这些</p></li><li><p>关于 MulALUMode 是 matrix 的一个 enum 类型的 attribute，目前只知道其 value 包括如下内容</p></li></ul><div class=highlight id=id-16><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>enum</span> <span class=k>class</span> <span class=nc>MulALUMode</span> <span class=o>:</span> <span class=kt>uint32_t</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUS1</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>ADDE</span> <span class=o>=</span> <span class=mi>1</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>NONE</span> <span class=o>=</span> <span class=mi>2</span><span class=p>,</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><hr><p>GraphToMatrixPass.cpp 改写内容：</p><div class=highlight id=id-17><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span><span class=p>(</span><span class=n>op</span><span class=p>.</span><span class=n>getGatherMultMode</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;Add_One_&#34;</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=n>mul_mode</span> <span class=o>=</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUModeAttr</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>rewriter</span><span class=p>.</span><span class=n>getContext</span><span class=p>(),</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUMode</span><span class=o>::</span><span class=n>PLUS1</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>op</span><span class=p>.</span><span class=n>getGatherMultMode</span><span class=p>()</span> <span class=o>==</span> <span class=s>&#34;Add_Weight_&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>mul_mode</span> <span class=o>=</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUModeAttr</span><span class=o>::</span><span class=n>get</span><span class=p>(</span><span class=n>rewriter</span><span class=p>.</span><span class=n>getContext</span><span class=p>(),</span> <span class=n>matrix</span><span class=o>::</span><span class=n>MulALUMode</span><span class=o>::</span><span class=n>ADDE</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>仿照 <code>Add_One_</code> 的方式，增加一个处理 <code>Add_Weight_</code> 的获取规则，由于两种方式下操作的构建方式都是相同的，因此其他部分可 reuse。不过这里的 <code>ADDE</code> 究竟表示什么意义还暂时不清楚，需要结合一下代码生成部分的内容。</p><p>其余部分需要用到的关键代码就是</p><div class=highlight id=id-18><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>rewriter</span><span class=p>.</span><span class=n>create</span><span class=o>&lt;</span><span class=n>matrix</span><span class=o>::</span><span class=n>GraphExerConfigOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>.</span><span class=n>getLoc</span><span class=p>(),</span> 
</span></span><span class=line><span class=cl>                                  <span class=n>noneType</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>rewriter</span><span class=p>.</span><span class=n>getI32IntegerAttr</span><span class=p>(</span><span class=n>SPM_OLD_V</span><span class=p>),</span> 
</span></span><span class=line><span class=cl>                                  <span class=n>rewriter</span><span class=p>.</span><span class=n>getI32IntegerAttr</span><span class=p>(</span><span class=n>new_v</span><span class=p>),</span>
</span></span><span class=line><span class=cl>                                  <span class=n>traversal_mode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>dstbufferoutput</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>edgefifomode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>mul_mode</span><span class=p>,</span>
</span></span><span class=line><span class=cl>                                  <span class=n>add_mode</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div><p>以上两部分内容相结合即可生成一个和 <code>graph.gc()</code> 对应 的 <code>matrix.GConfig()</code> MLIR 表达式。</p><p><code>matrix.GConfig()</code> MLIR 表达式在背后对应的实际是 <code>GraphExerConfigOp</code> 这个类，<code>rewrite.create</code>所做的无非是调用了该类的构造函数实例化出一个对象，构造函数如下图所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404261114013.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>而类的构造函数中的各种参数（或者说类的成员变量）来源于 matrix operation td 给定的 arguments，从类的角度来讲，tblgen 会为这些参数生成 getter 方法和携带它们的构造函数</p><div class=highlight id=id-19><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let arguments =(ins
</span></span><span class=line><span class=cl>    I32Attr :$old_spm_loc,
</span></span><span class=line><span class=cl>    I32Attr :$new_spm_loc,
</span></span><span class=line><span class=cl>    DefaultValuedAttr&lt;Matrix_TraversalDirectionModeAttr, &#34;matrix::TraversalDirectionMode::PULL&#34;&gt; : $traversal_dirc,
</span></span><span class=line><span class=cl>    DefaultValuedAttr&lt;Matrix_OutputToDstBufferModeAttr, &#34;matrix::OutputToDstBufferMode::OFF&#34;&gt; : $out_to_dst,
</span></span><span class=line><span class=cl>    DefaultValuedAttr&lt;Matrix_EdgeFIFOModeAttr, &#34;matrix::EdgeFIFOMode::OFF&#34;&gt; : $edge_fifo,
</span></span><span class=line><span class=cl>    DefaultValuedAttr&lt;Matrix_MulALUModeAttr, &#34;matrix::MulALUMode::PLUS1&#34;&gt; : $mul_alu,
</span></span><span class=line><span class=cl>    DefaultValuedAttr&lt;Matrix_AddALUModeAttr, &#34;matrix::AddALUMode::MIN&#34;&gt; : $add_alu
</span></span><span class=line><span class=cl>  );</span></span></code></pre></td></tr></table></div></div><p>最后可以生成 sssp 对应的 matrix dialect MLIR内容如下</p><div class=highlight id=id-20><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-mlir data-lang=mlir><span class=line><span class=cl>module <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=kt>func</span><span class=p>.</span><span class=kt>func</span> <span class=nf>@main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=nv>%0</span> <span class=p>=</span> <span class=s>&#34;graph.loadGraph&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>input_filename =</span> <span class=s>&#34;./test_graph&#34;</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%1</span> <span class=p>=</span> <span class=s>&#34;graph.loadVertexProp&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>input_filename =</span> <span class=s>&#34;./test_vdata&#34;</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=kt>tensor</span><span class=p>&lt;*</span>xi32<span class=p>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nv>%2</span> <span class=p>=</span> <span class=s>&#34;matrix.GConfig&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>add_alu =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>add_alu_mode MIN<span class=p>&gt;,</span> <span class=nl>edge_fifo =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>edge_fifo_mode ON<span class=p>&gt;,</span> <span class=nl>mul_alu =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>mul_alu_mode ADDE<span class=p>&gt;,</span> <span class=nl>new_spm_loc =</span> <span class=m>4194304</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>old_spm_loc =</span> <span class=m>4194304</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>out_to_dst =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>dst_Buff_mode ON<span class=p>&gt;,</span> <span class=nl>traversal_dirc =</span> <span class=nv>#matrix</span><span class=p>&lt;</span>tr_dirc_mode PUSH<span class=p>&gt;}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> none
</span></span><span class=line><span class=cl>    <span class=s>&#34;matrix.graphExerRun&#34;</span><span class=p>()</span> <span class=p>&lt;{</span><span class=nl>iter_num =</span> <span class=m>100</span> <span class=p>:</span> <span class=k>i32</span><span class=p>,</span> <span class=nl>root_id =</span> <span class=m>0</span> <span class=p>:</span> <span class=k>i32</span><span class=p>}&gt;</span> <span class=p>:</span> <span class=p>()</span> <span class=p>-&gt;</span> <span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=kt>return</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><h5 id=codegen>CodeGen</h5><p>目前代码中和此内容相关的涉及到两个 pass：CodeGenPass 和 RegisterAllocPass，但是目前参与 lowering 的只有前者（asm_generator.cpp证明）</p><div class=highlight id=id-21><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>compiler</span><span class=o>::</span><span class=n>createConvertGraphToMatrix</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>pm</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>compiler</span><span class=o>::</span><span class=n>matrix</span><span class=o>::</span><span class=n>createCodeGenPass</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><p>由于目前参与 lowering 的 pass 只有 <code>createCodeGenPass</code>，所以接下来分析 CodeGenPass.cpp</p><p>不同于 GraphToMatrixPass 的全人工实现方式，CodeGenPass 利用了 constructor，并且因为此步骤不再是 dialect lowering，而是代码生成，因此并不需要实现 <code>matchAndRewrite()</code></p><div class=highlight id=id-22><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-txt data-lang=txt><span class=line><span class=cl>def CodeGen : Pass&lt;&#34;codegen&#34;, &#34;ModuleOp&#34;&gt; {
</span></span><span class=line><span class=cl>  let summary = &#34;emit instructions&#34;;
</span></span><span class=line><span class=cl>  let constructor = &#34;createCodeGenPass()&#34;;
</span></span><span class=line><span class=cl>  let dependentDialects = [&#34;MatrixDialect&#34;];
</span></span><span class=line><span class=cl>  let options = [
</span></span><span class=line><span class=cl>  ];
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><p>从 pass 的 function hook 进入 <code>runOnOperation()</code>后，开始实施代码生成的流程</p><div class=highlight id=id-23><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>moduleop</span><span class=p>.</span><span class=n>walk</span><span class=p>([</span><span class=o>&amp;</span><span class=p>](</span><span class=n>mlir</span><span class=o>::</span><span class=n>Operation</span><span class=o>*</span> <span class=n>op</span><span class=p>){</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>GraphExerConfigOp</span> <span class=n>config_op</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>::</span><span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>GraphExerConfigOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>config_op</span><span class=p>.</span><span class=n>emit_Instr</span><span class=p>(</span><span class=o>&amp;</span><span class=n>builder</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>GraphExerRunOp</span> <span class=n>run_op</span> <span class=o>=</span> <span class=n>llvm</span><span class=o>::</span><span class=n>dyn_cast</span><span class=o>&lt;</span><span class=n>GraphExerRunOp</span><span class=o>&gt;</span><span class=p>(</span><span class=n>op</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>run_op</span><span class=p>.</span><span class=n>emit_Instr</span><span class=p>(</span><span class=o>&amp;</span><span class=n>builder</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>builder</span><span class=p>.</span><span class=n>store</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><p>walk 函数会遍历经过 GraphToMatrix lowering 生成的 MLIR 中的所有 operation，并且对于每个 operation 都实施一次给定的 回调函数。</p><p>回调函数的执行重点就在于 <code>config_op.emit_Instr()</code>。<code>emit_Instr()</code> 是 operation 的一个 interface。当我们为 operation 指定一些 attribute 时，tblgen 会自动为这些 attribute 生成一些 get 方法（其实就是普通类的成员变量对应的 get 方法）。如果想为 operation 添加一些自定义方法（更准确并且更好理解的说法是为 operation 类添加一些成员方法），MLIR 就提供了 interface 机制，在 td 中书写 operation 时指定一些 interface，tblgen 在生成 operation 类时就会在类中声明该方法，我们只需要直接给出定义即可。下图展示了为 GraphExerConfigOp 添加一个 interface 所需要做的全部工作</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251600008.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>在 td 中创建一个 interface，其中指明了此 interface 所指向的类的方法为 emit_Instr。operation 在模版参数中指定这一 interface。在完成这两步操作之后，通过 tblgen 生成的 operation 类中就会包含 emit_Instr 方法，我们只需要在 cpp 中给出其实现即可。</p><hr><p>CodeGenPass 中只对 GraphExerConfigOp 和 GraphExerRunOp 进行了匹配，只会对它们两条指令生成类汇编代码（ matrix dialect mlir 中一共也就 4 条指令）。从 emit_Instr 的具体实现来看，它直接写死了类汇编指令，这里有一点不理解，见疑惑小节。</p><hr><p>对于现有指令的分析:</p><p>指令中使用到的参数的概念如下</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404262119704.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h4 id=run>run</h4><p>运行阶段需要利用硬件模拟器 <code>third_party/function-sim-dev/build/assembler/assembler</code> 来执行后端生成的汇编代码</p><p>模拟器这部分一共生成了 3 个重要的内容：</p><ol><li>可执行程序 spmmcore: 对应 main.cpp，目前此代码把类汇编指令写死在程序里了，暂时没有用到</li><li>可执行程序 assembler: 对应 assembler/Assembler.cpp</li><li>库 src_lib: 对应 src 目录，此 lib 包含了部分工具</li></ol><p>类汇编代码的执行关键步骤都在 Assembler.cpp 中，执行包含两个步骤</p><blockquote><ol><li><p>set instruction memory</p></li><li><p>go through qunit pipeline</p></li></ol></blockquote><p>在这两个步骤中，后者是实际执行的流程，需要用到 TopUnit.cpp 提供的 <code>Frontend()</code> 和 <code>Backend()</code></p><p>TopUnit.cpp 的关键内容如下，在具体的实现中会涉及到计分板等算法实现</p><div class=highlight id=id-24><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>/// @brief TopUnit的初始化函数，初始化SPM, DRAM, 构建执行器和初始化计分板
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Init</span><span class=p>(){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// @brief 初始化指令SPM
</span></span></span><span class=line><span class=cl><span class=c1>/// @param instrs 外部的指令序列
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>void</span> <span class=nf>InitInstructionMemory</span><span class=p>(</span><span class=n>std</span><span class=o>::</span><span class=n>vector</span><span class=o>&lt;</span><span class=n>Instruction</span><span class=o>&gt;</span> <span class=o>&amp;</span><span class=n>instrs</span><span class=p>){}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// @brief TopUnit每一个cycle步的功能
</span></span></span><span class=line><span class=cl><span class=c1>/// @param clk 当前的时钟
</span></span></span><span class=line><span class=cl><span class=c1>/// @param rst 重置信号
</span></span></span><span class=line><span class=cl><span class=c1>/// @retval 是否shutdown
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>int</span> <span class=nf>CycleStep</span><span class=p>(</span><span class=kt>int</span> <span class=n>clk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// @brief TopUnit的前端实现
</span></span></span><span class=line><span class=cl><span class=c1>/// @param clk 当前时钟
</span></span></span><span class=line><span class=cl><span class=c1>/// @param rst 重置信号
</span></span></span><span class=line><span class=cl><span class=c1>/// @retval 是否shutdown
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>int</span> <span class=nf>Frontend</span><span class=p>(</span><span class=kt>int</span> <span class=n>clk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// @brief TopUnit的后端实现
</span></span></span><span class=line><span class=cl><span class=c1>/// @param clk 当前时钟
</span></span></span><span class=line><span class=cl><span class=c1>/// @param rst 重置信号
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>void</span> <span class=nf>Backend</span><span class=p>(</span><span class=kt>int</span> <span class=n>clk</span><span class=p>,</span> <span class=kt>int</span> <span class=n>rst</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>/// @brief 打印执行统计数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>virtual</span> <span class=kt>void</span> <span class=nf>PrintStastics</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><hr><p>关于硬件模拟器的前后端的解释</p><blockquote><ul><li><p>Frontend：前端负责模拟器与外部环境之间的接口和交互。这包括读取输入文件、解析指令、处理输入数据等工作。前端通常负责将输入转换为模拟器内部能够处理的格式，并将其传递给后端。</p></li><li><p>Backend：后端是模拟器的核心部分，负责执行模拟过程并产生模拟结果。后端通常包括模拟器的核心逻辑、仿真器、模拟器的模型和算法等。后端接收来自前端的输入，执行相应的仿真操作，并生成模拟结果或输出。</p></li></ul></blockquote><hr><p>令人费解的一点是，在类汇编语言在执行时，在 Assembler.cpp 中指定了在前 10 个时钟周期下，复位信号均为1，在以后的时钟周期下，复位信号均为 0。根据以下执行流程图中 <code>Frontend(clk, rst);</code> 的内容，只有在复位信号为 0 时才会进行取指和译码，否则会直接返回 0 值（正常返回，根据 Assembler.cpp 的内容，当 <code>Frontend(clk, rst);</code> 返回结果为 1 时，对时钟周期的循环将停止，否则将继续进行）。</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404182104375.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>以上过程令人费解的有两点：</p><ol><li>在一个时钟周期下，先进行的 <code>Backend(clk, rst);</code>，后进行的 <code>Frontend(clk, rst);</code>，这不太符合直观上的执行流程</li><li>这前 10 个时钟周期复位信号直接置为 1 是什么意思（复位信号是将硬件系统恢复到初始状态的信号）</li></ol><hr><p>assembler 在执行时首先将 asm 文件中的指令，借助于 graph_compiler/include/Builder/Instruction.h，将每所有指令解析到元素类型为 Instruction 类的容器中</p><h3 id=疑惑-1>疑惑</h3><p>从实际项目来看，核心工作在于 Dialect降级 和 IR的转换，应用其中的统一称为 pass（应用位于 asm_generator.cpp 中）</p><p>而 pass 所需要使用的原料即为 Dialect，不过目前不太懂的是 operation 作为 Dialect 的一种属性，它在 lowering 和 transformation 的过程中充当了什么作用，它是负责描述降级转换的方式还是说单纯就描述 Dialect 的属性</p><ol><li>mlir 是怎么变为的 asm？</li><li>bfs算法联调通过，这怎么个通过法，似乎根本就没实现这个bfs呀（难道就是说接口能跑通了?）</li></ol><p>整个变形过程分为两部分：GraphToMatrix 和 CodeGen。前者属于是lowering，IR本身并没有改变，只是运用Dialect实现了降级，相关的文件位于 lib/Conversion/，后者属于是transformation，IR已经发生了改变，相关的文件位于 lib/Dialect/Matrix/Transform</p><p>passManager添加的都是一些类，不过 pass 背后的执行逻辑现在完全还是黑盒状态，可能是因为这些类实现了什么特殊的方法从而使得 pass 能够使得他们发挥作用吗？现在对这个机制还不太理解</p><p>老师说重点关注一下 BFS算法 到 CGA实现 这部分代码，但是现在以我的理解，压根就还没有这个实现，只是说现在用一个 bfs.asm 跑通了 硬件模拟器（bfs.asm 怎么来的？）</p><p>不过目前这个逻辑确实是符合项目架构图的，因为后端的目标就是生成类汇编语言，至于类汇编语言之后现在项目采用模拟器可能是因为底层硬件目前还未实现，先拿硬件模拟器简单跑一下</p><p>发现 <code>graph_compiler/third_party/function-sim-dev/assembler/bfs.asm</code> 和给出的测试脚本 <code>graph_compiler</code> 在 backend 阶段生成的 out.asm 内容是完全相同的</p><ol start=3><li><del>执行程序的路径问题</del></li></ol><p>对于 tools 下面的 main.cpp 编译出的 graph_compiler 可执行程序，源代码在调用其他程序，例如 asm_generator 时，根路径采用的都是 build 文件夹。</p><p>debug 时，根路径 会遵循 launch.json 中 <code>cwd</code> 参数指向的值</p><ol start=4><li>pass 的注册和使用问题</li></ol><p>之前在 mlir-hello 中给出了 pass 的创建 和 使用流程，对于 pass 的使用来说，只需要通过 PassManager 添加 pass 并运行即可，即 pass 应用的全流程只包含 lowering 的创建，应用以及通过 PassManager 进行注册这几个过程（也就是 mlir-hello 项目中的 <a href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/#%E5%88%9B%E5%BB%BA-pass target=_blank rel="external nofollow noopener noreferrer">创建 pass</a> 和 <a href=https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/#%E5%88%9B%E5%BB%BA-opt target=_blank rel="external nofollow noopener noreferrer">创建 opt</a> 这两个过程中涉及到的内容）</p><p>不过在目前的项目中，把 创建pass 的 C++ 实现变为了使用 td 实现，实际是相同的操作，都是创建了一个重写 runOnOperation 方法的类，不过现有的项目是通过 td 声明了这个类，然后后续在 cpp 文件中进行了定义</p><p>有一点不同的是，在 mlir-hello 最后创建 opt 的环节，对于 pass 只进行了下面的操作：</p><div class=highlight id=id-25><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>PassManager</span> <span class=n>passManager</span><span class=p>(</span><span class=o>&amp;</span><span class=n>context</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=n>passManager</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>hello</span><span class=o>::</span><span class=n>createLowerToAffinePass</span><span class=p>());</span>
</span></span><span class=line><span class=cl><span class=n>passManager</span><span class=p>.</span><span class=n>addPass</span><span class=p>(</span><span class=n>hello</span><span class=o>::</span><span class=n>createLowerToLLVMPass</span><span class=p>());</span></span></span></code></pre></td></tr></table></div></div><p>但是在当前项目中，又额外进行了如下操作：</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404220959879.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>从上图中不难发现，人工调用的两个 MLIR 提供的函数调用就是下面两个（而这两个函数调用对应的后续工作都是通过 <code>tblgen</code> 生成的内容完成的，即上图中的红色箭头所指向的过程，并且 tblgen 生成的内容和人工编写的 td 文件的内容有关联）</p><div class=highlight id=id-26><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>registerCanonicalizer</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>mlir</span><span class=o>::</span><span class=n>registerConversionPasses</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><p>同样从上图可以看出，这两个调用对应到最底层的两项工作就是</p><div class=highlight id=id-27><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>registerPass</span><span class=p>([]()</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>mlir</span><span class=o>::</span><span class=n>createCanonicalizerPass</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=o>::</span><span class=n>mlir</span><span class=o>::</span><span class=n>registerPass</span><span class=p>([]()</span> <span class=o>-&gt;</span> <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;::</span><span class=n>mlir</span><span class=o>::</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>compiler</span><span class=o>::</span><span class=n>createConvertGraphToMatrix</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=p>});</span></span></span></code></pre></td></tr></table></div></div><p>目前的疑问其实就是，无论怎么做，最后都是要通过 <code>passManager.addPass()</code> 来添加一个 pass 的，那么这里进行的 register 注册的意义是什么？</p><p><a href=https://mlir.llvm.org/doxygen/classmlir_1_1OpPassManager.html#a6c540b725a808914461b8dc53a29a5e3 target=_blank rel="external nofollow noopener noreferrer">addPass()</a> 的作用是 &ldquo;Add the given pass to this pass manager&rdquo;</p><blockquote><p>需要注意的是代码中是 <code>PassManager</code> 类的实例在调用此方法，但是此方法实际是 <code>OpPassManager</code> 类的方法，<code>PassManager</code> 继承自 <code>OpPassManager</code></p></blockquote><p>我目前有一种猜想，就是 registerPass 和 addPass 起到的是相同的效果，实际只进行其中一种操作即可。根据 chatgpt 的说法，registerPass 就是将 pass 加入到 passManager 中了，这样来说的话，只需要使用 addPass 即可，初步测试好像注释掉 registerPass 确实没有问题</p><p>不过从源码来看，并没有看到 registerPass 哪里将 pass 加入了 passManager</p><div class=highlight id=id-28><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>mlir</span><span class=o>::</span><span class=n>registerPass</span><span class=p>(</span><span class=k>const</span> <span class=n>PassAllocatorFunction</span> <span class=o>&amp;</span><span class=n>function</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>std</span><span class=o>::</span><span class=n>unique_ptr</span><span class=o>&lt;</span><span class=n>Pass</span><span class=o>&gt;</span> <span class=n>pass</span> <span class=o>=</span> <span class=n>function</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=n>StringRef</span> <span class=n>arg</span> <span class=o>=</span> <span class=n>pass</span><span class=o>-&gt;</span><span class=n>getArgument</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>(</span><span class=n>arg</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span>
</span></span><span class=line><span class=cl>     <span class=n>llvm</span><span class=o>::</span><span class=n>report_fatal_error</span><span class=p>(</span><span class=n>llvm</span><span class=o>::</span><span class=n>Twine</span><span class=p>(</span><span class=s>&#34;Trying to register &#39;&#34;</span><span class=p>)</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                              <span class=n>pass</span><span class=o>-&gt;</span><span class=n>getName</span><span class=p>()</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>                              <span class=s>&#34;&#39; pass that does not override `getArgument()`&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=n>StringRef</span> <span class=n>description</span> <span class=o>=</span> <span class=n>pass</span><span class=o>-&gt;</span><span class=n>getDescription</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=n>PassInfo</span> <span class=nf>passInfo</span><span class=p>(</span><span class=n>arg</span><span class=p>,</span> <span class=n>description</span><span class=p>,</span> <span class=n>function</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=n>passRegistry</span><span class=o>-&gt;</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>arg</span><span class=p>,</span> <span class=n>passInfo</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>   <span class=c1>// Verify that the registered pass has the same ID as any registered to this
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=c1>// arg before it.
</span></span></span><span class=line><span class=cl><span class=c1></span>   <span class=n>TypeID</span> <span class=n>entryTypeID</span> <span class=o>=</span> <span class=n>pass</span><span class=o>-&gt;</span><span class=n>getTypeID</span><span class=p>();</span>
</span></span><span class=line><span class=cl>   <span class=k>auto</span> <span class=n>it</span> <span class=o>=</span> <span class=n>passRegistryTypeIDs</span><span class=o>-&gt;</span><span class=n>try_emplace</span><span class=p>(</span><span class=n>arg</span><span class=p>,</span> <span class=n>entryTypeID</span><span class=p>).</span><span class=n>first</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>(</span><span class=n>it</span><span class=o>-&gt;</span><span class=n>second</span> <span class=o>!=</span> <span class=n>entryTypeID</span><span class=p>)</span>
</span></span><span class=line><span class=cl>     <span class=n>llvm</span><span class=o>::</span><span class=n>report_fatal_error</span><span class=p>(</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;pass allocator creates a different pass than previously &#34;</span>
</span></span><span class=line><span class=cl>         <span class=s>&#34;registered for pass &#34;</span> <span class=o>+</span>
</span></span><span class=line><span class=cl>         <span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=5><li>对于 dialect 的疑似重复 load 疑问</li></ol><p>以对 dialect 的操作为例，如下图所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404221443475.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>注意，上图中的 蓝色虚线 表示在 <code>asm_generator.cpp</code> 中的执行顺序，可以发现两部分执行内容最终执行内容都是 <code>getOrLoadDialect&lt;>()</code>（红色标识内容）</p><p>所以是否以下两部分代码只需要执行一部分即可?</p><div class=highlight id=id-29><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>compiler</span><span class=o>::</span><span class=n>registerAllDialects</span><span class=p>(</span><span class=n>registry</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>mlir</span><span class=o>::</span><span class=n>func</span><span class=o>::</span><span class=n>FuncDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>compiler</span><span class=o>::</span><span class=n>graph</span><span class=o>::</span><span class=n>GraphDialect</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl><span class=n>context</span><span class=p>.</span><span class=n>loadDialect</span><span class=o>&lt;</span><span class=n>compiler</span><span class=o>::</span><span class=n>matrix</span><span class=o>::</span><span class=n>MatrixDialect</span><span class=o>&gt;</span><span class=p>();</span></span></span></code></pre></td></tr></table></div></div><ol start=6><li>[我的理解好像有问题，这个问题待定] 在 CodeGen 环节使用到的两个 pass(<code>RegisterAlloc</code> 和 <code>CodeGen</code>)，在创建时使用到了 constructor 辅助工具。按理说在对应的 cpp 文件中就无需再重复给出实现了 <code>runOnOperation()</code> 类中除了 <code>runOnOperation()</code> 以外的其他内容的定义，因为 tblgen 已经生成了此类的声明，在 cpp 文件中只需要给出 <code>runOnOperation()</code> 的定义即可，也就是目前虽然在 td 文件中使用到了 constructor 辅助工具，但是并没有利用上（从 CodeGenPass.cpp 和 RegisterAllocPass.cpp 引入的头文件即可证明这一点，如果使用到了 tblgen 生成的内容，那么两个 .cpp 应当会引入 .inc 文件）</li></ol><div class=highlight id=id-30><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>def</span> <span class=nf>RegisterAlloc</span> <span class=p>:</span> <span class=n>Pass</span><span class=o>&lt;</span><span class=s2>&#34;register-alloc&#34;</span><span class=p>,</span> <span class=s2>&#34;ModuleOp&#34;</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>summary</span> <span class=o>=</span> <span class=s2>&#34;alloc register&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>constructor</span> <span class=o>=</span> <span class=s2>&#34;createRegisterAllocPass()&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>dependentDialects</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;MatrixDialect&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>options</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>CodeGen</span> <span class=p>:</span> <span class=n>Pass</span><span class=o>&lt;</span><span class=s2>&#34;codegen&#34;</span><span class=p>,</span> <span class=s2>&#34;ModuleOp&#34;</span><span class=o>&gt;</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>summary</span> <span class=o>=</span> <span class=s2>&#34;emit instructions&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>constructor</span> <span class=o>=</span> <span class=s2>&#34;createCodeGenPass()&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>dependentDialects</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;MatrixDialect&#34;</span><span class=p>];</span>
</span></span><span class=line><span class=cl>  <span class=n>let</span> <span class=n>options</span> <span class=o>=</span> <span class=p>[</span>
</span></span><span class=line><span class=cl>  <span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><ol start=7><li>从 td 中的 operation 生成 .h.inc 中的类，这个名称的转换似乎都遵循了一种规则，这中规则是 MLIR 规定的还是人工约束的?</li></ol><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202404251110956.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=8><li>CodeGen 环节直接写死了类汇编代码，对此产生了几点疑问</li></ol><ul><li>为什么是执行这些指令？</li><li>这些指令只是 matrix.GConfig 和 matrix.graphExerRun 这两部分的，那么图数据是哪来的，没有数据那最后模拟器在跑什么？</li><li>一直强调的是将图算法转到矩阵运算上，转换到具体算子的实现上，按照现在这个转换方式，只有中间的 matrix dialect 涉及到了矩阵，而且还只是抽象的概念，一点没有涉及到之前分析的图算法到矩阵运算的转换算法，然后从抽象又直接转换到类汇编代码，整个过程矩阵运算体现在了哪里</li></ul><ol start=9><li>目前项目中的待完善点</li></ol><ul><li>在 MLIRGen.py 中的 <code>convert_main_func()</code> 提到后续需要在 main 函数中支持 stmt，这个 stmt 是什么？</li></ul><ol start=10><li>对于 MLIR 应用意义的疑惑</li></ol><p>如果说 编译层 面对的应用所使用的并非 python 程序，而是一种自创的语言，那么应用 MLIR 毋庸置疑，因为没有现成的编译器可以使用。</p><p>但是现在，按照 hk 同学的说法，编译层所面对的就是 python 程序，那为什么不能直接使用 python 解释器来解释执行，这个问题可以从 CGA 的实现方式上去考虑一下（其实目前仍然对 CGA 的表现形式有所疑惑，因为目前可以确定 编译层 所面对的的的确是 python，但是 GraphGenl 是 C++ 实现，当然这个可能并不冲突，因为 GraphGenl 可能仅仅是为了展示一下实现效果，并不一定就是真的 CGA 的应用）。</p><p>我能想到的一点可能的原因是，当前整个项目从最上层的应用层到最底层的芯片设计全覆盖，编译器需要具备面向具体硬件设计编译代码的能力，显然这是现有的 python 解释器所不具备的功能。而这种能力更具像化的来说就是生成面向具体硬件的类汇编代码，这一点是使用现有的 python 解释器无法做到的，可能这就是为什么一定要接入 MLIR。</p><p>之前对于寄存器分配的问题有疑惑，实际上目前现有的编译器，编译后产生的汇编代码显然都是寄存器级别的，那么对于 graph_compiler 来说，本质上也是形成汇编（类汇编）语言，那么加入对于寄存器分配的考虑是显然的。</p><p>实际上很多疑惑都来源于项目定位不清晰，我们如果把所要实现的就简单认为是一个编译器（实际上也是如此），那么需要做的很多事情就都说得通了，不同之处在于当前的编译器实现采用了 MLIR，借助其基础设施来实现一个编译器。</p><h2 id=polygeist>Polygeist</h2><p>Polygeist 是 MLIR 的 C/C++ 前端，用以将原始 C/C++ 转为 MLIR，从而接入 MLIR 生态</p><p>之前一直疑惑，从语言源程序到 MLIR 这个过程是怎么实现的，像 Toy 中是通过代码解析实现的前端，Python 似乎也是通过代码实现的，看来 对于 C/C++ 是有 llvm 工具实现的</p><h2 id=work-plan>work plan</h2><p>我觉得有两方面的入手点吧:</p><ul><li>一是通过 IR Level Examples 来了解从最开始的 MLIR 表达式 是如何经过一层层的 pass，最终到达可执行程序的；</li></ul><p>关于了解 MLIR 语法的作用，我理解的是，因为无论是表达式优化，还是降级，都是基于 MLIR表达式的，所以了解一下终究是有好处的</p><p>2024/03/26 进一步体会到这种好处具体体现在，因为我们自己实现无非就是实现各种 Dialect，实现其中的type，operation等，但是由于和 llvm 源码掺杂在一起，我们既需要了解它们自身的概念，同时还总是在纠结项目的组织结构。</p><p>而实际上，MLIR 中是存在一定量的原生 Dialect、type 和 operation，我们在使用这些内置类型时并不需要纠结它们和项目结构之间有什么关联，我们完全可以把 MLIR 当作一门新的语言去学习，尝试去使用它提供的一些组件，实现我们想要实现的功能。在应用的过程中，你就会发现自己对于其中的各种概念就会熟悉起来，自然就会明白什么位置需要使用什么东西，然后再去结合现实场景，你会发现内置的这些东西不足以表达你想表达的，所以你就会去尝试自行创造一些东西，而这就是我们最终的目的。</p><blockquote><p>优先考虑前进方向固然是重要的，但是也要找准时机动手做起来，在大方向正确的前提下，细微之处是需要通过实践来确定的</p></blockquote><ul><li>二是仿照 Domain-specific Application Level Examples，自行实现一个矩阵乘法（因为我看它里面也是去实现了一些算法）；</li></ul><p>再进阶一点的就是去尝试做一下
<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjY4NTk0NQ==&amp;mid=2247502387&amp;idx=1&amp;sn=3931a608eca05db8de6ca76c1ea8e520&amp;chksm=9f8370a5a8f4f9b32adcba9d2d529279216b60448de9a945eeabf2791673b70e5fdc9cb5e55d&amp;scene=178&amp;cur_album_id=2099721001268740096#rd" target=_blank rel="external nofollow noopener noreferrer">基于MLIR生成矩阵乘法的高性能GPU代码</a></p><p>这是一个相对完整的、具有具体应用场景的端到端编译示例，可以尝试复现一下</p><p>在 buddy-mlir 中，如果想要为上层应用提供接口，不仅需要定义接口数据结构，还需要提供 pass 管理工具 buddy-opt</p><ol><li>构建 budyy-opt 实现 lowering</li><li>添加接口数据结构实现应用示例</li></ol><h3 id=2024411>2024/4/11</h3><p>应该是把 sssp 部分的lowering部分完成就可以，我觉得思路可以参考 bfs 那部分，看看他们都做了什么工作，然后仿照着来做 sssp 部分即可</p><p>现有的编译出来的 graph_compiler 输出信息中显示 Convert DSL To MLIR，而 graph_compiler 的参数又是一个 python 文件，所以可能所谓的 DSL 可能就是这个使用 python 编写的图算法，那么说 graph_compiler 的作用就是把 python 通过一系列 transformation 和 lowering 把 python 转换为 MLIR，不过最后是如何执行起来的还不太懂</p><p>前面的主要任务就是把 graph_compiler 是如何把 python 转换为 MLIR 的这个全流程搞清楚，后面的任务就是考虑仿照着这个流程让 graph_compiler 支持 sssp</p><h3 id=2024428>2024/4/28</h3><p>重点看一下 BFS 算法是如何转换到 CGA 实现的，这样来看就说得通了</p><p>BFS 部分已经调通，即已经将 普通图论算法 转换为 CGA 实现，更重要的是这个转换机制是怎么样的</p><p>我理解有两方面问题：</p><ol><li>传统图论算法 是如何转变为 CGA实现的</li></ol><p>所谓 CGA 实现，简单点来说就是把传统的图论算法转变为 <strong>通过矩阵运算实现</strong>，而这种具体的实现方式，或者说计算模式就被称为 CGA（C: Construct, G: Gather, A: Apply)</p><p>转换为矩阵运算实现，这也就是为什么在整体实现框架中 dialect 被分为了 graph 和 matrix 两级</p><ol start=2><li>CGA实现 如何通过 lowering 和 transformation 对接到 llvm backend 从而执行（这部分需要构建出 compiler_opt 工具）</li></ol><p>这个问题表示的就是具体的代码实现了</p><h2 id=reference>Reference</h2><blockquote><ul><li><p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzA4MjY4NTk0NQ==&amp;action=getalbum&amp;album_id=2099721001268740096&amp;scene=173&amp;subscene=&amp;sessionid=svr_76259f2a30f&amp;enterid=1709891420&amp;from_msgid=2247499828&amp;from_itemidx=1&amp;count=3&amp;nolastread=1#wechat_redirect" target=_blank rel="external nofollow noopener noreferrer">从零开始学习深度学习编译器</a></p></li><li><p><a href=https://github.com/BBuf/tvm_mlir_learn target=_blank rel="external nofollow noopener noreferrer">深度学习编译器资料总结</a></p></li></ul></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://pybind11.readthedocs.io/en/stable/basics.html target=_blank rel="external nofollow noopener noreferrer">pybind11 creating bindings for a simple function</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-05-08 17:26:33">更新于 2024-05-08&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=https://github.com/gaohongy/blog/edit/main/content/posts/Graph-Computing/Graph-Compiler.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/graph-computing/mlir/ class=post-nav-item rel=prev title=MLIR><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>MLIR</a>
<a href=/blog/posts/hpc/memory-alignment/ class=post-nav-item rel=next title="Memory Alignment">Memory Alignment<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/katex/katex.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/copy-tex.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/blog/js/theme.min.js defer></script></body></html>