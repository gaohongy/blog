<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>C++ 对象初始化方式对比 - </title><meta name=author content="ghy"><meta name=author-link content="https://github.com/gaohongy"><meta name=description content="在了解创建对象的方式之前，首先了解一下初始化和赋值两个操作， 初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量 赋值是把对象的当前值"><meta name=keywords content='Hugo,FixIt'><meta itemprop=name content="C++ 对象初始化方式对比"><meta itemprop=description content="在了解创建对象的方式之前，首先了解一下初始化和赋值两个操作， 初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量 赋值是把对象的当前值"><meta itemprop=datePublished content="2023-06-18T17:18:40+08:00"><meta itemprop=dateModified content="2023-06-18T17:18:40+08:00"><meta itemprop=wordCount content="2056"><meta itemprop=keywords content="C-C++"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/c-c++/c++%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/"><meta property="og:title" content="C++ 对象初始化方式对比"><meta property="og:description" content="在了解创建对象的方式之前，首先了解一下初始化和赋值两个操作， 初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量 赋值是把对象的当前值"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-18T17:18:40+08:00"><meta property="article:modified_time" content="2023-06-18T17:18:40+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ 对象初始化方式对比"><meta name=twitter:description content="在了解创建对象的方式之前，首先了解一下初始化和赋值两个操作， 初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量 赋值是把对象的当前值"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/c-c++/c++%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94/><link rel=prev href=https://gaohongy.github.io/blog/posts/compile-link/cmake-make/><link rel=next href=https://gaohongy.github.io/blog/posts/c-c++/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/><link rel=stylesheet href=/blog/css/style.min.css><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blog/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C++ 对象初始化方式对比","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/c-c\u002b\u002b\/c\u002b\u002b%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94\/"},"genre":"posts","wordcount":2056,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/c-c\u002b\u002b\/c\u002b\u002b%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94\/","datePublished":"2023-06-18T17:18:40+08:00","dateModified":"2023-06-18T17:18:40+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ghy"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item><a href=/blog/ title>主页</a></li><li class=breadcrumb-item><a href=/blog/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>C++ 对象初始化方式对比</li></ol></nav><main class=container><aside class=toc id=toc-auto></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>C++ 对象初始化方式对比</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/gaohongy title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202205161528792.jpg data-title=ghy data-alt=ghy class=avatar style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;ghy</a></span>
<span class=post-category>收录于 <a href=/blog/categories/c-c++/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C-C++</a></span></div><div class=post-meta-line><span title="发布于 2023-06-18 17:18:40"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-06-18>2023-06-18</time></span>&nbsp;<span title="更新于 2023-06-18 17:18:40"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-06-18>2023-06-18</time></span>&nbsp;</div></div><div class=content id=content data-end-flag=EOF><p>在了解创建对象的方式之前，首先了解一下<strong>初始化</strong>和<strong>赋值</strong>两个操作，</p><ol><li>初始化是创建变量时赋予其一个初始值，即初始化之前并不存在变量</li><li>赋值是把对象的当前值擦除，用新值代替旧值，即赋值之前存在变量
让人困惑的是<code>=</code>既可以用于初始化，也可以用于赋值，不要认为初始化和赋值是相同的操作</li></ol><p>关于默认值（默认初始化），值和变量类型和位置决定</p><ol><li>函数体外部的内置类型默认初始化为0</li><li>函数体内部的内置类型不被默认初始化，数值为未定义</li></ol><blockquote><p>需要注意的是，这里的函数体是不包括main函数的，实测main函数内部的内置类型即使不被初始化，其值也为0</p></blockquote><p>四种方式分别为 等号，圆括号，花括号,最后一种是等号和花括号一起使用</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>a</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>其中，等号和圆括号是以前就存在的，使用花括号进行初始化或赋值是C++11新标准引入的。
需要理解的是<code>=</code>在这里代表的是初始化而非赋值，而且在实际使用中我们通常会忽略"=&ldquo;和花括号组合初始化的语法，因为C++通常把它视作和只有花括号一样。所以说我们关键要看的就是下面这3种方式。</p><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>a</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>其中，比较难区分的是圆括号和花括号，当然在上述代码中由于他们起到的效果是相同的，因此并不难区分。以vecotr为例，介绍他们的不同之处</p><ol><li>花括号内的值和容器内元素类型相同是为列表初始化，否则根据给定容量和值初始化。即花括号内的内容可以是以下几种类型</li></ol><ul><li>花括号内元素类型均为容器内元素类型</li><li>花括号内元素类型不完全相同 并且顺序为 数字 + 和容器内元素类型相同的元素</li></ul><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v1</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=mi>1</span><span class=p>};</span>       <span class=c1>// 第一种情况，列表初始化，v1包含两个元素10和1
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v2</span><span class=p>{</span><span class=mi>10</span><span class=p>,</span> <span class=s>&#34;1&#34;</span><span class=p>};</span> <span class=c1>// 第二种情况，列表初始化，v2包含10个值为“1”的元素
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>圆括号只能根据给定容量和值进行初始化，即圆括号内的内容只能是以下两种之一</li></ol><ul><li>数字</li><li>数字 + 与容器内类型相同的元素</li></ul><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>vector</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>v3</span><span class=p>(</span><span class=mi>10</span><span class=p>);</span>          <span class=c1>// 正确，v3有10个元素，每个值为默认值0
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v4</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=s>&#34;hi&#34;</span><span class=p>);</span> <span class=c1>// 正确，v4有10个元素，每个值为“hi”
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>vector</span><span class=o>&lt;</span><span class=n>string</span><span class=o>&gt;</span> <span class=n>v5</span><span class=p>(</span><span class=s>&#34;hi&#34;</span><span class=p>);</span>     <span class=c1>// 错误，必须包含数字
</span></span></span></code></pre></td></tr></table></div></div><p>使用花括号具有2个优点:</p><ol><li>防止变窄转换: 大括号不支持变窄转换，等号和圆括号为了向下兼容支持变窄转换。</li></ol><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>long</span> <span class=kt>double</span> <span class=n>ld</span> <span class=o>=</span> <span class=mf>3.1415926</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>{</span><span class=n>ld</span><span class=p>},</span> <span class=n>b</span> <span class=o>=</span> <span class=p>{</span><span class=n>ld</span><span class=p>};</span> <span class=c1>// 错误，因存在变窄转换，花括号初始化禁止这种行为
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=nf>c</span><span class=p>(</span><span class=n>ld</span><span class=p>),</span> <span class=n>d</span> <span class=o>=</span> <span class=n>ld</span><span class=p>;</span>   <span class=c1>// 正确，虽然存在信息丢失，但圆括号和等号并不会禁止这种行为
</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>免疫C++最令人头疼的解析: C++规定任何可以被解析为一个声明的东西必须被解析为声明，因此无法区分无参的构造函数和函数声明，此规则会默认其为函数声明</li></ol><p>花括号初始化共包含2种用途</p><ol><li>变量的列表初始化<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></li></ol><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=p>{</span><span class=mi>0</span><span class=p>};</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span><span class=p>{</span><span class=mi>0</span><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><ol start=2><li>构造函数初始值列表<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></li></ol><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=k>class</span> <span class=nc>myClass</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>b</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=n>myClass</span><span class=p>(</span><span class=kt>int</span> <span class=n>para_a</span><span class=p>,</span> <span class=kt>int</span> <span class=n>para_b</span><span class=p>)</span> <span class=o>:</span> <span class=n>a</span><span class=p>(</span><span class=n>para_a</span><span class=p>),</span> <span class=n>b</span><span class=p>(</span><span class=n>para_b</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl><span class=p>};</span></span></span></code></pre></td></tr></table></div></div><p>构造函数初始值列表由3部分组成：函数头、初始值列表和函数体，成员属性的初始化工作发生在函数体执行之前，因此<strong>初始值列表执行的是初始化，而函数值执行的则是初始化后的赋值</strong>。
在C++中，<strong>const变量</strong>、<strong>引用</strong>和<strong>不具备默认构造函数的类类型</strong>是无法首先进行默认初始化，然后再赋值，因此在这3种情况下，必须使用初始值列表</p><p>同时需要注意的是<strong>初始值列表只用于初始化成员的值，并不会限定初始化的具体执行顺序</strong>，在涉及到用一成员变量的值初始化另一个成员变量的值时要注意执行顺序</p><p>花括号初始化的缺点体现在构造函数的调用顺序方面</p><ol><li>直接初始化
并不能简单地把直接初始化理解为不需要使用现存的占据实际空间的对象来初始化其他对象,因为在示例代码中第2个例子虽然使用到了一个现存的对象dots,但是其依然属于直接初始化</li></ol><details><summary>直接初始化示例代码</summary><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// 好理解的直接初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=nf>dots</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=sc>&#39;.&#39;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 不易理解的直接初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>string</span> <span class=nf>s</span><span class=p>(</span><span class=n>dots</span><span class=p>);</span></span></span></code></pre></td></tr></table></div></div></details><ol start=2><li>拷贝初始化
需要注意的是第1行示例代码同不易理解的直接初始化的区别,虽然两者都利用了现存的对象dots,但是它们属于不同的初始化方式.</li></ol><details><summary>拷贝初始化示例代码</summary><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=n>string</span> <span class=n>s2</span> <span class=o>=</span> <span class=n>dots</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>string</span> <span class=n>s3</span> <span class=o>=</span> <span class=s>&#34;666&#34;</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div></details><p>涉及到拷贝初始化的场景</p><blockquote><ul><li>使用<code>=</code>定义变量时</li><li>一个对象作为非引用类型的形参时</li><li>一个返回值类型非引用类型的函数返回一个对象时</li><li>使用花括号初始化数组或聚合类</li></ul></blockquote><p>直接使用花括号和等号与花括号一同使用是直接初始化还是拷贝初始化?
如果说以stl中的insert/push同emplace相比,前者进行的是拷贝初始化,后者进行的是直接初始化,那么拷贝和直接的区别就在于是否多经历了一次变量的产生过程,因为push需要首先把待插入的对象真正创建出来然后将其拷贝到另一对象中,而emplace则是直接把数据构造成最终对象</p><p>拷贝初始化,拷贝构造函数,拷贝赋值运算符这三者之间的关系容易混淆,
需要明确初始化和赋值的区别,初始化是在对象定义的过程中顺便完成原始值的处理,而赋值是将一个对象赋给一个已存在的对象,初始化的对象是以前不存在的对象,赋值运算符的对象是已经存在的对象</p><p>拷贝初始化和直接初始化的区别是否仅仅是是否生成了中间变量</p><p>拷贝初始化和直接初始化，这两个说法是独立于 类的成员函数这一概念的。拷贝初始化和直接初始化的本质是初始化，强调的是同赋值这一操作之间的区别，但是他们究竟会调用何种类成员函数是不确定的，直接初始化可能调用构造函数，也可能调用拷贝构造函数。</p><h1 id=reference>Reference</h1><blockquote><ul><li>[1] <a href=https://cntransgroup.github.io/EffectiveModernCppChinese/3.MovingToModernCpp/item7.html target=_blank rel="external nofollow noopener noreferrer">区别使用()和{}创建对象</a></li></ul></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p><a href=https://en.cppreference.com/w/cpp/utility/initializer_list target=_blank rel="external nofollow noopener noreferrer">std::initializer_list</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://en.cppreference.com/w/cpp/language/constructor target=_blank rel="external nofollow noopener noreferrer">Constructors and member initializer lists</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-06-18 17:18:40">更新于 2023-06-18&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=https://github.com/gaohongy/blog/edit/main/content/posts/C-C++/C++%e5%af%b9%e8%b1%a1%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%b9%e5%bc%8f%e5%af%b9%e6%af%94.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/compile-link/cmake-make/ class=post-nav-item rel=prev title="CMake Make"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>CMake Make</a>
<a href=/blog/posts/c-c++/c++%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/ class=post-nav-item rel=next title="C++ 类型转换">C++ 类型转换<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/katex/katex.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/blog/js/theme.min.js defer></script></body></html>