<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>C++ Smart Pointer - </title><meta name=author content><meta name=author-link content><meta name=description content="原始指针
  
    
  
要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题"><meta itemprop=name content="C++ Smart Pointer"><meta itemprop=description content="原始指针 要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题"><meta itemprop=datePublished content="2023-06-20T23:04:00+08:00"><meta itemprop=dateModified content="2024-07-18T20:02:23+08:00"><meta itemprop=wordCount content="3723"><meta itemprop=keywords content="C-C++"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/c-c++/c++-smart-pointer/"><meta property="og:title" content="C++ Smart Pointer"><meta property="og:description" content="原始指针 要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-20T23:04:00+08:00"><meta property="article:modified_time" content="2024-07-18T20:02:23+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++ Smart Pointer"><meta name=twitter:description content="原始指针 要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/c-c++/c++-smart-pointer/><link rel=prev href=https://gaohongy.github.io/blog/posts/c-c++/c++-type-conversion/><link rel=next href=https://gaohongy.github.io/blog/posts/linux/comparison-of-shell-script-execution-modes/><link rel=stylesheet href=/blog/css/style.min.css><link rel=preload href=/blog/lib/fontawesome-free/all.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css></noscript><link rel=preload href=/blog/lib/animate/animate.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/animate/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C++ Smart Pointer","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/c-c\u002b\u002b\/c\u002b\u002b-smart-pointer\/"},"genre":"posts","wordcount":3723,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/c-c\u002b\u002b\/c\u002b\u002b-smart-pointer\/","datePublished":"2023-06-20T23:04:00+08:00","dateModified":"2024-07-18T20:02:23+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"Author"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=wide><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png alt=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png data-title=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png width=26 height=26 class=logo style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>Post</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>Category</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>Tag</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder="Search titles or contents ..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png alt=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png data-title=https://img2024.cnblogs.com/blog/1898659/202406/1898659-20240630192930755-1492568318.png width=26 height=26 class=logo style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents ..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>Post</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>Category</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>Tag</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title="Switch Theme"><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=container><aside class="aside-collection animate__animated animate__fadeIn animate__faster" aria-label=Collections></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>C++ Smart Pointer</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><span class=author><i class="fa-solid fa-user-circle" aria-hidden=true></i>
Anonymous</span></span><span class=post-included-in>&nbsp;included in <a href=/blog/categories/c-c++/ class=post-category title="Category - C-C++"><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> C-C++</a></span></div><div class=post-meta-line><span title="published on 2023-06-20 23:04:00"><i class="fa-solid fa-calendar-days fa-fw me-1" aria-hidden=true></i><time datetime=2023-06-20>2023-06-20</time></span>&nbsp;<span title="Updated on 2024-07-18 20:02:23"><i class="fa-regular fa-calendar-check fa-fw me-1" aria-hidden=true></i><time datetime=2024-07-18>2024-07-18</time></span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>Contents</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#原始指针>原始指针</a></li><li><a href=#智能指针说明>智能指针说明</a></li><li><a href=#智能指针初始化>智能指针初始化</a></li><li><a href=#unique_ptr>unique_ptr</a></li><li><a href=#shared_ptr>shared_ptr</a></li><li><a href=#weak_ptr>weak_ptr</a></li><li><a href=#四种指针之间的关系>四种指针之间的关系</a></li><li><a href=#智能指针常用函数和类方法>智能指针常用函数和类方法</a></li><li><a href=#reference>Reference</a></li></ul></nav></div></div><div class=content id=content data-end-flag=EOF><h2 id=原始指针 class=heading-element><span>原始指针</span>
<a href=#%e5%8e%9f%e5%a7%8b%e6%8c%87%e9%92%88 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>要想了解智能指针，就需要首先了解原始指针的痛点，原始指针有几点问题</p><ol><li><p>忘记释放内存 -> 产生内存泄漏</p></li><li><p>在尚有指针引用内存的情况下释放内存（使用已经释放掉的对象） -> 产生引用非法内存的指针</p></li><li><p>同一块内存释放2次</p></li></ol><p>智能指针的产生本质上都是为了解决这些问题</p><p>关于使用new动态分配对象的初始化问题，目前实际编码的结果和书籍内容存在冲突，《C++ Primer》p407 指出<code>int *pi = new int</code>中pi指向一个未初始化的int，其值是未定义，但是从实际编码结果来看，其遵循默认初始化的结果并非未定义，和<code>int a</code>表现出的并不相同（红色标注的位置即为和理解冲突的位置）</p><h2 id=智能指针说明 class=heading-element><span>智能指针说明</span>
<a href=#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%e8%af%b4%e6%98%8e class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li><p>shared_ptr：允许多个指针指向同一个对象</p></li><li><p>unique_ptr：独占所指向的对象</p></li><li><p>weak_ptr：伴随类，一种弱引用，指向shared_ptr管理的对象</p></li></ol><h2 id=智能指针初始化 class=heading-element><span>智能指针初始化</span>
<a href=#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%e5%88%9d%e5%a7%8b%e5%8c%96 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li>默认初始化的智能指针中保存一个空指针</li></ol><h2 id=unique_ptr class=heading-element><span>unique_ptr</span>
<a href=#unique_ptr class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>首先unique_ptr作为智能指针，是在原始指针基础上出现的。原始指针容易出现内存泄漏问题，智能指针利用<a href="https://www.cnblogs.com/hongyugao/p/17489579.html#:~:text=RAII,-Resource%20Acquisition%20Is" target=_blank rel="external nofollow noopener noreferrer">RAII</a>方法来解决这一问题。</p><p>unique_ptr为了避免重复释放（double free）问题出现，禁止拷贝（删除了拷贝构造函数）</p><p>这样的特性带来的问题是无法进行参数传递（因为参数传递需要拷贝构造函数），有两种解决方法</p><p>想要解决这个问题，首先需要理解为什么unique_ptr会禁止拷贝，对一个指针进行拷贝，两个指针指向相同的内存空间，若释放了一个指针，那么会导致另一个指针空悬。</p><p>上述问题出现的原因可以总结为：一份资源的多个备份，在生命周期发生变更时，无法保证数据一致性</p><p>如果说生命周期不发生改变，那么多个备份也是没有问题的，因此在确保函数无需接管资源生命周期的控制权时，可以通过<code>get()</code>方法获取到原始指针，完成函数参数传递</p><p>如果生命周期可能发生变更，那么需要确保资源始终只有一份，那么参数传递可以通过移动语义完成</p><h2 id=shared_ptr class=heading-element><span>shared_ptr</span>
<a href=#shared_ptr class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=k>typename</span><span class=o>&gt;</span> <span class=n>object</span><span class=p>;</span></span></span></code></pre></td></tr></table></div></div><p>unique_ptr虽然解决了原始指针资源易忘记释放的问题，但是为了解决重复释放问题，采用了禁止拷贝的方式，在实际应用场景中较难使用</p><p>因此出现了采用<strong>引用计数</strong>方案的（类似软链接的实现方式，共享Inode，当计数为0时才会真正释放资源）shared_ptr，记录有多少个shared_ptr指向相同对象，在引用计数变为0后，自动释放对象</p><p><code>shared_ptr</code>构造函数是<code>explicit</code>的，因此无法进行隐式类型转换式的初始化，必须通过直接初始化，以下代码展示了这一点</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p1</span> <span class=o>=</span> <span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1024</span><span class=p>);</span> <span class=c1>// 错误，由于explicit的存在，无法进行隐式类型转换式的初始化
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>p2</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1024</span><span class=p>));</span>  <span class=c1>// 正确，可以进行直接初始化
</span></span></span></code></pre></td></tr></table></div></div><p>关于<code>shared_ptr</code>和原始指针</p><p>智能指针和原始指针是可以混合使用的，但由于智能指针的生命周期控制权在于类，而原始指针的控制权在于开发者，当两者混合后，可能会因为生命周期产生一些问题，以以下代码为例进行说明</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>process</span><span class=p>(</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>ptr</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=o>*</span><span class=nf>x</span><span class=p>(</span><span class=k>new</span> <span class=kt>int</span><span class=p>(</span><span class=mi>1024</span><span class=p>));</span>       <span class=c1>// x是一个普通指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>process</span><span class=p>(</span><span class=n>shared_prt</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span><span class=p>));</span> <span class=c1>// 正确，可以用原始指针初始化智能指针
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>j</span> <span class=o>=</span> <span class=o>*</span><span class=n>x</span><span class=p>;</span>                  <span class=c1>// 未定义，x为空悬指针
</span></span></span></code></pre></td></tr></table></div></div><p>shared_ptr利用引用计数对指针生命周期进行控制，直接将shared_ptr指针作为实参和用原始指针初始化得到的shared_ptr作为实参的区别在于引用计数不同，前者引用计数为2，后者仅为1。process函数返回后引用计数分别变为1和0，前者没有问题，后者由于引用计数变为0会将内存释放，原始指针变为空悬指针，解引用操作为未定义行为。</p><blockquote><p>总结来说，由于无法得知智能指针负责的对象何时会释放，因此使用原始指针访问智能指针负责对象是危险行为</p></blockquote><p>一个智能指针是可以获取到一个对应的原始指针的，二者指向相同的内存地址，此时就变为了上述智能指针和原始指针混用的情况，需要注意生命周期问题。</p><p>c++中除了原始指针、shared_pointer和weak_pointer是浅拷贝，unique_pointer禁止拷贝，其他均为深拷贝。</p><h2 id=weak_ptr class=heading-element><span>weak_ptr</span>
<a href=#weak_ptr class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><blockquote><p>weak_ptr是shared_ptr的弱化版本，其不改变引用计数</p></blockquote><p><code>shared_ptr</code>虽然利用引用计数解决了<code>unique_ptr</code>实际应用较困难的问题，但是恰恰是这个机制也为其带来了一些问题。</p><p>若智能指针作为类的成员变量，并且类之间存在一定的从属关系，此时可能会出现循环引用的问题，导致最终资源不会被释放，以以下代码为例</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>m_child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>m_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>child</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>parent</span><span class=o>-&gt;</span><span class=n>m_child</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>child</span><span class=o>-&gt;</span><span class=n>m_parent</span> <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>parent</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>child</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以上代码实现的从属关系如下图所示，</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231243457.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>从上图可以看出，parent和child两片内存区域最初的引用计数均为2</p><p><code>parent = nullptr</code>产生的效果如下图所示，这里要明白parent就是一个指针，赋值为nullptr只是让这个指针不再指向原来的内存区域。只有当这个指针是最后一个指向这片内存区域的指针时，修改其指向才会释放内存区域，由于此时除了parent的指针外，还存在其他指针指向parent对应的内存区域，因此此时内存并不会释放。parent和child内存区域的引用计数分别变为1和2（由于parent指针已经释放，故无法通过该指针获取引用计数值，可以额外创建一个parent指针副本来获取引用计数）</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231441488.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p><code>child = nullptr</code>产生的效果如下图所示，最终parent和child对应内存区域的引用计数分别为1和1，因此对应的内存区域并不会释放。这里比较难理解的是<code>m_parent</code>和<code>m_child</code>是处在结构体当中的，但是<code>parent</code>和<code>child</code>都被赋值为<code>nullptr</code>了，为什么结构体仍然存在。这里parent和child只是一个指向结构体的指针变量，指针变量为nullptr并不代表结构体所占的内存就被释放了，只有当没有指针指向内存区域时，才会释放对应的内存区域。</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231510498.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p>因此最终的结果是，parent和child对应的内存区域均没有释放</p><p>产生上述问题，是由于从属关系混乱导致的，<code>shared_ptr</code>会增加引用计数，这个指针只要存在，指向的资源就不会被释放，类似拥有这个资源的含义，拥有它的所有权。</p><p>在<code>child</code>类中，由于<code>m_parent</code>是<code>shared_ptr</code>指针，这个意思就相当于child拥有parent，显然这是不正确，因此一种解决方式就是把类中<code>m_parent</code>修改为<code>weak_ptr</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;memory&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>C</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>m_child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>weak_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>m_parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>parent</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>shared_ptr</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span> <span class=n>child</span> <span class=o>=</span> <span class=n>std</span><span class=o>::</span><span class=n>make_shared</span><span class=o>&lt;</span><span class=n>C</span><span class=o>&gt;</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>parent</span><span class=o>-&gt;</span><span class=n>m_child</span> <span class=o>=</span> <span class=n>child</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>child</span><span class=o>-&gt;</span><span class=n>m_parent</span> <span class=o>=</span> <span class=n>parent</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>parent</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>child</span> <span class=o>=</span> <span class=k>nullptr</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>此时，代码呈现出的逻辑效果如下图所示，图中实线箭头表示<code>shared_ptr</code>，虚线箭头表示<code>weak_ptr</code>，注意<code>weak_ptr</code>并不影响引用计数。</p><p>此时parent和child对应的内存引用计数分别为1和2</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231709021.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p><code>parent = nullptr</code>之后，由于parent对应内存引用计数变为0，因此此内存区域被释放，parent->m_child指针也被销毁，因此child对应内存区域引用计数变为1。对应结构如下图所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231714049.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><p><code>child = nullptr</code>之，由于此时child指针是最后一个指向child内存区域的指针，当其不再指向这篇内存区域后，引用计数变为0，同时内存区域被释放，效果如下图所示</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png?size=large 2x" data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202306231718768.png style="background:url(/blog/images/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title;for(const e of["style","data-title","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=四种指针之间的关系 class=heading-element><span>四种指针之间的关系</span>
<a href=#%e5%9b%9b%e7%a7%8d%e6%8c%87%e9%92%88%e4%b9%8b%e9%97%b4%e7%9a%84%e5%85%b3%e7%b3%bb class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><p>原始指针和unique_ptr：原始指针可理解为unique_ptr的弱引用</p><p>weak_ptr和shared_ptr：weak_ptr是shared_ptr的弱引用</p><p>由于智能指针会自行进行资源回收，因此访问弱引用时指针可能已经失效，weak_ptr相较于原始指针提供了失效检测功能，当指向内存空间被释放时，不会出现访问错误</p><p>具体是用哪种组合取决于实际的应用场景，在讲述<code>shared_ptr</code>循环引用例子中的<code>parent</code>和<code>child</code>场景描述并不是非常清晰，假设一个<code>parent</code>可能有多个<code>child</code>，那么应当使用<code>shared_ptr</code>和<code>weak_ptr</code>的组合，如果一个<code>parent</code>只能有一个<code>child</code>，那么应当使用<code>unique_ptr</code>和原始指针的组合。</p><h2 id=智能指针常用函数和类方法 class=heading-element><span>智能指针常用函数和类方法</span>
<a href=#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88%e5%b8%b8%e7%94%a8%e5%87%bd%e6%95%b0%e5%92%8c%e7%b1%bb%e6%96%b9%e6%b3%95 class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2><ol><li>shared_ptr</li></ol><table><thead><tr><th style=text-align:left>functions</th><th style=text-align:left>meaning</th></tr></thead><tbody><tr><td style=text-align:left><code>shared_ptr&lt;T> sp</code></td><td style=text-align:left>null intelligence pointer, which can point to a T type object</td></tr><tr><td style=text-align:left><code>make_shared&lt;T>(args)</code></td><td style=text-align:left>use args to initialize a shared_ptr and return it</td></tr><tr><td style=text-align:left><code>shared_ptr&lt;T> p(q)</code></td><td style=text-align:left>p is the copy of shared_ptr q, this operation will increate the counter of q</td></tr><tr><td style=text-align:left><code>p = q</code></td><td style=text-align:left>decrease the reference count of original object of p, increase it of q</td></tr><tr><td style=text-align:left><code>p</code></td><td style=text-align:left>use p for conditional judgement, if p refers to an object, the result is true</td></tr><tr><td style=text-align:left><code>*p</code></td><td style=text-align:left>dereference p, get the object which is refered by p</td></tr><tr><td style=text-align:left><code>p->mem</code></td><td style=text-align:left>equal to (*p).mem</td></tr><tr><td style=text-align:left><code>p.get()</code></td><td style=text-align:left>get origin pointer</td></tr><tr><td style=text-align:left><code>swap(p, q)</code> / <code>p.swap(q)</code></td><td style=text-align:left>exchange the pointer of p and q</td></tr><tr><td style=text-align:left><code>p.use_count()</code></td><td style=text-align:left>get the reference count of intelligence pointer p</td></tr><tr><td style=text-align:left><code>p.unique()</code></td><td style=text-align:left>if the reference count of p equals 1, it returns true, otherwise false</td></tr></tbody></table><ol start=2><li>unique_ptr</li></ol><table><thead><tr><th style=text-align:left>functions</th><th style=text-align:left>meaning</th></tr></thead><tbody><tr><td style=text-align:left><code>unique_ptr&lt;T> up</code></td><td style=text-align:left>null intelligence pointer, which can point to a T type object</td></tr><tr><td style=text-align:left><code>p = q</code></td><td style=text-align:left>decrease the reference count of original object of p, increase it of q</td></tr><tr><td style=text-align:left><code>p</code></td><td style=text-align:left>use p for conditional judgement, if p refers to an object, the result is true</td></tr><tr><td style=text-align:left><code>*p</code></td><td style=text-align:left>dereference p, get the object which is refered by p</td></tr><tr><td style=text-align:left><code>p->mem</code></td><td style=text-align:left>equal to (*p).mem</td></tr><tr><td style=text-align:left><code>p.get()</code></td><td style=text-align:left>get origin pointer</td></tr><tr><td style=text-align:left><code>swap(p, q)</code> / <code>p.swap(q)</code></td><td style=text-align:left>exchange the pointer of p and q</td></tr><tr><td style=text-align:left><code>u = nullptr</code></td><td style=text-align:left>release the object pointed by u and set u to be nullptr</td></tr><tr><td style=text-align:left><code>u.release()</code></td><td style=text-align:left>u gives up the control power to pointer, return the pointer and set u to be nullptr</td></tr><tr><td style=text-align:left><code>u.reset(p)</code></td><td style=text-align:left>if p is nullptr, release the object pointed by u, otherwise release the original object and set u point to p</td></tr></tbody></table><p><strong>How does unique_ptr control to only point to one object ?</strong>
To be precise, one object can be pointed by multiple unique_ptr, but it will cause some errors, so we say unique_ptr is not allowed to point to multiple objects.
The reason is that unique_ptr doesn&rsquo;t use the count to memorize the object number which is pointed by intelligence pointer, so if code leave the action scope, the unique_ptr will release the source, if one object is pointed by multiple unique_ptr, it will cause repeated release, so we say unique_ptr can&rsquo;t point to multiple objects.</p><p><strong>A falliable point</strong>
In my previous understanding, a null pointer, which type is MyClass, can&rsquo;t call functions of MyClass. If we do it, we will get a Segmentation fault error.
But when a unique_ptr which value is nullptr, it can also call the get() function, and the result is also nullptr.</p><blockquote><p>To be honest, I don&rsquo;t know its principle now.</p></blockquote><ol start=3><li>weak_ptr</li></ol><table><thead><tr><th style=text-align:left>functions</th><th style=text-align:left>meaning</th></tr></thead><tbody><tr><td style=text-align:left><code>weak_ptr&lt;T> w</code></td><td style=text-align:left>null intelligence pointer, which can point to a T type object</td></tr><tr><td style=text-align:left><code>weak_ptr&lt;T> w(sp)</code></td><td style=text-align:left>w is a weak_ptr which points to a object that is same as shared_ptr sp</td></tr><tr><td style=text-align:left><code>w = p</code></td><td style=text-align:left>p is a shared_ptr or a weak_ptr</td></tr><tr><td style=text-align:left><code>w.reset()</code></td><td style=text-align:left>set w to be nullptr</td></tr><tr><td style=text-align:left><code>w.use_count()</code></td><td style=text-align:left>return the count of shared_ptr which shares the same object with w</td></tr><tr><td style=text-align:left><code>w.expired()</code></td><td style=text-align:left>if w.use_count() equals 0, it will return true, otherwise return false</td></tr><tr><td style=text-align:left><code>w.lock()</code></td><td style=text-align:left>if w.expired() return true, return a null shared_ptr, otherwise return a shared_ptr which points to w</td></tr></tbody></table><h2 id=reference class=heading-element><span>Reference</span>
<a href=#reference class=heading-mark><svg class="octicon octicon-link" viewBox="0 0 16 16" width="16" height="16" aria-hidden="true"><path d="m7.775 3.275 1.25-1.25a3.5 3.5.0 114.95 4.95l-2.5 2.5a3.5 3.5.0 01-4.95.0.751.751.0 01.018-1.042.751.751.0 011.042-.018 1.998 1.998.0 002.83.0l2.5-2.5a2.002 2.002.0 00-2.83-2.83l-1.25 1.25a.751.751.0 01-1.042-.018.751.751.0 01-.018-1.042zm-4.69 9.64a1.998 1.998.0 002.83.0l1.25-1.25a.751.751.0 011.042.018.751.751.0 01.018 1.042l-1.25 1.25a3.5 3.5.0 11-4.95-4.95l2.5-2.5a3.5 3.5.0 014.95.0.751.751.0 01-.018 1.042.751.751.0 01-1.042.018 1.998 1.998.0 00-2.83.0l-2.5 2.5a1.998 1.998.0 000 2.83z"/></svg></a></h2></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="Updated on 2024-07-18 20:02:23">Updated on 2024-07-18&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>Back</a></span>&nbsp;|&nbsp;<span><a href=/blog/>Home</a></span></section></div><div class=post-nav><a href=/blog/posts/c-c++/c++-type-conversion/ class=post-nav-item rel=prev title="C++ Type Conversion"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>C++ Type Conversion</a>
<a href=/blog/posts/linux/comparison-of-shell-script-execution-modes/ class=post-nav-item rel=next title="Comparison of Shell Script Execution Modes">Comparison of Shell Script Execution Modes<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article><aside class=toc id=toc-auto aria-label=Contents><h2 class=toc-title>Contents&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label="Back to Top"><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>This website works best with JavaScript enabled.</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=preload href=/blog/lib/katex/katex.min.css as=style onload='this.removeAttribute("onload"),this.rel="stylesheet"'><noscript><link rel=stylesheet href=/blog/lib/katex/katex.min.css></noscript><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/copy-tex.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"Got it!",link:"Learn more",message:"This website uses Cookies to improve your experience."},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"No results found",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0,version:"v0.3.9"}</script><script src=/blog/js/theme.min.js defer></script></body></html>