<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>NP完全性分析 - </title><meta name=author content="ghy"><meta name=author-link content="https://github.com/gaohongy"><meta name=description content="NP完全性的核心逻辑 NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单 有多项式时间算法的问题称为易解的，不存在多项式时间算法的问"><meta name=keywords content='Hugo,FixIt'><meta itemprop=name content="NP完全性分析"><meta itemprop=description content="NP完全性的核心逻辑 NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单 有多项式时间算法的问题称为易解的，不存在多项式时间算法的问"><meta itemprop=datePublished content="2023-11-26T12:58:07+08:00"><meta itemprop=dateModified content="2023-12-24T17:07:01+08:00"><meta itemprop=wordCount content="3531"><meta itemprop=keywords content="Algorithm"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/algorithm/np-completeness/"><meta property="og:title" content="NP完全性分析"><meta property="og:description" content="NP完全性的核心逻辑 NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单 有多项式时间算法的问题称为易解的，不存在多项式时间算法的问"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-26T12:58:07+08:00"><meta property="article:modified_time" content="2023-12-24T17:07:01+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="NP完全性分析"><meta name=twitter:description content="NP完全性的核心逻辑 NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单 有多项式时间算法的问题称为易解的，不存在多项式时间算法的问"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/algorithm/np-completeness/><link rel=prev href=https://gaohongy.github.io/blog/posts/linux/variables-in-linux/><link rel=next href=https://gaohongy.github.io/blog/posts/computer-architecture/computer-architecture/><link rel=stylesheet href=/blog/css/style.min.css><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blog/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"NP完全性分析","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/algorithm\/np-completeness\/"},"genre":"posts","wordcount":3531,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/algorithm\/np-completeness\/","datePublished":"2023-11-26T12:58:07+08:00","dateModified":"2023-12-24T17:07:01+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ghy"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item><a href=/blog/ title>主页</a></li><li class=breadcrumb-item><a href=/blog/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>NP完全性分析</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>NP完全性分析</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/gaohongy title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202205161528792.jpg data-title=ghy data-alt=ghy class=avatar style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;ghy</a></span>
<span class=post-category>收录于 <a href=/blog/categories/algorithm/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Algorithm</a></span></div><div class=post-meta-line><span title="发布于 2023-11-26 12:58:07"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-11-26>2023-11-26</time></span>&nbsp;<span title="更新于 2023-12-24 17:07:01"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2023-12-24>2023-12-24</time></span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#np完全性的核心逻辑>NP完全性的核心逻辑</a></li><li><a href=#性质>性质</a></li><li><a href=#问题的分类>问题的分类</a><ul><li><a href=#npc问题>NPC问题</a></li><li><a href=#nph问题>NPH问题</a></li></ul></li><li><a href=#计算复杂度>计算复杂度</a></li><li><a href=#证明>证明</a></li><li><a href=#如何解决-npc-问题>如何解决 NPC 问题</a></li><li><a href=#证明问题是-npc-问题的关键步骤>证明问题是 NPC 问题的关键步骤</a></li></ul></nav></div></div><div class=content id=content data-end-flag=EOF><h2 id=np完全性的核心逻辑>NP完全性的核心逻辑</h2><p>NP完全问题是为了反映一个问题有多难，而不是为了反应它有多简单</p><p>有多项式时间算法的问题称为易解的，不存在多项式时间算法的问题成为难解的（这里的多项式时间算法包含确定型图灵机多项式时间算法，也包含非确定性图灵机多项式算法）</p><h2 id=性质>性质</h2><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240911191.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312240949111.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=问题的分类>问题的分类</h2><ol><li>最优化问题(optimization problem)</li><li>判定问题(decision problem)
两类问题的关联在于：通常，通过对待优化的值强加一个界，就可以将一个给定的最优化问题转化为一个相关的判定问题了。同时从直观上来看，如果最优化问题容易，则对应的判定问题也是容易的。换言之，如果我们能够证明判定问题是困难的，则相当于也说明了对应的最优化问题是困难的.</li></ol><h3 id=npc问题>NPC问题</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241020579.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p><strong>相关问题描述</strong></p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241042951.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p><strong>问题描述三部曲</strong>：1.有什么 2.找什么 3.目的是什么</p><ol><li>顶点覆盖</li></ol><blockquote><p>存在一个顶点集包含所有边中的至少一个顶点</p></blockquote><p>V, E, k, 找V'</p><blockquote><ul><li>给定图G=(V, E), 正整数$K \le \left| V \right|$</li><li>是否存在V的一个子集V&rsquo;, $\left| V&rsquo; \right| \le K$</li><li>s.t. V&rsquo;包含图G任何一条边中至少一个顶点</li></ul></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241108839.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=2><li>相遇集</li></ol><blockquote><p>存在一个集合的子集包含原集合的子集族中每一个子集中的至少一个元素</p></blockquote><p>S, C, K, 找S'</p><blockquote><ul><li>给定集合S, S的子集族C, 正胜数$K \le \left| S \right|$</li><li>是否存在S的一个子集S&rsquo;, $\left| S&rsquo; \right| \le K$</li><li>s.t. S&rsquo;与C中任何一个子集的交集非空</li></ul></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241111499.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=3><li>划分问题</li></ol><blockquote><p>集合划分成两部分，两部分元素的权值和相等</p></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241402576.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=4><li>01整数规划问题</li></ol><p>关键是记住
$$
Ax \le b \
C^Tx \ge D
$$</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241404533.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=5><li>独立集 / 团</li></ol><p>无需记忆问题描述，只需要知道独立集和团都是点集。</p><ul><li>独立集这个点集中，任意两个顶点均不相邻</li><li>团这个点集中，任意两个顶点均相邻</li></ul><p>补图和原图的顶点没变，补图中两个顶点之间有边（相邻）当且仅当原图中这两个顶点之间没边（不相邻）</p><ol start=6><li>哈密顿回路问题</li></ol><blockquote><ul><li>给定图G=(V, E)</li><li>是否存在节点的一个排列</li><li>s.t. 存在包含全部节点的一条回路</li></ul></blockquote><ol start=7><li>旅行商判定问题</li></ol><blockquote><ul><li>给定一个城市集合C, 每对城市之间的距离d，正整数D</li><li>是否存在一个C中城市的排列</li><li>s.t. 排列形成一个回路，距离和$\le D$</li></ul></blockquote><ol start=8><li>0/1背包判定问题</li></ol><blockquote><p>总容量不超过某值情况下，总价值能否超过一个值</p></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202312241535988.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=nph问题>NPH问题</h3><ol><li>旅行商问题（TSP）</li><li>0/1背包问题</li></ol><p><strong>为什么如何重视判定问题 ？</strong>
无论是何种问题，关于P,NP,NPC,NPH都是在考虑如何描述解决问题的难易程度，这是这一章的核心逻辑
最优化问题或者说搜索问题，都可以比较简单的对应到一个判定问题，因此最优化问题易解->判定问题易解，逆反命题自然成立。而这种所谓的对应，专业的描述就是多项式时间变换，或者说属于归约操作</p><blockquote><p>关于这一内容，出自《算法设计与分析（第2版）》屈老师的那一本书，由最优化问题->对应的判定问题是最开始讲述这类问题时进行的一种操作，这个准确来说叫做归约。而多项式时间变化是证明NPC或者NPH时的说法，不过多项式时间变换也是归约的一种</p></blockquote><p>简单来说，判定问题的定义是明确且易表达易理解的，同时最优化问题是容易转换为判定问题的。</p><p>不过有一个疑问是为何只考虑最优化问题，在课程中提及的问题都是最优化问题，而是书籍中给出的示例一般也是最优化问题，但是一半问题中并非仅仅是最优化问题，不过似乎都是易转换为判定问题的</p><h2 id=计算复杂度>计算复杂度</h2><p>两个重要工作：</p><ol><li><p>确定问题计算复杂度的一个上界</p></li><li><p>确定问题计算复杂度的一个下界</p></li><li><p>以比较为基础的检索问题的时间下界$\Omega(logn)$</p></li><li><p>以比较为基础的排序问题时间下界$\Omega(nlogn)$</p></li><li><p>找最大值时间下界$\Omega(n-1)$</p></li><li><p>找最大值和最小值时间下界$\Omega(\lceil \frac{3n}{2} \rceil - 2)$ (分治)</p></li><li><p>找次大值时间下界$\Omega(n + \lceil logn \rceil - 2)$ （锦标赛算法，首先找最大值下界为$n - 1$，树形结构中在输于最大值的元素中找次大值时间下界$\lceil logn \rceil - 1$）</p></li><li><p>找中位数时间下界$\Omega(\frac{3n}{2} - \frac{3}{2})$</p></li><li><p>找第k小值时间下界$\Omega(n + min(k, n - k +1) - 2)$</p></li></ol><h2 id=证明>证明</h2><p>所有多项式时间内可验证的问题组成了NP类问题，其中能够在多项式时间内求解的为P类问题，能够由其他NPC问题归约得到的是NPC问题</p><p>P : 多项式时间内可求解，存在确定型多项式时间算法</p><p>NP：多项式时间内可验证，存在非确定型多项式时间算法（随便猜一种情况然后验证，把所有情况猜完一定可以找到解）</p><p>证明问题是NP的，根本上来说就是判断是否存在一种非确定型多项式时间算法能够求解出答案，对于这种算法的描述可以用猜想和验证两个阶段来表述。而这种算法是多项式时间的等价于猜想和验证环节都是多项式时间的，而且猜想和验证都只是需要考虑一个实例要如何处理。如果说总共需要猜想和验证的实例数是指数级($2^n$)，但是一个实例的猜想和验证都只是需要多项式时间，那么这种算法依然是多项式时间的，因为非确定型多项式时间算法是跑在NDTM非确定型图灵机上的，是可以并行的。举一个验证阶段无法在多项式时间内完成的例子，旅行商问题，对于旅行商问题的一个实例（注意是旅行商问题，不是旅行商的判定问题），验证环节需要和其他所有回路进行比较，而其他回路数量是指数级的，所以验证环节是无法在多项式时间内完成的（如果是旅行商的判定问题，验证环节是可以在多项式时间内完成的）。</p><p>NPC: 首先需要是NP，然后找到另一种NPC问题可以转化到当前问题</p><blockquote><p>为什么需要保证是NP？因为如果当前问题可以从另外一种NPC多项式时间内变换得到，只能说明当前问题不比那个NPC问题简单，有两种可能：1.NPC，2.非NPC的NPH，只有当时NP时才能保证是前者而非后者</p></blockquote><ol><li><p>给出已知NPC问题实例</p></li><li><p>给出待证明问题示例</p></li><li><p>说明<strong>最优化问题的原问题</strong>是NP的(存在一种多项式时间内猜想和多项式时间的验证方法可以得到问题的解，即存在非确定型多项式时间算法，其中非确定型是指需要猜想这个环节)</p></li><li><p>说明从一个已知的 <strong>NPC 问题的判定问题</strong>可以多项式时间归约到<strong>原问题的判定问题</strong></p></li></ol><p>4.1 构造一个待证明问题的示例</p><p>4.2 假设前一个问题可取得解，证明后一个问题同样存在解</p><p>4.3 假设后一个问题可取得解，证明前一个问题同样存在解</p><p>4.4 说明一下变换可以在多项式时间内完成</p><p>NPH: 首先判断是否为NP问题，如果是NP问题同时还是NPH问题那就只能是NPC问题，如果不是NP问题那就是非NPC的NPH问题，需要保证任意一个NP能够转化到当前问题(显然这是困难的，需要用到NPC的定义来实现)</p><ol><li>说明问题不是NP的（验证环节无法在多项式时间内完成）</li><li>说明问题的难度不低于NPC</li></ol><blockquote><p>第2步的具体方法目前考虑到的可能有2种：</p><ol><li>原问题的判定问题是NPC的，则说明原问题难度不低于NPC</li><li>存在一个已知的NPC问题可以多项式时间变换到当前问题</li></ol></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311261959462.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=如何解决-npc-问题>如何解决 NPC 问题</h2><ol><li>如果实际输入数据规模较小，则 指数级运行时间的算法 可解决问题</li><li>对于一些能在多项式时间内解决的特殊情况，可以单独求解</li><li>寻找一些能够在多项式时间内得到 <a href>近似最优解</a></li></ol><h2 id=证明问题是-npc-问题的关键步骤>证明问题是 NPC 问题的关键步骤</h2><ol><li>判定问题与最优化问题
NP 完全性不适合直接应用于最优化问题，但适合应用于判定问题</li></ol><p>关于这一点最直观的理解方式就是看NPC问题的证明</p><p>假设现在要证明一个最优化问题是NPC的，那么第1步中会证明该问题是NP的，此时存在一种非确定型多项式时间算法可以在多项式时间内完成猜想，以及多项式时间内完成验证，从而确定猜想到的解是不是一个合法解。在这一步中，无论是算法还是验证过程，都像是在处理原问题的判定问题。但是不要忽略了，只要我们可以在多项式时间内验证一个解，那么只要所有可能猜到的解中包含最终答案，理论上我们就可以得到这个最终答案并且完成验证过程，这个时候原问题就已经得到解了，那这种猜想验证的算法实际就已经解决了原问题。（回过头来看，在这一部分最后一般会添加一句话“能猜到一个xxx当且仅当yyy中存在一个xxx“，这句话并不是废话，它保证了这种算法在理论上是可以在所有可能的情况中找到一个解的）</p><p>第2步会去证明是一个NPC问题，这里证明的并不是原问题那个最优化问题，而是最优化问题对应的判定问题，最后通过判定问题和原问题的难度关系，由于判定问题是NPC，那么原问题是不比NPC简单的问题，结合上述是NP问题，就能够说明是NPC问题了。</p><p>根据上述分析，虽然我们要证明的是最优化问题是NPC问题，但是完全可以看为要证明的是最优化问题的判定问题是NPC问题。因为第2步证明的确实就是判定问题是NPC问题，第1步给出的算法本身也是判定问题的形式（判定问题的形式，但是结合上猜想可以解决最优化问题本身）。所以只需要关注判定问题是什么即可。</p><ol start=2><li>归约</li></ol><p>a.实例的概念: 实例是指某一特定问题的输入</p><p>b.多项式时间归约算法：一个多项式归约算法可以在多项式时间内，将A的任何实例a转化为B的实例b，a和b是相同(a为“是”时，b也为“是”)</p><p>c.多项式时间归约的目的：A 和 B 之间的 ”易求解性“ 或 ”难求解性“ 是相同的，可通过一个问题的性质推导另一个问题的性质</p><ol start=3><li>第一个 NPC 问题</li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2023-12-24 17:07:01">更新于 2023-12-24&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=https://github.com/gaohongy/blog/edit/main/content/posts/Algorithm/NP-Completeness.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/linux/variables-in-linux/ class=post-nav-item rel=prev title="Variables in Linux"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Variables in Linux</a>
<a href=/blog/posts/computer-architecture/computer-architecture/ class=post-nav-item rel=next title="Computer Architecture">Computer Architecture<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/katex/katex.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/copy-tex.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/blog/js/theme.min.js defer></script></body></html>