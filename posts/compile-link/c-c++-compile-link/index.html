<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=2"><meta name=robots content="noodp"><title>C C++ Compile Link - </title><meta name=author content="ghy"><meta name=author-link content="https://github.com/gaohongy"><meta name=description content="名词辨析 GNU GNU&rsquo;s Not Unix!的递归缩写 一个自由的操作系统,起源于GNU计划,希望发展出一套完整的开放源代码操作系统来取代Unix 基本组成包括： G"><meta name=keywords content='Hugo,FixIt'><meta itemprop=name content="C C++ Compile Link"><meta itemprop=description content="名词辨析 GNU GNU’s Not Unix!的递归缩写 一个自由的操作系统,起源于GNU计划,希望发展出一套完整的开放源代码操作系统来取代Unix 基本组成包括： G"><meta itemprop=datePublished content="2023-12-31T21:54:31+08:00"><meta itemprop=dateModified content="2024-04-20T00:51:53+08:00"><meta itemprop=wordCount content="7697"><meta itemprop=keywords content="Compile-Link"><meta property="og:url" content="https://gaohongy.github.io/blog/posts/compile-link/c-c++-compile-link/"><meta property="og:title" content="C C++ Compile Link"><meta property="og:description" content="名词辨析 GNU GNU’s Not Unix!的递归缩写 一个自由的操作系统,起源于GNU计划,希望发展出一套完整的开放源代码操作系统来取代Unix 基本组成包括： G"><meta property="og:locale" content="zh_CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-31T21:54:31+08:00"><meta property="article:modified_time" content="2024-04-20T00:51:53+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="C C++ Compile Link"><meta name=twitter:description content="名词辨析 GNU GNU’s Not Unix!的递归缩写 一个自由的操作系统,起源于GNU计划,希望发展出一套完整的开放源代码操作系统来取代Unix 基本组成包括： G"><meta name=application-name content="FixIt"><meta name=apple-mobile-web-app-title content="FixIt"><meta name=theme-color data-light=#f8f8f8 data-dark=#252627 content="#f8f8f8"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=canonical href=https://gaohongy.github.io/blog/posts/compile-link/c-c++-compile-link/><link rel=prev href=https://gaohongy.github.io/blog/posts/algorithm/branch-bound-algorithm/><link rel=next href=https://gaohongy.github.io/blog/posts/hpc/kokkos-source-code-analysis/><link rel=stylesheet href=/blog/css/style.min.css><link rel=stylesheet href=/blog/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/blog/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"C C++ Compile Link","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/gaohongy.github.io\/blog\/posts\/compile-link\/c-c\u002b\u002b-compile-link\/"},"genre":"posts","wordcount":7697,"url":"https:\/\/gaohongy.github.io\/blog\/posts\/compile-link\/c-c\u002b\u002b-compile-link\/","datePublished":"2023-12-31T21:54:31+08:00","dateModified":"2024-04-20T00:51:53+08:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"ghy"},"description":""}</script></head><body data-header-desktop=sticky data-header-mobile=auto><script>(window.localStorage?.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("data-theme","dark")</script><div class=wrapper data-page-style=normal><header class="desktop animate__faster" id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><nav><ul class=menu><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item delimiter"></li><li class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容…… id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></li><li class="menu-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></li></ul></nav></div></header><header class="mobile animate__faster" id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301210616317.png class=logo style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'><span class=header-title-text></span></a><span class=header-subtitle></span></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><nav><ul class=menu id=menu-mobile><li class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容…… id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fa-solid fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fa-solid fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fa-solid fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></li><li class=menu-item><a class=menu-link href=/blog/posts/>文章</a></li><li class=menu-item><a class=menu-link href=/blog/categories/>分类</a></li><li class=menu-item><a class=menu-link href=/blog/tags/>标签</a></li><li class="menu-item menu-system"><span class="menu-system-item theme-switch" title=切换主题><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></span></li></ul></nav></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><nav aria-label=breadcrumb class=breadcrumb-container><ol class=breadcrumb><li class=breadcrumb-item><a href=/blog/ title>主页</a></li><li class=breadcrumb-item><a href=/blog/posts/ title=Posts>Posts</a></li><li class="breadcrumb-item active" aria-current=page>C C++ Compile Link</li></ol></nav><main class=container><aside class=toc id=toc-auto><h2 class=toc-title>目录&nbsp;<i class="toc-icon fa-solid fa-angle-down fa-fw" aria-hidden=true></i></h2><div class="toc-content always-active" id=toc-content-auto></div></aside><aside class=aside-custom></aside><article class="page single"><div class=header><h1 class="single-title animate__animated animate__flipInX"><span>C C++ Compile Link</span></h1></div><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://github.com/gaohongy title=作者 target=_blank rel="external nofollow noopener noreferrer author" class=author><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202205161528792.jpg data-title=ghy data-alt=ghy class=avatar style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'>&nbsp;ghy</a></span>
<span class=post-category>收录于 <a href=/blog/categories/compile-link/><i class="fa-regular fa-folder fa-fw" aria-hidden=true></i> Compile-Link</a></span></div><div class=post-meta-line><span title="发布于 2023-12-31 21:54:31"><i class="fa-regular fa-calendar-alt fa-fw me-1" aria-hidden=true></i><time datetime=2023-12-31>2023-12-31</time></span>&nbsp;<span title="更新于 2024-04-20 00:51:53"><i class="fa-regular fa-edit fa-fw me-1" aria-hidden=true></i><time datetime=2024-04-20>2024-04-20</time></span>&nbsp;</div></div><div class="details toc" id=toc-static data-kept=false><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fa-solid fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#名词辨析>名词辨析</a><ul><li><a href=#gnu>GNU</a></li><li><a href=#gcc>GCC</a></li><li><a href=#gccgmingw>gcc/g++/MinGW</a></li><li><a href=#msvc>MSVC</a></li><li><a href=#llvm>LLVM</a></li><li><a href=#clangclang>clang/clang++</a></li><li><a href=#make>Make</a></li><li><a href=#cmake>CMake</a></li><li><a href=#ninja>Ninja</a></li></ul></li><li><a href=#编译流程>编译流程</a><ul><li><a href=#预处理预编译>预处理(预编译)</a></li><li><a href=#编译>编译</a></li><li><a href=#汇编>汇编</a></li><li><a href=#链接>链接</a><ul><li><a href=#相关概念解析>相关概念解析</a></li><li><a href=#静态链接库>静态链接库</a></li><li><a href=#动态链接库>动态链接库</a><ul><li><a href=#动态链接包含2个链接过程>动态链接包含2个链接过程</a></li><li><a href=#在编译时已经通过-l指定了库的搜索路径为何此时仍然找不到>在编译时已经通过<code>-L.</code>指定了库的搜索路径，为何此时仍然找不到?</a></li><li><a href=#动态链接器如何查找到所需的库文件dynamic_linker_search_way_of_libraries>动态链接器如何查找到所需的库文件?</a></li><li><a href=#动态链接库在构建和执行过程中的参与情况示意图>动态链接库在构建和执行过程中的参与情况示意图</a></li></ul></li></ul></li></ul></li><li><a href=#reference>Reference</a></li></ul></nav></div></div><div class=content id=content data-end-flag=EOF><h2 id=名词辨析>名词辨析</h2><h3 id=gnu>GNU</h3><ul><li>GNU&rsquo;s Not Unix!的递归缩写</li><li>一个自由的<strong>操作系统</strong>,起源于GNU计划,希望发展出一套完整的开放源代码操作系统来取代Unix</li><li>基本组成包括：<ul><li><a href>GNU编译器套装（GCC）</a></li><li>GNU的C库（glibc）</li><li>GNU核心工具组（coreutils）</li></ul></li></ul><h3 id=gcc>GCC</h3><ul><li><a href=https://gcc.gnu.org/index.html target=_blank rel="external nofollow noopener noreferrer">GNU Compiler Collection</a>, GNU编译器套装，最初是为了GNU操作系统而编写的编译器。</li><li>有多种<a href=https://www.cnblogs.com/G-H-Y/p/17061801.html target=_blank rel="external nofollow noopener noreferrer">语言前端</a>，可用于解析不同的编程语言、操作系统、计算机系统结构，是GNU计划的关键部分，也是GNU工具链的主要组成部分之一</li><li>可以编译C、C++、JAV、Fortran、Pascal、Object-C、Ada，Go等语言</li></ul><h3 id=gccgmingw>gcc/g++/MinGW</h3><ul><li>gcc: GCC中的GUN C Compiler（C 编译器）</li><li>g++: GUN C++ Compiler（C++编译器）</li><li>MinGW: Minimalist GNU for Windows，是将GCC编译器和GNU Binutils移植到Win32平台下的产物</li></ul><p>但根据<a href=https://www.cnblogs.com/samewang/p/4774180.html target=_blank rel="external nofollow noopener noreferrer">GCC的gcc和g++区别</a>的说法，gcc和g++并不是编译器，它们只是一种驱动器<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>，它们会根据参数中要编译的文件的类型，调用对应的GUN编译器。以编译C语言为例，包含以下过程。</p><blockquote><p>Step1：Call a preprocessor, like cpp.</p><p>Step2：Call an actual compiler, like cc or cc1.</p><p>Step3：Call an assembler, like as.</p><p>Step4：Call a linker, like ld</p></blockquote><p>因此gcc命令只是上述后台程序的包装，根据不同的参数调用不同的程序，例如预编译程序、编译器、汇编器和链接器</p><p><strong>两者的联系和区别</strong><sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup></p><blockquote><p>对于 *.c文件，gcc当做c文件看待，g++当做cpp文件看待</p></blockquote><p>虽然gcc和g++都可以编译*.c文件，但是二者会以不同的语言来对待c文件，而C++ 标准和 C 语言标准的语法要求是有区别的。</p><div class=highlight id=id-1><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=c1>#include &lt;stdio.h&gt;</span>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=n>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=n>char</span> <span class=o>*</span> <span class=n>a</span> <span class=o>=</span> <span class=s2>&#34;abc&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>printStr</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=ne>int</span> <span class=n>printStr</span><span class=p>(</span><span class=k>const</span> <span class=n>char</span><span class=o>*</span> <span class=nb>str</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>printf</span><span class=p>(</span><span class=nb>str</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>以上代码使用gcc进行编译，其会看为c语言，编译结果为</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200805118.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>以上代码使用g++进行编译，其会看为c++，编译结果为</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301200806353.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>由此可见，c++的语言要求会更高一些</p><blockquote><p>对于 *.cpp文件，gcc当做cpp文件看待，g++当做cpp文件看待</p></blockquote><p>虽然二者都会以cpp文件来对待，但是对于调用某些标准库中现有的函数或者类对象的c++程序，而单纯的 gcc 命令无法自动链接这些标准库文件，无法完成编译，需要手动链接 C++ 标准库，例如 <code>gcc -lstdc++</code></p><h3 id=msvc>MSVC</h3><ul><li>Microsoft Visual C++，is a compiler for the C, C++ and C++/CX programming languages by Microsoft</li></ul><h3 id=llvm>LLVM</h3><p>LLVM最初是指Low Level Virtual Machine，是类似但不同于jvm的一种虚拟机，现在来说，有很多理解方式，可以说LLVM是编译器的工具链的<a href=https://llvm.org/docs/CommandGuide/ target=_blank rel="external nofollow noopener noreferrer">集合</a>，Clang是使用LLVM的编译器；又或者说LLVM是一个优秀的编译器框架，它也采用经典的三段式设计
根据<a href=https://www.cnblogs.com/G-H-Y/p/17061801.html target=_blank rel="external nofollow noopener noreferrer">编译原理</a>可以了解到，在GCC中前端和后端的分界并非明显，这就导致出现下面的情况，一种语言的前端对对应多个后端
<a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201625299.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a>
而LLVM架构通过引入<code>LLVM IR</code>(Intermediate Representation)解决了这一问题，形成的LLVM架构如下图所示
<a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301201629881.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=clangclang>clang/clang++</h3><p>是LLVM项目中的一个子项目，是基于LLVM架构的轻量级编译器，属于整个LLVM架构中的<a href=https://www.cnblogs.com/G-H-Y/p/17061801.html target=_blank rel="external nofollow noopener noreferrer">编译器前端</a>(由LLVM架构图可得知)
创造目的是为了替代GCC，提供更快的编译速度</p><h3 id=make>Make</h3><p><code>make</code>工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式—通过调用makefile文件中用户指定的命令利用<code>gcc(或g++)</code>来进行编译和链接。当程序只有一个源文件时，可以直接使用用<code>gcc(或g++)</code>命令进行编译。但当程序包含多个源文件时，逐文件去编译，编译顺序可能出现混乱同时工作量较大</p><h3 id=cmake>CMake</h3><p>makefile在一些简单的工程中可以人工书写，但当工程较大时，手写makefile较为麻烦，同时更换平台需要修改makefile,cmake工具可以根据CMakeLists.txt文件去生成makefile，过程如下图所示
<a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/20211102161633.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>More details can be found in <a href=https://gaohongy.github.io/blog/posts/compile_link/cmake/ target=_blank rel="external nofollow noopener noreferrer">CMake Knowledges Summary</a></p><blockquote><p><strong>参考</strong></p><ul><li>[1] <a href=https://blog.csdn.net/qq_43617936/article/details/104504992 target=_blank rel="external nofollow noopener noreferrer">GNU的发展史</a></li><li>[2] <a href=https://www.cnblogs.com/samewang/p/4774180.html target=_blank rel="external nofollow noopener noreferrer">GCC的gcc和g++区别</a></li><li>[3] <a href=https://www.linuxidc.com/Linux/2019-01/156200.htm target=_blank rel="external nofollow noopener noreferrer">编译器 cc、gcc、g++、CC 的区别</a></li><li>[4] <a href=https://www.linuxidc.com/Linux/2018-10/155027.htm target=_blank rel="external nofollow noopener noreferrer">Linux环境中gcc和g++的区别详解</a></li><li>[5] <a href=https://www.cnblogs.com/Fingerprint/p/11249709.html target=_blank rel="external nofollow noopener noreferrer">GCC、LLVM、Clang区别</a></li><li>[6] <a href=https://www.cnblogs.com/findumars/p/14213309.html target=_blank rel="external nofollow noopener noreferrer">业界主流3大编译器</a></li><li>[7] <a href=https://zhuanlan.zhihu.com/p/448884264 target=_blank rel="external nofollow noopener noreferrer">区分gnu的gcc/g++, mingw/msvc, llvm的clang/clang++, make,cmake</a></li><li>[8] <a href=https://b23.tv/pdhEbrN target=_blank rel="external nofollow noopener noreferrer">LLVM架构</a>(<a href=https://github.com/chenzomi12/DeepLearningSystem/tree/main/Compiler/AICompiler target=_blank rel="external nofollow noopener noreferrer">相关资料</a>)</li><li>[9] <a href="https://www.bilibili.com/video/BV1bg411p7oS/?vd_source=98d46c524d240bd89f118ad90be17aef" target=_blank rel="external nofollow noopener noreferrer">CMake入门</a></li></ul></blockquote><h3 id=ninja>Ninja</h3><p>Ninja 同 Make 一样都属于构建系统，最大的特点是构建速度快。同时其也可与CMake结合使用，使用流程如下图所示:</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202403081626149.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h2 id=编译流程>编译流程</h2><blockquote><p>以gcc为例
集成开发环境一键式完成的过程，将编译和链接进行合并，此过程称为构建（Build）</p></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png srcset="https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png?size=small, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png data-alt=https://cdn.jsdelivr.net/gh/G-ghy/cloudImages@master/202301191738098.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>关于编译选项的详细解释见 <a href=https://gcc.gnu.org/onlinedocs/ target=_blank rel="external nofollow noopener noreferrer">GCC online documentation</a> -> <a href=https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/ target=_blank rel="external nofollow noopener noreferrer">GCC Manual</a> -> <a href=https://gcc.gnu.org/onlinedocs/gcc-13.2.0/gcc/#toc-GCC-Command-Options target=_blank rel="external nofollow noopener noreferrer">GCC Command Options</a></p></blockquote><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202308241020458.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><h3 id=预处理预编译>预处理(预编译)</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090842630.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><ul><li>头文件包含: 处理 <code>#include</code></li><li><a href=https://baike.baidu.com/item/%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91 target=_blank rel="external nofollow noopener noreferrer">条件编译</a>: 处理 <code>#if</code>, <code>#else</code>, <code>#endif</code> 等等条件编译指令</li><li>宏替换: 处理#define, 将宏展开</li><li>删除注释</li></ul></blockquote><div class=highlight id=id-2><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>cpp hello.c &gt; hello.i
</span></span><span class=line><span class=cl>gcc -E hello.c -o hello.i</span></span></code></pre></td></tr></table></div></div><p>若要检查宏定义或头文件包含是否正确时，可查看预编译后的文件</p><p>使用<code>file</code>命令可以查看预处理后文件类型如下：</p><blockquote><p>main.i: C source, ASCII text</p></blockquote><h3 id=编译>编译</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090844783.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>词法，语法，语义分析，生成汇编代码</p></blockquote><div class=highlight id=id-3><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>gcc -S hello.i -o hello.s
</span></span><span class=line><span class=cl>gcc -S hello.c -o hello.s</span></span></code></pre></td></tr></table></div></div><p>使用<code>file</code>命令可以查看编译后文件类型如下：</p><blockquote><p>main.s: assembler source, ASCII text</p></blockquote><h3 id=汇编>汇编</h3><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311090845168.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>将汇编语言转化为相应的机器语言(二进制目标文件)</p></blockquote><div class=highlight id=id-4><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>as hello.s -o hello.o
</span></span><span class=line><span class=cl>gcc -c hello.s -o hello.o
</span></span><span class=line><span class=cl>gcc -c hello.c -o hello.o</span></span></code></pre></td></tr></table></div></div><p>使用<code>file</code>命令可以查看汇编后文件类型如下：</p><blockquote><p>main.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</p></blockquote><p>注：关于"not stripped"，和<code>strip</code>命令有关，表示没有Removes symbols and sections of files.</p><h3 id=链接>链接</h3><blockquote><p>将多个可重定位目标文件和标准库函数合并为可执行目标文件</p></blockquote><p>在链接之前，各个程序模块都是相互独立的，模块A所使用到的模块B的内容，在模块A的视角下仅仅是一个符号，并不清楚其具体内容。链接过程可以理解为把模块B的内容结合到A中。整个过程类似搭积木最后的模块拼接过程。</p><p><strong>说明</strong></p><p>Windows 下的链接过程涉及的知识和 Linux 下并不完全相同，以下内容仅面向 Linux 下的链接过程</p><h4 id=相关概念解析>相关概念解析</h4><ol><li>ELF格式文件分类</li></ol><table><thead><tr><th>文件类型</th><th>说明</th><th>实例</th></tr></thead><tbody><tr><td>可重定位文件(Relocatable File)</td><td></td><td>Linux的.o (对应Windows的.obj)</td></tr><tr><td>共享目标文件(Shared Object File)</td><td></td><td>Linux的.so (对应Windows的.dll)</td></tr><tr><td>可执行文件(Executable File)</td><td></td><td>Linux的/bin目录下的程序 (对应Windows的.exe)</td></tr><tr><td>核心转储文件(Core Dump File)</td><td>当进程意外终止时，系统将进程的地址空间的内容及终止时的信息转储到该文件中</td><td>Linux的core dump</td></tr></tbody></table><blockquote><p>Note: The <strong>ELF</strong> (Executable and Linkable Format) file format corresponds to <strong>Linux</strong>, the <strong>PE</strong> (Portable Executable) file format corresponds to <strong>Windows</strong> and the <strong>Mach-O</strong> (Mach Object) corresponds to <strong>macOS</strong>.</p></blockquote><ol start=2><li>library分类</li></ol><ul><li>静态链接库：static library, 一种文件归档(archive). relocatable Files + 索引(index) -> static library</li></ul><blockquote><p>静态链接库(libadd.a)的文件格式:</p><p>libadd.a: current ar archive</p></blockquote><ul><li>动态链接库：shared library(Linux) / dynamic link library(Windows)</li></ul><blockquote><p>动态链接库(libadd.so)的文件格式：</p><p>libadd.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=644e95c7d3f9bd18796622c3041e7653e402d179, not stripped</p></blockquote><p>从本质上来说就是以上这两种，但是如果采用的链接方式是显示运行时链接，那么利用到的library又被称作dynamic loading library，使用的仍然是xxx.so文件，只是换了一种使用方式</p><ol start=3><li>链接方式</li></ol><ul><li>静态链接：使用<code>-static</code>选项，仅使用静态链接器，在编译链接过程中就将其他模块装入可执行文件中</li></ul><blockquote><p>静态链接生成的可执行目标文件的文件格式：</p><p>main: ELF 64-bit LSB executable, x86-64, version 1 (GNU/Linux), statically linked, for GNU/Linux 3.2.0, BuildID[sha1]=65422291d167d002123191a5f63d9a5503d6d670, not stripped</p></blockquote><ul><li>动态链接：默认的链接方式, 同时使用静态链接器和动态链接器，动态链接器在<strong>运行前</strong>将共享模块装载进内存并进行重定位操作</li></ul><blockquote><p>动态链接生成的可执行目标文件的文件格式：</p><p>main: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=3e226365a1d11bf52e8c7f5b4b9a72bbecbd7007, not stripped</p></blockquote><ul><li>显示运行时链接(Explicit Run-time Linking): 通过某些机制在运行时将共享模块装载进内存并进行重定位操作，让程序在运行时加载或卸载共享模块</li></ul><p><strong>关于library种类和链接方式之间的关系，容易产生的一个误解</strong></p><p>静态链接库，动态链接库 和 静态链接，动态链接，这些名称很容易带给人一种误解: 采用静态链接库时采用的就是静态链接，使用动态链接库时采用的就是动态链接。</p><p>首先从链接方式的分类来说，静态还是动态链接是由编译选项<code>-static</code>决定的，并不是采用了静态链接库还是动态链接库决定的。</p><p>但是它们之间并不是没有关系，从另一个角度来说，根据GNU文档<a href=https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#index-static target=_blank rel="external nofollow noopener noreferrer">Options for Linking - static</a>对于static选项的描述</p><blockquote><p>prevents linking with the shared libraries</p></blockquote><p>可以看出，当我们使用static选项进行静态链接时，使用的只能是静态链接库。</p><p>所以，关于库和链接方式的对应关系，需要从两个方向进行讲述：</p><ul><li>使用静态链接库时，进行的可以是静态链接 或 动态链接； 使用动态链接库，只能进行动态链接</li><li>进行静态链接时，只能使用静态链接库；进行动态链接时，可以使用静态链接库或动态链接库</li></ul><p>i.e. <strong>使用静态链接库是进行静态链接的必要不充分条件, 使用动态链接库是进行动态链接的充分不必要条件</strong></p><blockquote><p>注：后半句的表述并不是非常准确，因为在现行系统下，进行动态链接都会利用到一个特殊的动态链接库-动态链接器，同时C/C++程序无论是否调用一些函数，都会链接libc.so(这一点判断还没有寻找确切的证据，仅是根据实际测试结果)，从这个角度来说，使用动态链接库是进行动态链接的充要条件，而上面的表述仅仅是为了表述库和链接方式的那2点对应关系，所以给出的是充分不必要条件</p></blockquote><p>重新分析上述给出的那种误解，采用静态链接库时，如果没有给出<code>-static</code>选项，那么这时候进行的是动态链接，这正验证了使用静态链接库对于进行静态链接的不充分性</p><p>除了上述提出的各类问题，还会涉及到一个比较隐含的问题。上面提到使用静态链接库可以进行静态链接，但是在注中又提到一个事实，即虽然我们人为仅仅指定了一些静态链接库，但是背后会隐含利用一些特殊的动态链接库。动态链接库是不可以进行静态链接的，但是为何在进行静态链接时，这些特殊的动态链接库并没有报错。</p><p>事实上，这些动态链接库，都存在着与之对应的静态链接库，在我们添加<code>-static</code>选项后，链接使用的就是这些静态链接库。e.g. libc.so就存在一个libc.a的静态链接库（可通过命令<code>find /usr/lib /usr/local/lib -name "libc.a"</code>查找到）</p><ol start=4><li>链接到底在完成一件什么事情？</li></ol><p>简单来说就是重定向。</p><ul><li>静态链接 -> 静态地址重定位， 地址在编译时就已经确定</li><li>动态链接 -> 装载时地址重定位，地址在编译时是相对地址，具体的绝对地址在加载时由装载器（Loader）进行计算和修改</li><li>显示运行时链接 -> 运行时地址重定位</li></ul><h4 id=静态链接库>静态链接库</h4><p>静态链接是可执行目标文件在构建过程中完成的，使用链接器将多个.o可重定位目标文件结合（实际上也可以将.so动态链接库结合进来，在动态链接部分详细说明），生成可执行目标文件。</p><p>静态链接库：Windows平台.lib (library)，Linux平台.a (archive)</p><p>假设编写一个包含加法运算的静态链接库，供main函数调用</p><div class=highlight id=id-5><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// add.cpp
</span></span><span class=line><span class=cl>int fun(int a, int b) {
</span></span><span class=line><span class=cl>     return a + b;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><div class=highlight id=id-6><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// main.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>fun</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>使用<code>ar</code>命令将汇编过程生成的.o可重定位目标文件生成静态链接库</p><div class=highlight id=id-7><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>g++ -c add.cpp -o add.o
</span></span><span class=line><span class=cl>ar -rsv libadd.a add.o</span></span></code></pre></td></tr></table></div></div><blockquote><p><code>ar -rsv</code>: 以输出较多信息的方式，完成下述任务：创建归档文件的同时，创建归档索引</p></blockquote><p>使用<code>file</code>命令可以查看生成的文件类型如下：</p><blockquote><p>libadd.a: current ar archive</p></blockquote><p>在链接环节链接该静态链接库（假设libadd.o和main.cpp在同一路径下)</p><div class=highlight id=id-8><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>g++ main.cpp -L. -ladd</span></span></code></pre></td></tr></table></div></div><p>以上就是一个创建及使用静态链接库的全流程。
值得注意的是Linux下静态链接库的本质，查询一下<code>ar</code>命令会发现，其不过是一个创建归档文件的命令，和目前的<code>tar</code>作用是类似的。
因此，所谓静态链接库不过是把一些.o可重定位目标文件集中起来放置到一个文件中，以便链接环节将各模块结合在一起。
不过<code>tar</code>和<code>ar</code>创建的归档格式并不相同，仅<code>ar</code>才能用于创建静态链接库。</p><p>为何要用.a这种归档格式作为静态链接库？
把这些零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织方面的不便，于是通常人们使用“ar”压缩程序将这些目标文件压缩到一起，并且对其进行编号和索引，以便于查找和检索，就形成了.a这种归档格式的静态库文件</p><p><code>tar</code>创建的归档格式如下：</p><blockquote><p>libadd.a: POSIX tar archive (GNU)</p></blockquote><p>静态链接库在构建过程中的参与情况示意图：</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202311091009376.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>注：从图中也可以看出.a文件本身只是.o文件的一个容器，实际参与链接过程的仍然是.o可重定位目标文件</p></blockquote><p><strong>静态链接的缺点</strong>
静态链接是将所需的所有库文件内容进行整合，全部装入到可执行文件中，这种方式会带来以下两种问题：</p><ol><li>内存和磁盘空间浪费严重：共用相同库文件的，不同的可执行程序中都存在着相同的库文件，如下图所示</li></ol><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011609985.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><ol start=2><li>程序更新不便：更新可执行程序所用的其中一个库文件需要重新下载整个可执行程序</li></ol><h4 id=动态链接库>动态链接库</h4><p><strong>动态链接的动态指的是哪个环节是动态的？/ 什么是动态链接库？</strong></p><p>所谓动态链接，这里有两种不同的描述，在《程序员的自我修养-链接、装载与库》中的说法大概描述是：不在编译链接环节对那些组成程序的目标文件进行链接，而是等到程序运行时才进行链接“。但是根据下面的动态链接流程图，动态链接大致可以理解为：动态链接 = 编译链接环节的部分链接 + 程序运行时的完全链接。</p><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><p>我目前对这一点的理解是，编译链接环节的输出结果只是保存了程序需要使用到哪些库（也就是<code>ldd</code>能够查询到的那些），然后在程序运行过程中由动态链接器来完成实际的链接过程。所以说以上两种说法其实都没什么问题，真实链接的过程确实是在运行阶段由动态链接器完成的，但是编译链接环节确实也使用到链接器经历了一次链接环节，所以说成部分链接倒是也合理</p><p>动态链接库：Windows平台动态链接库.dll (dynamic link library)，Linux平台共享对象文件.so (shared object file)</p><p>仍然采用静态链接库的场景，构建动态链接库。</p><div class=highlight id=id-9><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// add.cpp
</span></span><span class=line><span class=cl>int fun(int a, int b) {
</span></span><span class=line><span class=cl>     return a + b;
</span></span><span class=line><span class=cl>}</span></span></code></pre></td></tr></table></div></div><div class=highlight id=id-10><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c++ data-lang=c++><span class=line><span class=cl><span class=c1>// main.cpp
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>fun</span><span class=p>(</span><span class=kt>int</span><span class=p>,</span> <span class=kt>int</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=n>fun</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>     <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span></span></span></code></pre></td></tr></table></div></div><p>创建动态链接库：
与创建静态链接库不同，由于静态链接库本质上就是可执行重定位文件的一个归档，因此必须首先生成.o。
动态链接库似乎经历了完整的构建流程，所以是对add.cpp还是对add.o都是可以的</p><div class=highlight id=id-11><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>g++ add.cpp -fpic -shared -o libadd.so</span></span></code></pre></td></tr></table></div></div><p>在链接环节链接该动态链接库（假设libadd.so和main.cpp在同一路径下)</p><div class=highlight id=id-12><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>g++ main.cpp -L. -ladd</span></span></code></pre></td></tr></table></div></div><h5 id=动态链接包含2个链接过程>动态链接包含2个链接过程</h5><p>使用动态链接库和静态链接库的一个显著区别在于：使用静态链接库时，程序构建完成了就可以直接执行了，但是使用动态链接库，程序构建完成并不一定表示可以正常执行。
In other words, 程序构建和程序执行是两个显著分离的过程。</p><p>在静态链接库的链接过程中，使用的的命令是g++ main.cpp -L. -ladd。
同样的，在使用动态链接库时也一样可以使用这一条命令，程序可以正常构建。但是一旦执行程序，会报以下错误：</p><blockquote><p>./main: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory</p></blockquote><p>通过<code>ldd</code>命令(MacOS下可以使用<code>otool -L</code>)检查可执行目标文件所需的动态链接库：</p><blockquote><p>linux-vdso.so.1 (0x00007ffe113c2000)</p><p><strong>libadd.so => not found</strong></p><p>libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f4aa5de5000)</p><p>libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f4aa59f4000)</p><p>libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f4aa5656000)</p><p>/lib64/ld-linux-x86-64.so.2 (0x00007f4aa6370000)</p><p>libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f4aa543e000)</p></blockquote><p>可以发现，程序找不到libadd.so这一动态链接库。</p><h5 id=在编译时已经通过-l指定了库的搜索路径为何此时仍然找不到>在编译时已经通过<code>-L.</code>指定了库的搜索路径，为何此时仍然找不到?</h5><p>We mentioned above that using dynamic libraries is divided into two stages: the first is using static linker, the second is using dynamic linker.</p><p>The compile command option <code>-L. -ladd</code> helps the static linker to find the libraries file, but it doesn&rsquo;t work for dynamic linker.</p><p>So, the first linking stage can complete successfully and the second linking stage will encounter &ldquo;No such file or directory&rdquo; error.</p><h5 id=动态链接器如何查找到所需的库文件dynamic_linker_search_way_of_libraries>动态链接器如何查找到所需的库文件?<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup></h5><p>动态链接器搜索库文件的顺序如下：</p><p><strong>1. 使用指定的路径名</strong></p><p>对于最开始引入的动态链接库的应用示例，修改编译命令<code>g++ main.cpp ./libadd.so -o main</code>，此时在和libadd.so相同路径下即可正常执行可执行目标文件。通过<code>ldd</code>命令可以发现内容有所改变</p><blockquote><p>linux-vdso.so.1 (0x00007fff8a570000)</p><p><strong>./libadd_dynamic.so (0x00007f5421cea000)</strong></p><p>libstdc++.so.6 => /usr/lib/x86_64-linux-gnu/libstdc++.so.6 (0x00007f5421961000)</p><p>libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5421570000)</p><p>libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007f54211d2000)</p><p>/lib64/ld-linux-x86-64.so.2 (0x00007f54220ee000)</p><p>libgcc_s.so.1 => /lib/x86_64-linux-gnu/libgcc_s.so.1 (0x00007f5420fba000)</p></blockquote><p>关于这种方式的实现机理，通过 <code>readelf -d main</code> 命令可以查询到 ELF 文件的 .dynamic section 内容， 同 <code>g++ main.cpp -o main</code> 编译得到的文件的 <code>readelf</code> 命令的执行结果的关键差别如下所示：</p><div class=highlight id=id-13><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=c1># g++ main.cpp -o main 结果</span>
</span></span><span class=line><span class=cl>Tag        Type                         Name/Value
</span></span><span class=line><span class=cl>0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>libadd.so<span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1># g++ main.cpp ./libadd.so -o main </span>
</span></span><span class=line><span class=cl>Tag        Type                         Name/Value
</span></span><span class=line><span class=cl>0x0000000000000001 <span class=o>(</span>NEEDED<span class=o>)</span>             Shared library: <span class=o>[</span>./libadd.so<span class=o>]</span></span></span></code></pre></td></tr></table></div></div><p><strong>2. 使用 <code>DT_RPATH</code> 中指定的目录</strong></p><p>We can use compile option <code>-Wl,-rpath,/custom/rpath/</code> to specify the path in the executable file for the dynamic linker.</p><p>It is similar to the first method, because it affects the dynamic linker also with the help of ELF file format&rsquo;s .dynamic section. We can use the command <code>readelf -d &lt;binary_name> | grep 'R.*PATH'</code> to verify it.</p><p><strong>3. 使用环境变量 <code>LD_LIBRARY_PATH</code></strong></p><p>修改环境变量<code>LD_LIBRARY_PATH</code>（macOS下为<code>DYLD_LIBRARY_PATH</code>），将libadd.so所在路径添加到环境变量中</p><p>有几点注意事项：</p><ol><li>根据<a href=https://gaohongy.github.io/blog/posts/linux/comparison-of-shell-script-execution-modes/ target=_blank rel="external nofollow noopener noreferrer">Comparison of Shell Script Execution Modes</a>的知识，可执行文件的执行会在子进程中进行，因此此处的变量需要设置为<a href=https://gaohongy.github.io/blog/posts/linux/variables-in-linux/ target=_blank rel="external nofollow noopener noreferrer">Environment/Global Variables</a>以便子进程可以访问到。</li><li>在 macOS 下，<code>DYLD_LIBRARY_PATH</code> 无法被设置为环境变量，即执行<code>env | grep DYLD_LIBRARY_PATH</code>结果为空。对于这个奇怪的现象，在<code>man dyld</code>中有下面一则提示</li></ol><blockquote><p>Note: If System Integrity Protection is enabled, these environment variables are ignored when executing binaries protected by System Integrity Protection.</p></blockquote><p>截止到更新此处内容时，还并没有尝试关闭 System Integrity Protection 来测试是否是这种安全机制导致的这种奇怪现象，目前暂且认为是如此。</p><p><strong>4. 使用 <code>DT_RUNPATH</code> 中指定的目录</strong></p><p>这种方式和滴2种方法有着一定联系，暂时没有遇到相关应用场景，暂时按下不表待后续完善</p><p>如果二进制文件中存在 DT_RUNPATH 动态段属性，则动态链接器会搜索这些目录。这些目录仅用于查找 DT_NEEDED（直接依赖项）条目所需的对象，不适用于这些对象的子对象，这些子对象必须自己有自己的 DT_RUNPATH 条目。这与 DT_RPATH 不同，后者适用于依赖树中所有子对象的搜索。</p><p><strong>5. 从缓存文件 <code>/etc/ld.so.cache</code> 中搜索</strong></p><p>按照目前理解，如果期望使用这种方式，需要首先将期望被搜索的路径添加到 <code>/etc/ld.so.conf</code> 文件中，然后通过 <code>sudo ldconfig</code> 构建出新的 <code>/etc/ld.so.cache</code>，然后 dynamic linker 就会根据 <code>ld.so.cache</code> 来进行搜索</p><p>由于未涉及到相关应用常见，此方法还未经测试，等待后续测试完善</p><p><strong>6. 在默认路径中搜索</strong></p><p>默认路径包括 /lib 和 /usr/lib（某些 64 位架构中，默认路径为 /lib64 和 /usr/lib64）</p><p>在上述示例中，把生成的libadd.so移动到/usr/local/lib等默认搜索路径（根据现有理解，<code>make install</code>所做的工作就是将相关文件复制到这些默认的搜索路径当中，但是个人并不是很推荐这种做法，因为直接采用默认搜索路径就类似黑盒，在不同设备中默认设置并不一定相同，显式给出各种信息会使得编译链接过程更加清晰明了）</p><h5 id=动态链接库在构建和执行过程中的参与情况示意图>动态链接库在构建和执行过程中的参与情况示意图</h5><p><a class=lightgallery href="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=large" data-thumbnail="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=small" data-sub-html="<h2>https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png</h2>"><img loading=lazy src=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png srcset="https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=small, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=medium 1.5x, https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png?size=large 2x" sizes=auto data-title=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png data-alt=https://cdn.jsdelivr.net/gh/gaohongy/cloudImages@master/202401011657893.png style="background:url(/blog/svg/loading.min.svg)no-repeat 50%" onload='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e);this.dataset.lazyloaded=""' onerror='this.title=this.dataset.title,this.alt=this.dataset.alt;for(const e of["style","data-title","data-alt","onerror","onload"])this.removeAttribute(e)'></a></p><blockquote><p>注：从图上也可以验证上述的说法，相较于静态链接库，动态链接库在构建过程和执行过程中都会发挥作用</p><p>静态链接器和动态链接器都分别完成了哪些工作 / 从动态链接的流程图中可以看出，xxx.so文件同时参与静态链接库和动态链接库两个链接过程，在这两个过程中这个library分别起到了什么作用?</p><p>答：假设程序P.cpp使用到了一个其他库中定义的函数fun()。当程序P.cpp被编译为P.o之后，编译器是不知道fun()函数的地址的。如果fun()是static library中的函数，那么静态链接器会根据所用的static library，直接将P.o中的fun()函数的地址进行重定位。如果fun()是shared library中的，那么静态链接器会将其标记为动态链接的符号，等到装载时由动态链接器完成重定位。可见，xxx.so需要被用到两次</p></blockquote><h2 id=reference>Reference</h2><blockquote><ul><li>[1] <a href=https://opensource.apple.com/source/clang/clang-23/clang/tools/clang/www/comparison.html target=_blank rel="external nofollow noopener noreferrer">Clang vs Other Open Source Compilers</a></li><li>[2] <a href="https://www.bilibili.com/video/BV18j411B7TF/?spm_id_from=333.788.recommend_more_video.1&amp;vd_source=98d46c524d240bd89f118ad90be17aef" target=_blank rel="external nofollow noopener noreferrer">LLVM整体设计</a></li><li>[3] <a href=https://alibabatech.medium.com/gcc-vs-clang-llvm-an-in-depth-comparison-of-c-c-compilers-899ede2be378 target=_blank rel="external nofollow noopener noreferrer">GCC vs. Clang/LLVM: An In-Depth Comparison of C/C++ Compilers</a></li><li>[4] <a href=https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html target=_blank rel="external nofollow noopener noreferrer">gcc Optimize Options</a></li><li>[5] <a href=https://blog.csdn.net/weixin_44966641/article/details/120659285 target=_blank rel="external nofollow noopener noreferrer">Linux下编译Opencv</a>(<a href=https://www.cnblogs.com/hongyugao/p/17822192.html target=_blank rel="external nofollow noopener noreferrer">备份</a>)</li><li>[6] <a href="https://blog.csdn.net/weixin_44966641/article/details/120631079?spm=1001.2014.3001.5501" target=_blank rel="external nofollow noopener noreferrer">ELF文件格式解析</a>(<a href=https://www.cnblogs.com/hongyugao/p/17822204.html target=_blank rel="external nofollow noopener noreferrer">备份</a>)</li><li>[7] <a href=https://tldp.org/HOWTO/Program-Library-HOWTO/index.html target=_blank rel="external nofollow noopener noreferrer">How to create and use program libraries on Linux</a></li><li>[8] <a href=https://blog.ideawand.com/2020/02/15/how-does-linux-shared-library-versioning-works/ target=_blank rel="external nofollow noopener noreferrer">一文读懂Linux下动态链接库版本管理及查找加载方式</a></li></ul></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>关于驱动器的说法，目前只在<a href="https://gcc.gnu.org/onlinedocs/gcc/Link-Options.html#:~:text=Therefore%2C%20the-,G%2B%2B%20driver,-automatically%20adds%20%2Dshared" target=_blank rel="external nofollow noopener noreferrer">gcc/g++链接选项</a>一文中看到相关说法&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p><a href=https://github.com/mebusy/notes/blob/master/dev_notes/CLib.md target=_blank rel="external nofollow noopener noreferrer">理清gcc、libc、libstdc++的关系</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><a href="https://en.wikipedia.org/wiki/Rpath#cite_note-1:~:text=The%20dynamic%20linker%20of%20the%20GNU%20C%20Library%20searches%20for%20shared%20libraries%20in%20the%20following%20locations%20in%20order%3A" target=_blank rel="external nofollow noopener noreferrer">Linux / Unix Command: ld.so</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span title="更新于 2024-04-20 00:51:53">更新于 2024-04-20&nbsp;</span></div></div><div class=post-info-line><div class=post-info-md><span><a href=https://github.com/gaohongy/blog/edit/main/content/posts/Compile-Link/C-C++-Compile-Link.md title=编辑此页 target=_blank rel="external nofollow noopener noreferrer" class=link-to-edit>编辑此页</a></span></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/posts/algorithm/branch-bound-algorithm/ class=post-nav-item rel=prev title="Branch Bound Algorithm"><i class="fa-solid fa-angle-left fa-fw" aria-hidden=true></i>Branch Bound Algorithm</a>
<a href=/blog/posts/hpc/kokkos-source-code-analysis/ class=post-nav-item rel=next title="Kokkos Source Code Analysis">Kokkos Source Code Analysis<i class="fa-solid fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></main></div><div class=widgets><div class="fixed-buttons animate__faster d-none"><div class="fixed-button back-to-top" role=button aria-label=回到顶部><i class="fa-solid fa-arrow-up fa-fw" aria-hidden=true></i><span class=variant-numeric>0%</span></div></div><div id=mask></div><div class=reading-progress-bar style=left:0;top:0></div><noscript><div class=noscript-warning>FixIt 主题在启用 JavaScript 的情况下效果最佳。</div></noscript></div><link rel=stylesheet href=/blog/lib/lightgallery/css/lightgallery-bundle.min.css><link rel=stylesheet href=/blog/lib/katex/katex.min.css><link rel=stylesheet href=/blog/lib/cookieconsent/cookieconsent.min.css><script src=/blog/lib/autocomplete/autocomplete.min.js defer></script><script src=/blog/lib/fuse/fuse.min.js defer></script><script src=/blog/lib/twemoji/twemoji.min.js defer></script><script src=/blog/lib/lightgallery/lightgallery.min.js defer></script><script src=/blog/lib/lightgallery/plugins/thumbnail/lg-thumbnail.min.js defer></script><script src=/blog/lib/lightgallery/plugins/zoom/lg-zoom.min.js defer></script><script src=/blog/lib/katex/katex.min.js defer></script><script src=/blog/lib/katex/auto-render.min.js defer></script><script src=/blog/lib/katex/copy-tex.min.js defer></script><script src=/blog/lib/katex/mhchem.min.js defer></script><script src=/blog/lib/cookieconsent/cookieconsent.min.js defer></script><script>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{enable:!1},cookieconsent:{content:{dismiss:"同意",link:"了解更多",message:"本网站使用 Cookies 来改善您的浏览体验。"},enable:!0,palette:{button:{background:"#f0f0f0"},popup:{background:"#1aa3ff"}},theme:"edgeless"},lightgallery:!0,math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{distance:100,findAllMatches:!1,fuseIndexURL:"/blog/index.json",highlightTag:"em",ignoreFieldNorm:!1,ignoreLocation:!1,isCaseSensitive:!1,location:0,maxResultLength:20,minMatchCharLength:2,noResultsFound:"没有找到结果",snippetLength:50,threshold:.3,type:"fuse",useExtendedSearch:!1},twemoji:!0}</script><script src=/blog/js/theme.min.js defer></script></body></html>