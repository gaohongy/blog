<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 -</title><link>https://gaohongy.github.io/blog/posts/</link><description>所有文章 |</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Fri, 07 Jun 2024 09:49:52 +0800</lastBuildDate><atom:link href="https://gaohongy.github.io/blog/posts/" rel="self" type="application/rss+xml"/><item><title>Heterogeneous Compilation</title><link>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</link><pubDate>Fri, 07 Jun 2024 09:49:52 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/compile-link/heterogeneous-compilation/</guid><description>与 CUDA Compilation 不同在于 The tools used in the CUDA compilation are all closed source except gcc, g++ etc., for example fatbinary and nvlink. We need to substitue these tools to tools in clang system. Clang Offload Bundler is used to combined different code for different machine structurel. Clang Offload Packager is used to embed device code into host code. Clang Linker Wrapper is used to .</description></item><item><title>Several Methods For Obtaining Time</title><link>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</link><pubDate>Tue, 04 Jun 2024 11:38:22 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/several-methods-for-obtaining-time/</guid><description>We can reference this article
About the last method that using rdtsc assembly command to obtain time, there are some error prone points, we can reference to this article.
If you want to learn about the TST, please reference to this article.</description></item><item><title>SIMD Extension</title><link>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</link><pubDate>Mon, 03 Jun 2024 16:09:29 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/simd-extension/</guid><description>说明 SIMD Extension 的各种函数中参数的顺序以及各种函数的实现机制都是遵循着机器在实际存储时采用的小端序，注意在和数组混用时可能会产生一定思维上的混乱。 Categories</description></item><item><title>OpenMP</title><link>https://gaohongy.github.io/blog/posts/hpc/openmp/</link><pubDate>Tue, 30 Apr 2024 20:49:00 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/openmp/</guid><description><![CDATA[Check the OpenMP version 1 2 3 4 5 6 7 8 9 10 #include &lt;stdio.h&gt; int main() { #ifdef _OPENMP printf(&#34;OpenMP version: %d\n&#34;, _OPENMP); #else printf(&#34;OpenMP is not supported.\n&#34;); #endif return 0; } If system supports the OpenMP, you will receive similar output results OpenMP version: 201511 &ldquo;201511&rdquo; means that this OpenMP is released in November 2015. Next, you need to go to this official website to search the]]></description></item><item><title>Matrix Multiplication</title><link>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</link><pubDate>Sun, 28 Apr 2024 10:00:06 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/matrix-multiplication/</guid><description>GEMM（General Matrix Multiplication）-通用矩阵乘 BLAS (Basic Linear Algebra Subprograms) - 基本线性代数子程序 SGEMM (Single precision General Matrix Multiply) - 单精度矩阵乘法 DGEMM (Double precision General Matrix Multiply) -</description></item><item><title>Debugging in Visual Studio Code</title><link>https://gaohongy.github.io/blog/posts/project-experience/debugging-in-visual-studio-code/</link><pubDate>Thu, 18 Apr 2024 11:48:47 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/project-experience/debugging-in-visual-studio-code/</guid><description>整体理解 从宏观上来讲，调试程序的两大场景： 单程序写完后直接运行调试 大型项目编译完成后，需要结合源码对某一个可执行程序进行执行流分析 实际上这看</description></item><item><title>Polymorphism</title><link>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</link><pubDate>Mon, 15 Apr 2024 11:54:10 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/c-c++/polymorphism/</guid><description>谈及多态主要是在考虑具有继承关系的多个类型之间的关系。考虑多态的核心在于引用或指针的 静态类型 与 动态类型 是可能不同的 静态多态 和 动态多态 的一个明</description></item><item><title>principle of software version control in Linux</title><link>https://gaohongy.github.io/blog/posts/linux/principle-of-software-version-control-in-linux/</link><pubDate>Mon, 08 Apr 2024 17:45:39 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/linux/principle-of-software-version-control-in-linux/</guid><description>In Linux, sometimes we will face to a software which has many editions, such as gcc and java. In different scenes, maybe we need different editions of the same software, so we must save all of them. But how can we switch them?
Linux uses the symlink to allow user easily switching between programs.
Then, we use the gcc as an example to illustrate the principle of software version control.</description></item><item><title>Memory Alignment</title><link>https://gaohongy.github.io/blog/posts/hpc/memory-alignment/</link><pubDate>Sat, 23 Mar 2024 21:08:23 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/hpc/memory-alignment/</guid><description>内存的编址单位是字节 但是内存 IO 的单位是字长，此数值应当和 数据通路 的宽度有关，当数据通路为 32 位时，那么一次内存 IO 就会读取4B数据1 对于上述内容</description></item><item><title>Graph Compiler</title><link>https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/</link><pubDate>Thu, 07 Mar 2024 21:26:29 +0800</pubDate><author>ghy</author><guid>https://gaohongy.github.io/blog/posts/graph-computing/graph-compiler/</guid><description>对于系统结构的理解 主要是对于 应用层代码，编译层 和 运行时库 之间关系的理解 在此之前，需要首先考虑一下到底什么是 ”运行时库“，我们所能接触到的一个</description></item></channel></rss>